
<br/> 
<ul>
 <li> <a href="#1">Introduction</a></li>
  <ul>
   <li><a href="#1.1">Informal Motivating Example: Random Number Generation</a></li>
  </ul>
 <li> <a href="#2">Review of Logic with Sets, Relations, and Operators</a>
  <ul>
   <li><a href="#2.1">Formulas (without quantifiers)</a></li>
   <li><a href="#2.2">Terms: integers and term operators that take integer inputs</a></li>
   <li><a href="#2.3">Formulas: relational operators and predicates dealing with integers</a></li>
   <li><a href="#2.4">Terms: finite sets of integers, term operators that take set inputs, and set comprehensions</a></li>
   <li><a href="#2.5">Formulas: quantifiers over finite sets of integers</a></li>
   <li><a href="#2.6">Formulas: predicates dealing with finite sets of integers</a></li>
   <li><a href="#2.7">Terms: set products and binary relations</a></li>
   <li><a href="#2.8">Formulas: predicates dealing with relations</a></li>
   <li><a href="#2.9"><b>Assignment #1: Prerequisite Review: Logic, Integers, Sets, and Relations</b></a></li>
   <li><a href="#2.10">Terms: set quotients and quotient maps</li>
   <li><a href="#2.11">Term operators and their properties</li>
  </ul>
 </li>
 <li> <a href="#3">Modular Arithmetic</a>
  <ul>
   <li><a href="#3.1">Terms: congruence classes in \Z/%m\Z and term operators on congruence classes</a></li>
   <li><a href="#3.2">Formulas: relational operators dealing with congruence classes in \Z/%m\Z</a></li>
   <li><a href="#3.3">Algebra of congruence classes</a></li>
   <li><a href="#3.4">Example: Random Number Generation</a></li>
   <li><a href="#3.5">Generating prime numbers</a></li>
   <li><a href="#3.6">Greatest common divisor and related facts</a></li>
   <li><a href="#3.7">Testing whether a number is probably prime</a></li>
   <li><a href="#3.8"><b>Assignment #2: Modular Arithmetic, Random Sequences, and Primes</b></a></li>
   <li><a href="#3.9">Chinese remainder theorem and applications</a></li>
   <li><a href="#3.10">Euler's totient function, multiplicative inverses in \Z/%m\Z, and applications</a></li>
   <li><a href="#3.11"><b>Assignment #3: CRT, Totient Function, Inverses, and Applications</b></a></li>
  </ul>
 </li>
 <li> <a href="#4">Complexity of modular arithmetic algorithms</a>
  <ul>
   <li><a href="#4.1">Complexity of (probably) intractable problems</a></li>
   <li><a href="#4.2">Complexity of algorithms for solving tractable problems</a></li>
   <li><a href="#4.3"><b>Assignment #4: Reductions, Quadratic Residues, and Review</b></a></li>
  </ul>
 </li>
 <li> <a href="#5"><b>Review #1</b></a></li>
 <li> <a href="#6">Algebraic Structures</a>
  <ul>
   <li><a href="#6.1">Algebraic Structures and Axioms</a></li>
   <li><a href="#6.2">Implementations of Algebraic Structures and Operations</a></li>
   <li><a href="#6.2a">Group of all permutations (symmetric group)</a></li>
   <li><a href="#6.2b">Groups of shift permutations (cyclic groups)</a></li>
   <li><a href="#6.3"><b>Assignment #5: Algebraic Structures and Permutations</b></a></li>
   <li><a href="#6.4">Isomorphisms: Equivalence of Algebraic Structures</a></li>
   <li><a href="#6.5">Reasoning about Algebraic Structures using Induction</a></li>
   <li><a href="#6.6">Subgroups and the Direct Product of Groups</a></li>
   <li><a href="#6.7">Algebraic Structures and Cosets</a></li>
   <li><a href="#6.8">Generalizations of CRT and Applications</a></li>
   <li><a href="#6.9"><b>Assignment #6: Generalizing CRT</b></a></li>
  </ul>
 </li>
 <li><a href="#8"><b>Review #2</b></a></li>
 <li><a href="#9"><b>Bonus Assignment</b></a></li>
</ul>

<a name="lecture1"></a> 
<a name="1"></a>
<hr style="margin-bottom:80px;"/>
<h2>Introduction</h2>

When many real-world problems are addressed or solved mathematically and computationally, the details of those problems are abstracted away until they
can be represented directly as idealized mathematical structures (e.g., numbers, sets, trees, graphs, matrices, and so on). In this course, we will
study a collection of such idealized mathematical objects: integers, groups, rings, residues, matrices, polynomials, and several others. We will
see how these structures and their properties can be used for implementing random number generators, error correcting codes,
defining simple cryptographic protocols, approximating and interpolating numerical functions, and other applications.

In covering the material for this course, we will use the standard language and conventions for discussing these mathematical structures that
have been developed by the mathematics community. You will need to become familiar with these conventions in order to find, identify, and use
the structures and techniques that have already been developed for solving certain computational problems. At the same time, we will also learn
how modern programming languages and programming paradigms can be used to implement these structures and algorithms both accessibly and efficiently.

The development and application of mathematics involves <i>abstraction</i>. A problem can be viewed at multiple levels of abstraction, and in
developing mathematics humans have adopted a variety of techniques that allow them to successfully employ abstraction to study natural phenomena
and solve problems.

<table class="fig_table">
 <tr>
  <td><b>symbolic</b></td>
  <td><b>abstract meaning</b></td>
  <td><b>concrete meaning in<br/>application domain</b></td>
 </tr>
 <tr> 
  <td>2+3</td>
  <td>5</td>
  <td>five objects</td>
 </tr>
 <tr> 
  <td>{(1,2),(1,3)}</td>
  <td>acyclic graph</td>
  <td>file system</td>
 </tr>
 <tr> 
  <td>{(1,2),(2,3),(3,1)}</td>
  <td>graph with cycle</td>
  <td>network</td>
 </tr>
</table>

The above illustrates the different levels of abstraction that may exist for a given problem. We employ a <i>language</i> of <i>symbols</i>
to denote certain abstract structures, which may correspond to actual structures in the world. A string of symbols corresponds to a particular
abstract object. Notice that the actual object being modelled and the abstract structure behave the same way, and that this behavior
implies certain rules about how we can manipulate the symbols without changing the object that they name. For example, we can represent the same graph
using the two strings of symbols "{(1,2),(2,3),(3,1)}" and "{(1,2),(2,3),(3,1)}", or the same number of objects using "2+3", "3+2", "1+4", and so on.

<a name="1.1"></a>
<h3>Informal Motivating Example: Random Number Generation</h3>

Let us informally consider the problem of generating a sequence of random positive integers.
Random number generators are needed in many situations and applications, including:
<ul>
  <li>generating unique identifiers for database records, objects, etc.;</li>
  <li>generating a one-time pad for a simple encryption scheme;</li>
  <li>generating public and private keys for more sophisticated encryption and signature schemes;</li>
  <li>simulation and approximation methods that employ random sampling (Monte-Carlo, and so on).</li>
</ul>
Different applications will impose different requirements on what is and is not a sufficiently "random" 
sequence of number. Suppose we adopt the following method:
<ul>
  <li>%n_0 = a number in the range (inclusive) 0 to 5;</li>
  <li>%n_%i = (2 \cdot %n_{i-1} + 1) \mod 6.</li>
</ul>
We can consider another method:
<ul>
  <li>%n_0 = an initial seed integer 10^4 > %n \geq 10^3;</li>
  <li>%n_%i = only the last four digits of %n_{i-1}^2.</li>
</ul>
Frequent repetition of a sequence may or may not be allowed in our given application. Does the above method produce repeating numbers? How often? For
how many initial seeds? How do we choose a good seed? We can measure a physical process or component (a clock, a keyboard), but even
under these circumstances we need a way to reason about the range of random values the measurement produces, and the range of random values
the application requires. How do we begin to approach and formally characterize these aspects of the problem so that we are certain we are
meeting the requirements imposed by the application?

One way to model a random number generation process is to view it is a permutation. In fact, there is more than one way to view the process as a
permutation. We could simply count up from 0 to %m and apply the same permutation to each 0 \leq %n \leq %m in order to produce the %nth random
number in the sequence. Is there an efficient way (i.e., using no more memory than O(\log %m)) to compute a random number from each
%n such that a number never repeats?

In this course we will learn about a variety of mathematical structures and their properties that will allow us to precisely specify the
above problem and others like it, to identify what solutions are appropriate for such a problem, and to implement these solutions correctly and,
where necessary, efficiently.

<a name="2"></a>
<hr style="margin-bottom:80px;"/>
<h2>Review of Logic with Sets, Relations, and Operators</h2>

In this section, we will review several abstract structures and associated properties (and the symbolic language used to represent them)
that you should have already encountered in past courses. Simultaneously, we will review one way in which these structures can be
implemented and manipulated within the modern programming language Python.

As with most human languages that have developed organically over time, mathematics has a rich and often redundant vocabulary. We introduce many
terms in this section that we will use consistently in this course. However, keep in mind that there are often other synonyms within
mathematics and computer science for these structures.

<a name="2.1"></a>
<h3>Formulas (without quantifiers)</h3>

A <i>logical formula</i> or <i>formula</i> is a string of symbols that follow a certain syntax. If the formula is written using a
correct syntax, we can ask whether the formula is <i>true</i> or <i>false</i>. The symbols <i>or</i>, <i>and</i>, <i>not</i>, <i>implies</i>, and
<i>iff</i> are <i>logical operators</i>.

<table class="fig_table">
 <tr>
  <td><b>formula</b></td>
  <td><b>true or false</b></td>
  <td><b>example of one possible<br/>Python representation</b></td>
 </tr>
 <tr> 
  <td>true</td>
  <td>always true</td>
  <td><code>True</code></td>
 </tr>
 <tr> 
  <td>false</td>
  <td>always false</td>
  <td><code>False</code>
  </td>
 </tr>
 <tr> 
  <td>%f_1 and %f_2</td>
  <td>only true if both %f_1 and %f_2 are true</td>
  <td><code>True and False</code></td>
 </tr>
 <tr> 
  <td>%f_1 or %f_2</td>
  <td>true if %f_1 or %f_2 (or both) are true</td>
  <td><code>True or (False and True)</code></td>
 </tr>
 <tr> 
  <td>%f_1 implies %f_2</td>
  <td>if %f_1 is true, then %f_2 must be true<br/><br/><i>or equivalently</i><br/><br/>%f_1 is false, or %f_2 is true</td>
  <td></td>
 </tr>
 <tr> 
  <td>%f_1 iff %f_2</td>
  <td>%f_1 and %f_2 are either both true or both false</td>
  <td><code>True == False</code></td>
 </tr>
 <tr> 
  <td>\neg %f</td>
  <td>true if %f is false</td>
  <td><code>not (True or (False and True))</code></td>
 </tr>
</table>

The following table may help with gaining a good intuition for the meaning of the <i>implies</i> operator.

<table class="fig_table">
 <tr>
  <td><b>meaning of<br/>left-hand side<br/>(premise)</b></td>
  <td><b>meaning of<br/>right-hand side<br/>(conclusion)</b></td>
  <td><b>meaning of<br/>entire formula</td>
  <td><b>comments</td>
 </tr>
 <tr> 
  <td>true</td>
  <td>true</td>
  <td>true</td>
  <td>if the premise is true and the conclusion<br/>is true, the claim of implication is true;<br/><br/>thus, the whole formula is true</td>
 </tr>
 <tr> 
  <td>true</td>
  <td>false</td>
  <td>false</td>
  <td>if the premise is true but the conclusion is<br/>false, the conclusion is <i>not</i> implied<br/>by the premise, so the 
 claim of implication<br/>is false; thus, the formula is false</td>
 </tr>
 <tr> 
  <td>false</td>
  <td>true</td>
  <td>true</td>
  <td>if the conclusion is true on its own, it doesn't matter<br/>that the premise is false, because <i>anything</i> implies<br/>an 
  independently true conclusion; thus, the claim<br/>of implication is true, and so is the<br/>entire formula</td>
 </tr>
 <tr> 
  <td>false</td>
  <td>false</td>
  <td>true</td>
  <td>if we assume that a false premise is true, then "false"<br/>itself is "true"; in other words, false<br/>implies itself, so 
     the formula is true</td>
 </tr>
</table>

<a name="2.2"></a>
<h3>Terms: integers and term operators that take integer inputs</h3>

A <i>term</i> is a string of symbols that represents some kind of mathematical structure. In our case, terms will initially
represent integers or sets of integers. Terms may contain <i>term operators</i>. We can view these as functions that take
terms as input and return terms as output. The term operators for terms that represent integers with which we will
be working are +, -, \cdot, and mod.

<table class="fig_table">
 <tr>
  <td><b>term</b></td>
  <td><b>what it represents</b></td>
  <td><b>example of one possible<br/>Python representation</b></td>
 </tr>
 <tr> 
  <td>0</td>
  <td>0</td>
  <td><code>0</code></td>
 </tr>
 <tr> 
  <td>1</td>
  <td>1</td>
  <td><code>1</code></td>
 </tr>
 <tr> 
  <td>%z_1 + %z_2</td>
  <td>the integer sum of %z_1 and %z_2</td>
  <td><code>3 + 4</code>
  </td>
 </tr>
 <tr> 
  <td>%z_1 - %z_2</td>
  <td>the integer difference of %z_1 and %z_2</td>
  <td><code>(1 + 2) - 4</code>
  </td>
 </tr>
 <tr> 
  <td>%z_1 \cdot %z_2</td>
  <td>the integer product of %z_1 and %z_2</td>
  <td><code>3 * 5</code>
  </td>
 </tr>
 <tr> 
  <td>%z_1 \mod %z_2</td>
  <td>the remainder of the integer quotient %z_1 / %z_2<br/>%z_1 - \lfloor %z_1/%z_2 \rfloor \cdot %z_2</td>
  <td><code>17 % 5</code>
  </td>
 </tr>
 <tr> 
  <td>%z_1^{%z_2}</td>
  <td>product of %z_2 instances of %z_1</td>
  <td><code>pow(2,3)</code>
  </td>
 </tr>
</table>

<a name="2.3"></a>
<h3>Formulas: relational operators and predicates dealing with integers</h3>

A term can only appear in a formula if it is an argument to a <i>predicate</i>. A few common predicates involving integers are
represented using <i>relational operators</i> (e.g, \leq, \geq).

<table class="fig_table">
 <tr>
  <td><b>formula</b></td>
  <td><b>what it represents</b></td>
  <td><b>example of one possible<br/>Python representation</b></td>
 </tr>
 <tr> 
  <td>%z_1 = %z_2</td>
  <td>true if %z_1 and %z_2<br/>have the same meaning;<br/>false otherwise</td>
  <td><code>1 == 2</code></td>
 </tr>
 <tr> 
  <td>%z_1 < %z_2</td>
  <td>true if %z_1 is less than %z_2;<br/>false otherwise</td>
  <td><code>4 < 3</code></td>
 </tr>
 <tr> 
  <td>%z_1 > %z_2</td>
  <td>true if %z_1 is greater than %z_2;<br/>false otherwise</td>
  <td><code>4 > 3</code></td>
 </tr>
 <tr> 
  <td>%z_1 \leq %z_2</td>
  <td>true if %z_1 is less than or equal to %z_2;<br/>false otherwise</td>
  <td><code>4 <= 3</code></td>
 </tr>
 <tr> 
  <td>%z_1 \geq %z_2</td>
  <td>true if %z_1 is greater than or equal to %z_2;<br/>false otherwise</td>
  <td><code>4 >= 3</code></td>
 </tr>
 <tr> 
  <td>%z_1 \neq %z_2</td>
  <td>true if %z_1 is not equal to %z_2;<br/>false otherwise</td>
  <td><code>4 != 3</code></td>
 </tr>
</table>

We can define our own predicates as well. Notice that one way we can represent these in Python is by defining a function that
return a boolean result.

<table class="fig_table">
 <tr>
  <td><b>predicate definition</b></td>
  <td><b>example of one possible<br/>Python representation</b></td>
 </tr>
 <tr> 
  <td>%P(%x) &nbsp;&nbsp;&nbsp; iff &nbsp;&nbsp;&nbsp; %x > 0 and %x < 2</td>
  <td><code>def P(x): return x > 0 and x < 2</code></td>
 </tr>
 <tr> 
  <td>%Q(%x) &nbsp;&nbsp;&nbsp; iff &nbsp;&nbsp;&nbsp; %x > 3</td>
  <td><code>Q = lambda x: x > 3</code></td>
 </tr>
</table>

<table class="fig_table">
 <tr>
  <td><b>formula</b></td>
  <td><b>what it represents</b></td>
  <td><b>example of one possible<br/>Python representation</b></td>
 </tr>
 <tr> 
  <td>%P(1)</td>
  <td>true</td>
  <td><code>P(1)</code></td>
 </tr>
 <tr> 
  <td>%P(1) or %P(2)</td>
  <td>true</td>
  <td><code>P(1) or P(2)</code>
  </td>
 </tr>
 <tr> 
  <td>%Q(1) and %P(1)</td>
  <td>false</td>
  <td><code>Q(1) and Q(1)</code>
  </td>
 </tr>
</table>

In <a href="#assignment1">Assignment #1</a>, you will define the following predicates. We will also use them throughout the course.

<b>Definition:</b> For any %x,%y \in \Z, %x | %y &nbsp;&nbsp; iff &nbsp;&nbsp;%y/%x \in \Z.

<b>Definition:</b> For any %y \in \Z, %y is prime &nbsp;&nbsp; iff &nbsp;&nbsp; %y > 1 and for any integer %x > 0, %x | %y implies %x = 1 or %x = %y.

<table class="fig_table">
 <tr>
  <td><b>formula</b></td>
  <td><b>what it represents</b></td>
 </tr>
 <tr> 
  <td>%x | %y</td>
  <td>%y / %x \in \Z<br/><br/>%x divides %y<br/>%y is divisible by %x<br/>%y is an integer multiple of %x<br/>%y \mod %x = 0</td>
 </tr>
 <tr> 
  <td>%y is prime</td>
  <td> %y > 1 and<br/>%x | %y implies %x = 1 or %x = %y<br/><br/>%y > 1 and<br/>%y is divisibly only by 1 and itself</td>
  </td>
 </tr>
</table>


<a name="2.4"></a>
<h3>Terms: finite sets of integers, term operators that take set inputs, and set comprehensions</h3>

The following are examples of terms the meaning of which is a finite set of integers (with the exception of the set size terms, the meaning of
which is a positive integer).

<table class="fig_table">
 <tr>
  <td><b>term</b></td>
  <td><b>what it represents</b></td>
  <td><b>example of one possible<br/>Python representation</b></td>
 </tr>
 <tr> 
  <td>\emptyset</td>
  <td>a set with no elements in it</td>
  <td><code>set([])</code></td>
 </tr>
 <tr> 
  <td>{1,2,3}</td>
  <td>{1,2,3}</td>
  <td><code>set([1,2,3])</code></td>
 </tr>
 <tr> 
  <td>{2,..,5}</td>
  <td>{2,3,4,5}</td>
  <td><code>set(range(2,6))</code></td>
 </tr>
 <tr>
  <td>{ %x | %x \in {1,2,3,4,5,6}, x > 3 }</td>
  <td>{4,5,6}</td>
  <td><code>set([x for x in set([1,2,3,4,5,6]) if x > 3])</code>
  </td>
 </tr>
 <tr> 
  <td>|{1,2,3,4}|</td>
  <td>4</td>
  <td><code>len(set([1,2,3,4]))</code>
  </td>
 </tr>
</table>

The following are term operators on terms the meaning of which is a finite set of integers.

<table class="fig_table">
 <tr>
  <td><b>term</b></td>
  <td><b>what it represents</b></td>
  <td><b>example of one possible<br/>Python representation</b></td>
 </tr>
 <tr> 
  <td>%S_1 \cup %S_2</td>
  <td>{%z | %z \in \Z, %z \in %S_1 or %z \in %S_2}</td>
  <td><code>{1,2,3}.union({4,5})</code></td>
 </tr>
 <tr> 
  <td>%S_1 \cap %S_2</td>
  <td>{%z | %z \in \Z, %z \in %S_1 and %z \in %S_2}</td>
  <td><code>{1,2,3}.intersection({2,3,5})</code></td>
 </tr>
 <tr> 
  <td>|%S|</td>
  <td>the number of elements in %S</td>
  <td><code>len({1,2,3})</code></td>
 </tr>
</table>

While these are not <i>finite</i> sets of integers, we introduce the following two set terms in order to reference them throughout the notes.

<b>Definition:</b> Let \Z be the set of all integers.

<b>Definition:</b> Let \N be the set of all positive integers, including 0.

<table class="fig_table">
 <tr>
  <td><b>term</b></td>
  <td><b>what it represents</b></td>
 </tr>
 <tr> 
  <td>\N</td>
  <td>{0, 1, 2, ...}</td>
 </tr>
 <tr> 
  <td>\Z</td>
  <td>{..., -2, -1, 0, 1, 2, ...}</td>
 </tr>
</table>

<a name="2.5"></a>
<h3>Formulas: quantifiers over finite sets of integers</h3>

Suppose we define the following two Python functions that take predicates (or, more specifically, functions that represent predicates) as input.

<code>
<br/>&nbsp;&nbsp; def forall(X,P): return len(X) == len(set([x for x in X if P(x)]))
<br/>&nbsp;&nbsp; 
<br/>&nbsp;&nbsp; def exists(X,P): 
<br/>&nbsp;&nbsp;&nbsp;&nbsp; for x in X: 
<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if P(x):
<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return True
<br/>&nbsp;&nbsp;&nbsp;&nbsp; return False
<br/>&nbsp;&nbsp; 
<br/>&nbsp;&nbsp; def subset(X,Y): return forall(X, lambda x: x in Y)
</code>

Then we can introduce the following definitions and corresponding Python examples.

<table class="fig_table">
 <tr>
  <td><b>formula</b></td>
  <td><b>what it represents</b></td>
  <td><b>example of one possible<br/>Python representation</b></td>
 </tr>
 <tr> 
  <td>1 \in {1,2,3}</td>
  <td>true</td>
  <td><code>1 in set([1,2,3])</code></td>
 </tr>
 <tr> 
  <td>4 \in {1,2,3}</td>
  <td>false</td>
  <td><code>4 in set([1,2,3])</code></td>
 </tr>
 <tr> 
  <td>\forall %x \in {1,2,3}, %x > 0 and %x < 4</td>
  <td>true</td>
  <td><code>forall(set([1,2,3]), lambda x: x > 0 and x < 4)</code></td>
 </tr>
 <tr> 
  <td>\exists %x \in {1,2,3}, %x < 1 and %x > 3</td>
  <td>false</td>
  <td><code>exists(set([1,2,3]), lambda x: x < 1 or x > 3)</code></td>
 </tr>
 <tr> 
  <td>\forall %x \in \emptyset, %f</td>
  <td>true</td>
  <td></td>
 </tr>
 <tr> 
  <td>\exists %x \in \emptyset, %f</td>
  <td>false</td>
  <td></td>
 </tr>
</table>

Notice that when we quantify over an empty set with a universal quantifier \forall, the formula is always true. When we quantify over an empty set
with an existential quantifier, the formula is always false (since no element satisfying any formula could exist). We can see that the Python
functions for these quantifiers are consistent with this interpretation.

<b>Exercise:</b> Implement Python functions that correspond to formulas which can be used to define each of the following statements about
a set %X and a predicate %P.
<ul>
  <li> All the elements of a set %X satisfy the predicate %P.
<solution>
<code>
def all(X, P): return forall(X, P)
<br/>def all(X, P): return len({x for x in X if P(x)}) == len(X)
</code>
</solution>
  </li>
  <li> None of the elements of a set %X satisfy the predicate %P.
<solution>
<code>
def none(X, P): return forall(X, lambda x: not P(x))
<br/>def none(X, P): return not exists(X, P(x))
<br/>def none(X, P): return len({x for x in X if P(x)}) == 0
</code>
</solution>
  </li>
  <li> At most one of the elements of a set %X satisfy the predicate %P.
<solution>
<code>
def atMostOne(X, P): return len({x for x in X if P(x)}) <= 1
<br/>def atMostOne(X, P): return one(X, P) or none(X, P)
</code>
</solution>
  </li>
  <li> At least one of the elements of a set %X satisfy the predicate %P.
<solution>
<code>
def atLeastOne(X, P): return exists(X, P)
<br/>def atLeastOne(X, P): return len({x for x in X if P(x)}) >= 1
</code>
</solution>
  </li>
  <li> Exactly one of the elements of a set %X satisfy the predicate %P.
<solution>
<code>
def one(X, P): return len({x for x in X if P(x)}) == 1
<br/>def one(X, P): return atLeastOne(X, P) and atMostOne(X, P)
</code>
</solution>
  </li>
</ul>










<a name="2.6"></a>
<h3>Formulas: predicates dealing with finite sets of integers</h3>

The following are examples of formulas that contain relational operators dealing with finite sets of integers.

<table class="fig_table">
 <tr>
  <td><b>formula</b></td>
  <td><b>what it represents</b></td>
  <td><b>example of one possible<br/>Python representation</b></td>
 </tr>
 <tr> 
  <td>3 \in {1,2,3}</td>
  <td>true</td>
  <td><code>3 in set([1,2,3])</code></td>
 </tr>
 <tr> 
  <td>{1,2} \subset {1,2,3}</td>
  <td>true</td>
  <td><code>subset(set([1,2]), set([1,2,3]))</code></td>
 </tr>
 <tr> 
  <td>{4,5} \subset {1,2,3}</td>
  <td>false</td>
  <td><code>subset(set([4,5]), set([1,2,3]))</code></td>
 </tr>
</table>

Below are the general forms of formulas containing relational operators dealing with finite sets of integers.

<table class="fig_table">
 <tr>
  <td><b>formula</b></td>
  <td><b>what it represents</b></td>
 </tr>
 <tr> 
  <td>%z \in %S</td>
  <td>true if %z is an element of %S; false otherwise</td>
 </tr>
 <tr> 
  <td>%S_1 \subset %S_2</td>
  <td>\forall %z \in %S_1, %z \in %S_2</td>
 </tr>
 <tr> 
  <td>%S_1 = %S_2</td>
  <td>%S_1 \subset %S_2 and %S_2 \subset %S_1</td>
 </tr>
</table>

<a name="2.7"></a>
<h3>Terms: set products and binary relations</h3>

<b>Definition:</b> The product of two sets %X and %Y is denoted %X \times %Y and is defined to be the set of <i>ordered</i> pairs
(%x,%y) for every possible combination of %x \in %X and %y \in %Y.

<table class="fig_table">
 <tr>
  <td><b>term</b></td>
  <td><b>what it represents</b></td>
  <td><b>example of one possible<br/>Python representation</b></td>
 </tr>
 <tr> 
  <td>{1,2} \times {5,6,7}</td>
  <td>{(1,5),(1,6),(1,7),(2,5),(2,6),(2,7)}</td>
  <td><code>set([(x,y) for x in set([1,2]) for y in set([4,5,6,7])])</code></td>
 </tr>
</table>

<a name="lecture2"></a>
<b>Definition:</b> A set %R is a <i>relation</i> between the sets %X and %Y if %R \subset %X \times %Y.

<a name="2.8"></a>
<h3>Formulas: predicates dealing with relations</h3>

There are several common properties that relations may possess.

<table class="fig_table">
 <tr>
  <td><b>predicate</b></td>
  <td><b>definition</b></td>
  <td><b>graphical example</b></td>
 </tr>
 <tr>
  <td>%X \times %Y is the set product of %X and %Y</td>
  <td>%X \times %Y = { (%x,%y) | %x \in %X, %y \in %Y }</td>
  <td></td>
 </tr>
 <tr>
  <td>%R is a relation between %X and %Y</td>
  <td>%R \subset %X \times %Y</td>
  <td><img src="images/relation.png"></td>
 </tr>
 <tr>
  <td>%R is a function from %X to %Y<br/>%R is a (many-to-one) map from %X to %Y</td>
  <td>
    %R is a relation between %X and %Y and<br/>
    \forall %x \in %X,<br/>
    &nbsp;&nbsp;&nbsp; there is at most one<br/>
    &nbsp;&nbsp;&nbsp; %y \in %Y s.t. (%x,%y) \in %R
  </td>
  <td><img src="images/function.png"></td>
 </tr>
 <tr>
  <td>%R^{-1} is the inverse of %R</td>
  <td>%R^{-1} = { (%b,%a) | (%a,%b) \in %R }</td>
  <td></td>
 </tr>
 <tr>
  <td>%R is an injection from %X to %Y</td>
  <td>
  %R is a relation between %X and %Y and<br/>
    \forall %y \in %Y,<br/>
    &nbsp;&nbsp;&nbsp; there is at most one<br/>
    &nbsp;&nbsp;&nbsp; %x \in %X s.t. (%x,%y) \in %R
  </td>
  <td><img src="images/injection.png"></td>
 </tr>
 <tr>
  <td>%R is a surjection from %X to %Y</td>
  <td>
  %R is a relation between %X and %Y and<br/>
    \forall %y \in %Y,<br/>
    &nbsp;&nbsp;&nbsp; there is at least one<br/>
    &nbsp;&nbsp;&nbsp; %x \in %X s.t. (%x,%y) \in %R
  </td>
  <td><img src="images/surjection.png"></td>
 </tr>
 <tr>
  <td>%R is a bijection between %X and %Y</td>
  <td>%R is an injection from %X and %Y and<br/>%R is a surjection from %X and %Y</td>
  <td><img src="images/bijection.png"></td>
 </tr>
 <tr>
  <td>%R is a permutation on %X</td>
  <td>%R \subset %X \times %X and<br/>
      %R is a bijection between %X and %X</td>
  <td></td>
 </tr>
 <tr>
  <td>%R is a reflexive relation on %X</td>
  <td>%R \subset %X \times %X and<br/>\forall %x \in %X, (%x,%x) \in %R </td>
  <td></td>
 </tr>
 <tr>
  <td>%R is a symmetric relation on %X</td>
  <td>%R \subset %X \times %X and<br/>\forall %x \in %X, \forall %y \in %X, (%x,%y) \in %R implies (%y,%x) \in %R</td>
  <td></td>
 </tr>
 <tr>
  <td>%R is a transitive relation on %X</td>
  <td>%R \subset %X \times %X and<br/>
      \forall %x \in %X, \forall %y \in %X, \forall %z \in %X,<br/>
      &nbsp;&nbsp;&nbsp;(%x,%y) \in %R and (%y,%z) \in %R implies (%x,%z) \in %R</td>
  <td></td>
 </tr>
 <tr>
  <td>%R is an equivalence relation on %X<br/>%R is a congruence relation on %X</td>
  <td>%R \subset %X \times %X and<br/>
      %R is a reflexive relation on %X and<br/>
      %R is a symmetric relation on %X and<br/>
      %R is a transitive relation on %X</td>
  <td></td>
 </tr>
 <tr>
  <td>%R is an antisymmetric relation on %X</td>
  <td>%R \subset %X \times %X and<br/>\forall %x \in %X, \forall %y \in %X, (%x,%y) \in %R and (%y,%x) \in %R implies %x = %y</td>
  <td></td>
 </tr>
 <tr>
  <td>%R is a partial order on %X</td>
  <td>%R \subset %X \times %X and<br/>
      %R is a reflexive relation on %X and<br/>
      %R is an antisymmetric relation on %X and<br/>
      %R is a transitive relation on %X</td>
  <td></td>
 </tr>
</table>

Notice that we may have %R such that %R is a function, but %R^{-1} is not a function.

<b>Exercise:</b> Write a Python function that takes a finite set of integers and builds the relation on that set corresponding
to the operator \leq.

<solution>
<code>
def buildLTE(X): return {(x,y) for x in X for y in X if x <= y}
</code>
</solution>

<b>Exercise:</b> Write a Python function that takes a relation %R and a set %X and determines whether %R is a symmetric relation on %X.

<solution>
<code>
def symmetric(R,X): return subset(R, product(X,X)) and forall(R, lambda z: (z[1],z[0]) in R)
</code>
</solution>

We introduce several terms that deal with the relationship between the relation and the members and subsets of the two sets that the relation involves.

<table class="fig_table">
 <tr>
  <td><b>predicate</b></td>
  <td><b>required conditions</b></td>
 </tr>
 <tr>
  <td>%X is the domain of %R between %X and %Y</td>
  <td>%R is a function from %X to %Y</td>
 </tr>
 <tr>
  <td>%Y is the codomain of %R between %X and %Y</td>
  <td>%R is a function from %X to %Y</td>
 </tr>
 <tr>
  <td>%B is the image of %R between %X and %Y</td>
  <td>%R is a function from %X to %Y and<br/>
      %B = {%y | %x \in %X, (%x',%y) \in %R, %x = %x'}</td>
 </tr>
 <tr>
  <td>%B is the image of %x under %R between %X and %Y</td>
  <td>%R is a function from %X to %Y and<br/>
      %B = {%y | (%x,%y) \in %R}</td>
 </tr>
 <tr>
  <td>%A is the pre-image of %y under %R between %X and %Y</td>
  <td>%R is a function from %X to %Y and<br/>
      %A = {%x | (%x,%y) \in %R}</td>
 </tr>
</table>

<b>Exercise:</b> Implement Python functions that correspond to each of the structures above.

<solution>
<code>
def domain(Xcheck,R,X,Y): return function(R,X,Y) and Xcheck == X
<br/>
<br/>def codomain(Ycheck,R,X,Y): return function(R,X,Y) and Ycheck == X
<br/>
<br/>def image(B,R,X,Y): return function(R,X,Y) and B == {y for (x,y) in R if x in X}
<br/>
<br/>def imageElem(B,x,R,X,Y): return function(R,X,Y) and B == {y for (x2,y) in R if x2 == x}
<br/>
<br/>def preimage(A,y,R,X,Y): return function(R,X,Y) and A == {x for (x,y2) in R if y2 == y}
</code>
</solution>


<b>Fact:</b> If %R is a function from %X to %Y and %R is an injection from %X to %Y and %R is finite, and if %B is the image of %R, then 
|%B| = |%X| and (because %B \subset %Y and so |%B| \leq |%Y|), we have that |%Y| \geq |%X|.

<b>Exercise:</b> Determine whether the relation %R = {(%x,%y) | %x \in \Z, %y \in \Z, %x | %y} is an equivalence relation (check whether each
of the three properties of an equivalence relation are satisfied).

<b>Exercise:</b> Determine whether the relation %R = {(%x,%y) | %x \in \Z, %y \in \Z, %x | %y} is a partial order on \Z (check whether each
of the three properties of a partial order are satisfied).






<!--assignment1-->
<br/><hr/>
<a name="2.9"></a>
<a name="assignment1"></a>
<b>Assignment #1: Prerequisite Review: Logic, Integers, Sets, and Relations</b>
<!--span class="btn_assignment">(<a href="materials.php?hw=1">show only this assignment</a>)</span-->

  <p>In this assignment you will define Python functions that represent various constructs. For this assignment, you will submit
  a single Python source file <code>a1.py</code>.

  <b style="color:firebrick;">Your file may not import any modules or employ any external library functions associated with
  integers and sets (unless the problem statement explicitly permits this). Solutions to each of the programming problem parts below should
  fit on one or two lines. You will be graded on the correctness, concision, and mathematical legibility of your code.
  The different problems and problem parts rely on each other; carefully consider whether you can use functions you define
  in one part within subsequent parts.</b>

<ol>

  <li>
    <ol style="list-style-type:lower-alpha;">
      <li> Define a Python function <code>divides()</code> that takes two positive integer arguments and returns <code>True</code>
           only if the first argument divides the second argument.
      </li>

      <li> Define a Python function <code>prime()</code> that takes a single argument and returns <code>True</code> only if the argument is a prime
           positive integer. You may use the <code>range()</code>, <code>len()</code>, and <code>divides()</code> functions.
      </li>
    </ol>
  </li>

  <li> In this problem, you will implement a small algorithm that can generate arbitrarily many prime numbers.
       This algorithm is very inefficient; its purpose is to serve as a programmatic argument that there
       are infinitely many distinct prime numbers.
    <ol style="list-style-type:lower-alpha;">
      <li>Implement a Python function <code>factors</code> that takes a single positive integer argument and returns the
          set of factors of that number.
      </li>

      <li>Implement a Python function <code>primeFactors</code> that takes a single positive integer argument and returns the
          set of prime factors of that number.</li>
      </li>

      <li>Implement a Python function <code>anotherPrime</code> that takes a set of prime numbers and returns a new prime that
          is distinct from all the others in the list. To accomplish this, compute the product <code>p</code> of all the prime
          numbers in the set, then return a prime factor <b style="color:firebrick;">that belongs to the set of factors</b> 
          of <code>p+1</code>.
      </li>

      <li>Implement a Python function <code>generatePrimes</code> that takes a single input <code>n</code> and returns a set
          of <code>n</code> distinct prime numbers. <b>Hint: use recursion and another function you have already implemented.</b>
      </li>
    </ol>
  </li>

  <li>
    <ol style="list-style-type:lower-alpha;">
      <li> Define a Python function <code>implies()</code> that takes two arguments and correctly implements the logical operator <i>implies</i>.
      </li>
    </ol>
  </li>

  <li> <b style="color:firebrick;">To receive credit for each part below, your solutions must employ <code>forall</code>, <code>exists</code>,
       and/or list comprehensions. Solutions that are more than one or two lines in length will receive no credit.</b>

    <ol style="list-style-type:lower-alpha;">
      <li> Define a Python function <code>product(X,Y)</code> that takes two sets as arguments and returns the set product of the sets.

      </li>

      <li> Define a Python function <code>relation(R,X,Y)</code> that takes three arguments and returns <code>True</code> only if the
           first argument <code>R</code> is a relation between the second and third arguments <code>X</code> and <code>Y</code>.

      </li>

      <li> Define a Python function <code>function(R,X,Y)</code> that takes three arguments and returns <code>True</code> only if the
           first argument <code>R</code> is a function from <code>X</code> to <code>Y</code>.

      </li>

      <li> Define a Python function <code>injection(R,X,Y)</code> that takes three arguments and returns <code>True</code> only if the
           first argument <code>R</code> is an injection from <code>X</code> to <code>Y</code>.

      </li>

      <li> Define a Python function <code>surjection(R,X,Y)</code> that takes three arguments and returns <code>True</code> only if the
           first argument <code>R</code> is a surjection from <code>X</code> to <code>Y</code>.

      </li>

      <li> Define a Python function <code>bijection(R,X,Y)</code> that takes three arguments and returns <code>True</code> only if the
           first argument <code>R</code> is a bijection from <code>X</code> to <code>Y</code>.

      </li>

      <li> Define a Python function <code>transitive(R,X)</code> that takes two arguments and returns <code>True</code> only if the
           first argument <code>R</code> is a transitive relation on <code>X</code>.

      </li>

      <li> Define a Python function <code>lte(R)</code> that takes one argument and returns <code>True</code> only if the
           relation <code>R</code> is a subset of the relation represented by the relational operator <code>&lt;=</code>.

      </li>
    </ol>
  </li>

</ol>
<hr/><br/>
<!--/assignment1-->

<a name="2.10"></a>
<h3>Terms: set quotients and quotient maps</h3>

Given an equivalence relation on a set, we can partition that set into a collection of distinct subsets, called <i>equivalence classes</i>,
such that all the elements of each subset are equivalent to one another.

<b>Definition:</b> For any set %X and equivalence relation %R on %X, let the quotient set of %X with respect to %R, denoted %X/%R, be defined as:
\begin{eqnarray}
 %X/%R & = & {{%y | (%x,%y) \in %R} | %x \in %X}
\end{eqnarray}

<b>Exercise:</b> Implement a Python function that takes two inputs (a set %X and an equivalence relation %R on that set), and outputs the
quotient set %X/%R.

<solution>
<code>
def quotient(X,R): return {frozenset({z for (y,z) in R if y == x}) for x in X}
</code>
</solution>

Below, we evaluate the above function on an example input.

<solution>
<code>
&gt;&gt; quotient({1,2,3,4}, {(1,1),(2,2),(3,3),(2,3),(3,2),(4,4)})
<br/>{frozenset({4}), frozenset({2, 3}), frozenset({1})}
</code>
</solution>

<b>Definition:</b> For a set %X and a relation %R over %X, the relation that relates each %x \in %X to its equivalence class in %X under %R is called
the <i>quotient map</i>. The function is typically denoted using [ ... ]. That is, [%x] is the equivalence class of %x under %R.

<b>Exercise:</b> Why is the relation {(%x,[%x]) | %x \in %X} necessarily a <i>map</i>? Suppose it is not a map. What would this imply?

<b>Exercise:</b> Implement a Python function that takes two inputs (a set %X and an equivalence relation %R on that set), and outputs the
quotient map taking each element %x \in %X to its corresponding equivalence class [%x] \in %X/%R.

<solution>
<code>
def quotientMap(X,R): return {(x, frozenset({z for (y,z) in R if y == x})) for x in X}
</code>
</solution>

<b>Exercise:</b> Determine whether {(%x,%y) | %x \in \Z, %y \in \Z, %x + %y \mod 2 = 0} is an equivalence relation.

<!-- The pre-images under %R of %y \in %Y are equivalence classes iff %R is a quotient map. -->

<a name="lecture3"></a>
<a name="2.11"></a>
<h3>Term operators and closure properties</h3>

We have names for several common properties that operators may possess for a given set. In the table below, We define them
precisely using logical notation.

<table class="fig_table">
 <tr>
  <td><b>property</b></td>
  <td><b>definition</b></td>
 </tr>
 <tr>
  <td>%S is closed under \oplus</td>
  <td>\forall %x,%y \in %S, <br/>&nbsp;&nbsp;&nbsp; %x \oplus %y \in %S</td>
 </tr>
 <tr>
  <td>\oplus is commutative on %S</td>
  <td>\forall %x,%y \in %S, <br/>&nbsp;&nbsp;&nbsp; %x \oplus %y = %y \oplus %x</td>
 </tr>
 <tr>
  <td>\oplus is associative on %S</td>
  <td>\forall %x,%y,%z \in %S, <br/>&nbsp;&nbsp;&nbsp; (%x \oplus %y) \oplus %z = %x \oplus (%y \oplus %z)</td>
 </tr>
 <tr>
  <td>\oplus has a left identity <b>1</b> in %S</td>
  <td>\forall %x \in %S, <br/>&nbsp;&nbsp;&nbsp; <b>1</b> \oplus %x = %x</td>
 </tr>
 <tr>
  <td>\oplus has a right identity <b>1</b> in %S</td>
  <td>\forall %x \in %S, <br/>&nbsp;&nbsp;&nbsp; %x \oplus <b>1</b> = %x</td>
 </tr>
 <tr>
  <td>\oplus has an identity <b>1</b> in %S</td>
  <td>\forall %x \in %S, <br/>&nbsp;&nbsp;&nbsp; <b>1</b> \oplus %x = %x \oplus <b>1</b> = %x</td>
 </tr>
 <tr>
  <td>\otimes distributes across \oplus in %S</td>
  <td>\forall %x,%y,%z \in %S, <br/>&nbsp;&nbsp;&nbsp; %x \otimes (%y \oplus %z) = (%x \otimes %y) \oplus (%x \otimes %z)</td>
 </tr>
</table>

<a name="lecture4"></a>
<a name="3"></a>
<hr style="margin-bottom:80px;"/>
<h2>Modular Arithmetic</h2>

Modular arithmetic can be viewed as a variant of integer arithmetic in which we introduce a congruence (or equivalance) relation on the integers
and redefine the integer term operators so that they are defined on these congruence (or equivalance) classes.

<a name="3.1"></a>
<h3>Terms: congruence classes in \Z/%m\Z and term operators on congruence classes</h3>

<div class="mathenv fact proposition_to_know">
<b>Definition:</b> For any %m \in \Z, define:
\begin{eqnarray}
 %m\Z & = & {%x \cdot %m | %x \in \Z}
\end{eqnarray}
</div>

<div class="mathenv fact proposition_to_know">
<b>Definition:</b> For any %m \in \Z, define:
\begin{eqnarray}
 %k + %m\Z & = & {%k + (%x \cdot %m)  | %x \in \Z}
\end{eqnarray}
</div>

<b>Exercise:</b> Show that the relation %R = {(%x,%y) | %x \in \Z, %y \in \Z, %x \mod 17 = %y \mod 17} is an equivalence relation.

<div class="mathenv fact proposition_to_know">
<b>Definition:</b> For a given %m \in \Z, define:
\begin{eqnarray}
 \Z/%m\Z & = & \Z/{(%x,%y) | %x \in \Z, %y \in \Z, %x \mod %m = %y \mod %m}
\end{eqnarray}
</div>

Informally and intuitively, we could think of the structure of the above set as a logical consequence of letting all multiples of %m be equivalent to 0.
That is, if 0 = %m = 2%m = ..., then 1 = %m + 1 = 2%m + 1 = ..., and so on.

<table class="fig_table">
 <tr>
  <td><b>term</b></td>
  <td><b>what it represents</b></td>
 </tr>
 <tr>
  <td>%z<br/>%z \mod %m<br/>%z + %m\Z</td>
  <td>{%z + (%a \cdot %m) | %a \in \Z}</td>
 </tr>
 <tr>
  <td>%c_1 + %c_2</td>
  <td>{(%x + %y) | %x \in %c_1, %y \in %c_2}</td>
 </tr>
 <tr>
  <td>%c_1 - %c_2</td>
  <td>{(%x - %y) | %x \in %c_1, %y \in %c_2}</td>
 </tr>
 <tr>
  <td>%c_1 \cdot %c_2</td>
  <td>{(%x \cdot %y) | %x \in %c_1, %y \in %c_2}</td>
 </tr>
 <tr>
  <td>%c^{%z}</td>
  <td>%c \cdot ... \cdot %c</td>
 </tr>
 <tr>
  <td>%c!</td>
  <td>%c \cdot (%c-1) \cdot (%c-2) \cdot ... \cdot 1</td>
 </tr>
</table>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> For a fixed number %m, the relation {(%n, {%x | %x \in \Z, %n \mod %m = %x \mod %m) | %n \in \Z} is a quotient map from \Z to \Z/m\Z.
</div>

<a name="3.2"></a>
<h3>Formulas: relational operators dealing with congruence classes in \Z/%m\Z</h3>

<table class="fig_table">
 <tr>
  <td><b>formula</b></td>
  <td><b>what it represents</b></td>
 </tr>
 <tr> 
  <td>%c_1 \equiv %c_2</td>
  <td>true only if %c_1 = %c_2 where "=" is set equality<br/>applied to the congruence classes %c_1 and %c_2;<br/>false otherwise</td>
 </tr>
</table>

<a name="3.3"></a>
<h3>Algebra of congruence classes</h3>

We use the familiar symbols 0, 1, +, -, and \cdot to represent operations on congruence classes. When these symbols are used to
represent operations on integers, they have certain algebraic properties. Do the operations on congruence classes also share the familiar
algebraic properties of the corresponding operations on integers?

<b>Example:</b> Suppose we write the term 3 + 4 \equiv 2 where 2, 3, and 4 are congruence classes in \Z/5\Z. What is the meaning
of this term? First, note the following equivalence.
\begin{eqnarray}
  { %x + %y | %x \in \Z, %y \in \Z} = {%z | %z \in \Z }
\end{eqnarray}
Now, we expand the definitions of congruence classes and the operation + on congruence classes below.
\begin{eqnarray}
 3 + 4 & \equiv & (3 + 5\Z) + (4 + 5\Z) \\
       & = & {3 + %a \cdot 5 | %a \in \Z} + {4 + %b \cdot 5 | %b \in \Z} \\
       & = & {(%x + %y) &nbsp; | &nbsp; %x \in {3 + %a \cdot 5 | %a \in \Z}, %y \in {4 + %b \cdot 5 | %b \in \Z}} \\
       & = & {(3 + %a \cdot 5) + (4 + %b \cdot 5) &nbsp; | &nbsp; %a \in \Z, %b \in \Z} \\
       & = & {(3 + 4) + (%a \cdot 5) + (%b \cdot 5) &nbsp; | &nbsp; %a \in \Z, %b \in \Z} \\
       & = & {2 + 5 + (%a \cdot 5) + (%b \cdot 5) &nbsp; | &nbsp; %a \in \Z, %b \in \Z} \\
       & = & {2 + (1 + %a + %b) \cdot 5 &nbsp; | &nbsp; %a \in \Z, %b \in \Z}  \\
       & = & {2 + %c \cdot 5 | %c \in \Z}  \\
       & \equiv & 2 + 5\Z \\
       & \equiv & 2
\end{eqnarray}

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> The set \Z/%m\Z is closed under the operation represented by +.
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> It is the case that \Z/%m\Z = {0,...,%m-1} where 0,...,%m-1 are congruence classes, and thus, |\Z/%m\Z| = %m.
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> The addition operation on congruence classes represented by + is commutative.
</div>

Suppose that %a and %b are congruence classes in \Z/%m\Z. We know that %a + %b and %b + %a are also congruence classes (they are sets). We want
to show that:
\begin{eqnarray}
  %a + %b & \equiv & %b + %a \\
  (%a + %m\Z) + (%b + %m\Z) & \equiv & (%b + %m\Z) + (%a + %m\Z) \\
  {(%x+%y) \mod %m | %x \in (%a + %m\Z), %y \in (%b + %m\Z)} & = & {(%y+%x) \mod %m | %y \in (%b + %m\Z), %x \in (%a + %m\Z)}
\end{eqnarray}
Notice that the last line above is <i>set equality</i>. Thus, it is sufficient to show that:
\begin{eqnarray}
  {(%x+%y) \mod %m | %x \in (%a + %m\Z), %y \in (%b + %m\Z)} & \subset & {(%y+%x) \mod %m | %y \in (%b + %m\Z), %x \in (%a + %m\Z)} \\
  {(%y+%x) \mod %m | %y \in (%b + %m\Z), %x \in (%a + %m\Z)} & \subset & {(%x+%y) \mod %m | %x \in (%a + %m\Z), %y \in (%b + %m\Z)}
\end{eqnarray}
To show the first relationship, we must show that for every integer in {(%x+%y) \mod %m | %x \in (%a + %m\Z), %y \in (%b + %m\Z)}, that
integer is also in {(%y+%x) \mod %m | %y \in (%b + %m\Z), %x \in (%a + %m\Z)}. Because we know that %x + %y = %y + %x when %x and %y are integers,
it must also be that for any %x,%y \in \Z:
\begin{eqnarray}
  %x + %y & = & %y + %x \\
  (%x + %y) \mod %m & = & (%y + %x) \mod %m
\end{eqnarray}
Thus, for every (%x + %y) \mod %m in the first set, there is a corresponding (%y + %x) \mod %m in the second set, so the subset relation holds.
The argument also works in the other direction. Thus, the two sets are equivalent, so the congruence holds, and + defined on congruence classes
is commutative.

<table class="fig_table">
 <tr>
  <td><b>property</b></td>
  <td><b>definition</b></td>
 </tr>
 <tr>
  <td>\Z/%m\Z is closed under +</td>
  <td>\forall %x,%y \in \Z/%m\Z, <br/>&nbsp;&nbsp;&nbsp; %x + %y \in \Z/%m\Z</td>
 </tr>
 <tr>
  <td>+ is commutative on \Z/%m\Z</td>
  <td>\forall %x,%y \in \Z/%m\Z, <br/>&nbsp;&nbsp;&nbsp; %x + %y \equiv %y + %x</td>
 </tr>
 <tr>
  <td>+ is associative on \Z/%m\Z</td>
  <td>\forall %x,%y,%z \in \Z/%m\Z, <br/>&nbsp;&nbsp;&nbsp; (%x + %y) + %z \equiv %x + (%y + %z)</td>
 </tr>
 <tr>
  <td>+ has a (left and right) identity <b>0</b> in \Z/%m\Z</td>
  <td>\forall %x \in \Z/%m\Z, <br/>&nbsp;&nbsp;&nbsp; <b>0</b> + %x \equiv %x and %x + <b>0</b> \equiv %x</td>
 </tr>
 <tr>
  <td>\Z/%m\Z has inverses with respect to +</td>
  <td>\forall %x \in \Z/%m\Z, <br/>&nbsp;&nbsp;&nbsp; (%m - %x) + %x \equiv 0</td>
 </tr>
 <tr>
  <td>\Z/%m\Z is closed under \cdot</td>
  <td>\forall %x,%y \in \Z/%m\Z, <br/>&nbsp;&nbsp;&nbsp; %x \cdot %y \in \Z/%m\Z</td>
 </tr>
 <tr>
  <td>\cdot is commutative on \Z/%m\Z</td>
  <td>\forall %x,%y \in \Z/%m\Z, <br/>&nbsp;&nbsp;&nbsp; %x \cdot %y \equiv %y \cdot %x</td>
 </tr>
 <tr>
  <td>+ is associative on \Z/%m\Z</td>
  <td>\forall %x,%y,%z \in \Z/%m\Z, <br/>&nbsp;&nbsp;&nbsp; (%x \cdot %y) \cdot %z \equiv %x \cdot (%y \cdot %z)</td>
 </tr>
 <tr>
  <td>+ has a (left and right) identity <b>1</b> in \Z/%m\Z</td>
  <td>\forall %x \in \Z/%m\Z, <br/>&nbsp;&nbsp;&nbsp; 1 \cdot %x \equiv %x and %x \cdot 1 \equiv %x</td>
 </tr>
 <tr>
  <td>\cdot distributes across + in \Z/%m\Z</td>
  <td>\forall %x,%y,%z \in \Z/%m\Z, <br/>&nbsp;&nbsp;&nbsp; %x \cdot (%y + %z) \equiv (%x \cdot %y) + (%x \cdot %z)</td>
 </tr>
</table>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> For any congruence classes %a, %b, %c \in \Z/%m\Z, %a \equiv %b implies %a + %c \equiv %b + %c.
</div>

To show this is true, consider any (%x + %z \mod %m) \in (%a + %c) and any (%y + %z \mod %m) \in (%b + %c). As in the previous proof, we have that:
\begin{eqnarray}
  %x & = & %y \\
  %x + %z & = & %y + %x \\
  (%x + %z) \mod %m & = & (%y + %z) \mod %m
\end{eqnarray}
Thus, the two congruence classes contain the same elements, so they are equivalent.

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> For any congruence classes %a, %b, %c \in \Z/%m\Z, %a \equiv %b implies %a - %c \equiv %b - %c.
</div>

We can adjust the argument above in the following way:
\begin{eqnarray}
  %x & = & %y \\
  %x - %z & = & %y - %x \\
  (%x - %z) \mod %m & = & (%y - %z) \mod %m
\end{eqnarray}

We saw that we can add and subtract from both sides of an equation involving congruence classes. Can we also divide both sides by the same factor (or
"cancel" that factor) in such an equation? We can do so under certain conditions. In order to show that we can do so, we need a few preliminary
facts.

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> For any %a, %m \in \Z, %a \mod %m = 0 iff that %m | %a.
</div>

If %a \mod %m = 0 then:
\begin{eqnarray}
  %a - \lfloor %a/%m \rfloor \cdot %m & = & 0\\
  %a & = & \lfloor %a/%m \rfloor \cdot %m \\
  %a / %m & = & \lfloor %a/%m \rfloor \\
  %a / %m & \in & \Z \\
  %m & | & %a
\end{eqnarray}

If %m | %a then:
\begin{eqnarray}
  %m & | & %a \\
  %a / %m & \in & \Z \\
  %a / %m & = & \lfloor %a/%m \rfloor \\
  %a & = & \lfloor %a/%m \rfloor \cdot %m \\
  %a - \lfloor %a/%m \rfloor \cdot %m & = & 0 \\
  %a \mod %m & = & 0
\end{eqnarray}

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> For any %a, %b, %c \in \N, if %c|%a then %c|(%a \cdot %b).

Because %c|%a, it must be that %a/%c \in \Z. But then we have that:
\begin{eqnarray}
  (%a \cdot %b) / %c = (%a / %c) \cdot %b
\end{eqnarray}
Since (%a / %c) \in \Z and %b \in \Z, (%a / %c) \cdot %b \in \Z and  (%a \cdot %b) / %c \in \Z. Thus, %c|(%a \cdot %b).
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact (Euclid's lemma):</b> For any %a, %b, %p \in \N, if %p is prime and %p | (%a \cdot %b), then it must be that %p|%a or %p|%b (or both).
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> For any congruence classes %a, %b, %c \in \Z/%p\Z, if %c is not divisible by %p then %a \cdot %c \equiv %b \cdot %c implies %a \equiv %b.
</div>

We observe that:
\begin{eqnarray}
  %a \cdot %c & \equiv & %b \cdot %c \\
  (%a \cdot %c) - (%b \cdot %c) & \equiv & 0 \\
  ((%a \cdot %c) - (%b \cdot %c)) \mod %p & = & 0 \\
  ((%a - %b) \cdot %c) \mod %p & = & 0 \\
  %p & | & ((%a - %b) \cdot %c)
\end{eqnarray}
By Euclid's lemma, the fact that %c is not divisible by %p requires that %a - %b must be divisible by %p. Thus:
\begin{eqnarray}
  %p & | & (%a - %b) \\
  (%a - %b) \mod %p & = & 0 \\
  %a - %b & \equiv & 0 \\
  %a & \equiv & %b
\end{eqnarray}

<a name="fact-aimodp-is-permutation"></a>
<div class="mathenv fact proposition_to_know">
<b>Fact:</b> For any %p \in \N, for any %a \in {1,...,%p-1}, if %p is prime then the following is a permutation from {1,...,%p-1} to
\Z/%p\Z - {0} (the non-zero congruence classes in \Z/%p\Z):
\begin{eqnarray}
 %R & = & { (1, (1 \cdot %a) \mod %p), (2, (2 \cdot %a) \mod %p), ..., (%p-1, ((%p-1) \cdot %a) \mod %p) } \\
    & = & { (%i, (%i \cdot %a) \mod %p) | %i \in {1,...,%p-1} }
\end{eqnarray}
</div>

Recall that %R is a permutation if %R is a bijection. In order to be a bijection, %R must be both an injection and a surjection.

To show that %R is an injection, suppose that it is not. We will derive a contradiction from this assumption, which
will tell us that the assumption must be false.

If it is not injective, then there exist distinct non-zero %i \in {1,...,%p-1} and %j \in {1,...,%p-1} where without loss of generality 
%j < %i such that:
\begin{eqnarray}
 %i & \neq & %j \\
 (%i \cdot %a) \mod %p & = & (%j \cdot %a) \mod %p \\
 ((%i \cdot %a) - (%j \cdot %a)) \mod %p & = & 0 \mod %p \\
 ((%i - %j) \cdot %a) \mod %p & = & 0 \mod %p \\
 %p & | & (%i - %j) \cdot %a
\end{eqnarray}
But because %a < %p, %p does not divide %a, so the above implies that %p | (%i - %j). But this is also impossible because %p > %i - %j > 0. Also, notice that in the
above, we could have simply divided both sides of the second line by %a because %p does not divide %a.

Since assuming that distinct %i and %j can be related to the same element of the relation's codomain
leads to a contradiction, it must be impossible. Thus, %R is an injection.

Furthermore, %R is an injection from {1,...,%p-1} to \Z/%p\Z - {0} and we have that:
\begin{eqnarray}
|{1,...,%p-1}| & = & |\Z/%p\Z - {0}|
\end{eqnarray}
Thus, since %R maps to at least %p-1 distinct elements, and |\Z/%p\Z - {0}| has at most %p-1
elements, %R must map to every element in \Z/%p\Z - {0}, so it is also a surjection by the 
<a href="http://en.wikipedia.org/wiki/Pigeonhole_principle">Pigeonhole principle</a>.

Since %R is both an injection and a surjection from {1,...,%p-1} to \Z/%p\Z - {0}, it must be a bijection, and thus a permutation.

Notice that if we extend %R by adding (0,0), it is now a permutation from {0,...,%p-1} to \Z/%p\Z.

<a name="3.4"></a>
<h3>Example: Random Number Generation</h3>

Suppose we want to find a way to generate a "random" sequence %v of positive integers. Assume we have only one requirement.

<b>Requirement 1:</b> The sequence %v has %m distinct positive integers between 0 and %m-1, where %v_%i is the %ith element in the sequence.</li>

In this case, a relation %R \subset \N \times \Z/%m\Z that is a permutation would be sufficient. One such relation is:
\begin{eqnarray}
  %v_0 & = & 0 \mod %m \\
  %v_%i & = & (%v_{i-1} + 1) \mod %m \\
  %R_0 & = & {(%i, %v_%i) | %i \in {0,...,%m-1}}
\end{eqnarray}
Notice that the second term in (%x, %x \mod %m) is in this case the <i>congruence class</i> modulo %m that corresponds to %x.

The relation %R_0 is indeed a permutation, but it does not satisfy our intuitive notion of a random sequence, so we impose another requirement.

<b>Requirement 2:</b> The sequence %v must not be the trivial sequence (0,...,%m-1).</li>

Suppose we propose the following relation:
\begin{eqnarray}
  %v_0 & = & 0 \\
  %v_%i & = & (%v_{i-1} + 2) \mod %m \\
  %R_1 & = & {(%i, %v_%i) | %i \in {0,...,%m-1}}
\end{eqnarray}
Notice that we can redefine %R_1 above more concisely:
\begin{eqnarray}
  %R_1 & = & {(%i, (0 + 2 \cdot %i) \mod %m) | %i \in {0,...,%m-1}}
\end{eqnarray}
Does %R_1 always satisfy both requirements? Suppose that %m is even. Then we have that there exists %j \in {0,...,%m-1} such that 2 \cdot %j = %m. But
this means that 2 \cdot %j \equiv 0, so 2 \cdot (%j+1) \equiv 2 \cdot %j + 2 \cdot 1 \equiv 2 \cdot 1 \equiv 2 and so on. This means that %R_1 is
not injective, so the first requirement is not met when %m is even.

Suppose we define %R_2 to be a variant of %R_1 parameterized by some %b \in {0,...,%m-1}:
\begin{eqnarray}
  %R_2 & = & {(%i, (0 + %b \cdot %i) \mod %m) | %i \in {0,...,%m-1}}
\end{eqnarray}
What conditions can we impose on %b and %m so that they satisfy both requirements?

<b>Fact:</b> If %m is prime and %b \in {2,...,%m-1}, then %R_2 satisfies both requirements.

We know this is true because in this case, %R is a permutation, so it satisfies <b>Requirement 1</b>. Furthermore, element %v_1 = %b, so
%v is never the trivial sequence. Thus, <b>Requirement 2</b> is satisfied.

<b>Exercise:</b> What are some drawbacks (or unresolved issues) with building random sequences by choosing a prime %m and some %b \in {2,...,%m-1}?

<a name="lecture5"></a>
<a name="3.5"></a>
<h3>Generating and detecting prime numbers</h3>

Many applications require the generation of new primes. We saw a simple example above in which generating new random sequences required
the generation of new primes. Another important class of applications with this requirement are cryptographic schemes and protocols. In this
section, we consider the problem of generating prime numbers.

As you saw in <a href="#assignment1">Assignment 1</a>, a straightforward algorithm that is guaranteed to generate
new prime numbers is not necessarily efficient. In practice, most algorithms that need to generate large primes simply choose a range of
of numbers and filter out non-primes using some efficient algorithm that does not provide an absolute guarantee that the numbers
that remain are all prime. As long as it is not too likely that the generated number is not a prime, this may be sufficient.

<b>Example: </b> Suppose we want to generate a %d-digit prime number (in decimal representation). 
The <a href="http://en.wikipedia.org/wiki/Prime_number_theorem">prime number theorem</a> states that for a given %N, the number of primes in the
range {2,...,%N} is about %N/(\ln(%N)). We can roughly estimate the number of primes with %d-digit decimal representations using
the following formula:
\begin{eqnarray}
  (10^{%d+1}-1 / \ln(10^{%d+1}-1)) - (10^{%d} / \ln(10^{%d}))
\end{eqnarray}
For %d = 8, this value is about 4,780,406, so we can roughly say that the chances that a chosen 8-digit number is prime are about:
\begin{eqnarray}
  4,780,406/((10^9 - 1) - 10^8) \approx 5.5/100
\end{eqnarray}

Suppose we defined the following algorithm for generating a prime with a %d-digit representation.

<ol style="list-style-type:none;">
 <li><b>inputs:</b> %d \in \N</li>
 <li>
 do
   <ol style="list-style-type:none;">
     <li>%n := a number from {10^{%d}, ..., 10^{%d+1}-1}</li>
   </ol>
 while %n is not prime
 </li>
 <li>return %n</li>
</ol>

Assuming we were choosing numbers "well" with respect to their distribution (we are being imprecise here), we could optimistically hope that
for %d = 8, the above algorithm would only need to check for primality about 20 times (since roughly 1 out of every 20 numbers it tries should be
a prime).

It remains to define an algorithm for checking whether an arbitrary input %m \in \N is prime. We could check every number %k between 2 and 
\lfloor \sqrt(%m) \rfloor to see if it is a factor of %m. However, \lfloor \sqrt(%m) \rfloor still grows exponentially in the representation
size of %m. For example, for an %n-bit input, an integer %m in {0,...,2^{%n}-1} which must have a representation size of at least %n bits, we have
the following exponential running time:
\begin{eqnarray}
  \sqrt(%m) & = & \sqrt(2^{%n})\\
            & = & 2^{%n/2}\\
            & = & (2^{1/2})^{%n}\\
            & \approx & 1.42^{%n}
\end{eqnarray}

If we only consider primes and not any of their multiples (i.e., we apply
the <a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">Sieve of Eratosthenes</a> to the set {2,...,\lfloor \sqrt(%m) \rfloor}), we can
decrease the number of times we check the divisibility of %m. However, we would need to do a lot of extra work to filter out the multiples
of primes. Modern algorithms such as
<a href="http://en.wikipedia.org/wiki/Elliptic_curve_primality_testing">ECPP</a> run in polynomial time, in practice it is currently difficult
to implement a version of these algorithms that runs quickly enough for many applications. Thus, we instead modify our algorithm in the
following way:

<!-- 
Consider the application of generating random sequences. If the number %m is chosen from the range
{2,...,65536}, then depending on the distribution, the chance of choosing a prime %m is about 1/11. If for a given application domain, it is
okay that only 1/11 of the random sequences is actually a permutation (and that sequences can be of any length), this may be an acceptable solution.
-->

<ol style="list-style-type:none;">
 <li><b>inputs:</b> %d \in \N</li>
 <li>
 do
   <ol style="list-style-type:none;">
     <li>%n := a number from {10^{%d}, ..., 10^{%d+1}-1}</li>
   </ol>
 while %n is not <i><b>probably</b></i> prime
 </li>
 <li>return %n</li>
</ol>

It remains to define a subroutine for checking whether a number is <i>probably</i> prime (for some appropriate definition of
"probably") that is very efficient.

<a name="lecture6"></a>
<a name="3.6"></a>
<h3>Greatest common divisor and related facts</h3>

<div class="mathenv fact proposition_to_know">
<b>Definition:</b> For any two %x, %y \in \Z, we define the <i>greatest common divisor</i>, denoted \gcd(%x,%y), as the greatest
integer %z \in \Z such that %z|%x and %z|%y. Equivalently, we can define it as the maximum of a set:
\begin{eqnarray}
 \gcd(%x,%y) & = & \max{ %z | %z \in \Z, %z|%x, %z|%y} 
\end{eqnarray}
We can also define it recursively (not that %z|0 for all %z \in \Z because 0/%z \in \Z):
\begin{eqnarray}
 \gcd(%x,0) & = & %x \\
 \gcd(%x,%y) & = & \gcd(%y, %x \mod %y)
\end{eqnarray}
</div>

To see why the recursive case works, consider two cases. If %x < %y, then the two inputs are simply reversed. This ensures that the
first input %x is eventually larger than the second input %y. If %x \geq %y and they share a greatest common divisor %a,
then we have for %n = \lfloor %x/%y \rfloor
that:
\begin{eqnarray}
 %y & = & %y' \cdot %a \\
 %x & = & %x' \cdot %a \\
 %x \mod %y & = & %x - (%n \cdot %y)\\
            & = & (%x' \cdot %a) - (%n \cdot %y)\\
            & = & %x' \cdot %a - ((%n \cdot %y') \cdot %a)\\
            & = & (%x' - %n \cdot %y') \cdot %a
\end{eqnarray}

Notice that (%x' - %n \cdot %y') \cdot %a < %x' \cdot %a, but that the new smaller value is still a multiple of %a, so the greatest common
divisor of this value and %y is still %a.

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> For any %x \in \Z, %y \in \Z, %x|%y iff \gcd(%x,%y) = %x.
</div>

<div class="mathenv fact proposition_to_know">
<b>Definition:</b> For any %x \in \Z, %y \in \Z, %x and %y are <i>relatively prime</i>, <i>relative primes</i>, and <i>coprime</i> iff \gcd(%x,%y) = 1.
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact (Euclid's lemma generalization):</b> For any %a, %b, %c \in \N, if %a | (%b \cdot %c) 
and %a and %b are relatively prime, then it must be that %a|%c.
</div>

<a name="coprime-multiples-permutation"></a>
<div class="mathenv fact proposition_to_know">
<b>Fact:</b> For any %a \in \N and %m \in \N, if gcd(%a,%m) = 1, then {(%i, (%i \cdot %a) mod %m) | %i \in {0,...,%m-1}} is a permutation.
</div>

The above can be proven by noticing that if gcd(%a,%m) = 1, then %a does not divide %m and %m does not divide %a. 
Notice that in the <a href="#fact-aimodp-is-permutation">proof of
this statement in which %p was prime</a>, the fact that it was prime was not used.

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> For any %m \in \Z where %m \geq 2, \gcd(%m,%m+1) = 1.
</div>

We prove the above by contradiction. Suppose there exists a factor %z > 1 of %m and %m+1. In other words, \gcd(%m,%m+1) > 1. Then we have
that:
\begin{eqnarray}
 %z \cdot %a & = & %m \\
 %z \cdot %b & = & %m+1 \\
 (%z \cdot %b) - (%z \cdot %a) & = & %m+1-%m\\
 %z \cdot (%b- %a) & = & 1\\
 %z \cdot (%b- %a) & = & 1/%z
\end{eqnarray}
If %z > 1 then 1/%z \not\in \Z, so (%b - %a) \not\in \Z. Since %b-%a \in \Z, this is a contradiction, so it must be that \gcd(%m,%m+1) = %z = 1.

Notice that the prime number generator in <a href="#assignment1">Assignment 1</a> relies on the above fact: for a product %p of known
prime numbers, it is guaranteed that %p+1 shares no factors with %p, so any prime factors it has must be new.

<a name="3.7"></a>
<h3>Testing whether a number is probably prime</h3>

In this section, we consider the problem of defining a very efficient algorithm to check whether a positive integer %m \in \N is prime. 
In fact, the algorithm we consider will be detectors of <i>some</i>, but not all, <i>composite</i> numbers.

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> For any %n \in \N, %n is <i>composite</i> iff %n > 1 and it is not the case that %n is prime.
</div>

That is, the algorithms we consider recognize prime numbers but with false positives.
They only guarantee that there are no false negatives (i.e., if the algorithm outputs that its input is <i>composite</i>, then 
it is indeed composite; otherwise, the number may or may not be prime and we call it <i>probably prime</i> because we were not able to
detect that it is composite). First, consider how an algorithm for checking primality that never has a "false" output behaves:

<table class="fig_table">
 <tr>
  <td><b>algorithm input</b></td>
  <td><b>algorithm output</b></td>
  <td><b>meaning</b></td>
  <td><b>comment</b></td>
 </tr>
 <tr> 
  <td>actually a composite number<br/>(this is not known at time of input)</td>
  <td>composite</td>
  <td>the input is composite</td>
  <td>true negative</td>
 </tr>
 <tr> 
  <td>actually a prime number<br/>(this is not known at time of input)</td>
  <td>prime</td>
  <td>the input is prime</td>
  <td>true positive</td>
 </tr>
</table>

Compare the above table to the following table describing three possible conditions (and one forbidden condition) for an algorithm that detects
probably primes.

<table class="fig_table">
 <tr>
  <td><b>algorithm input</b></td>
  <td><b>algorithm output</b></td>
  <td><b>meaning</b></td>
  <td><b>comment</b></td>
 </tr>
 <tr> 
  <td>actually a composite number<br/>(this is not known at time of input)</td>
  <td>composite</td>
  <td>the input is definitely composite</td>
  <td>true negative</td>
 </tr>
 <tr> 
  <td>actually a composite number<br/>(this is not known at time of input)</td>
  <td>probably prime</td>
  <td>the input is either composite or prime</td>
  <td>false positive</td>
 </tr>
 <tr> 
  <td>actually a prime number<br/>(this is not known at time of input)</td>
  <td>probably prime</td>
  <td>the input is either composite or prime</td>
  <td>true positive</td>
 </tr>
 <tr> 
  <td>actually a prime number<br/>(this is not known at time of input)</td>
  <td>composite</td>
  <td><b style="color:firebrick">impossible</b></td>
  <td>false negative<br/>(we will not consider such algorithms)</td>
 </tr>
</table>

We now define our first algorithm for testing whether a number is <i>probably</i> prime.

<ol style="list-style-type:none;">
 <li><b>inputs:</b> %m \in \N, %k \in \N</li>
 <li>
 repeat %k times:
   <ol style="list-style-type:none;">
     <li>%a := a number from {2,...,%m-1}</li>
     <li>if gcd(%a,%m) \neq 1 then return <b><i>composite</i></b></li>
   </ol>
 </li>
 <li>return <b><i>probably prime</i></b></li>
</ol>

The above algorithm is somewhat problematic if we want to have a good idea of how to set %k given our desired level of confidence
in the output. For example, how high should %k be so that the probability that we detect a composite is more than 1/2?

If we require that %k \approx \sqrt(%m) to be sufficiently confident in the output, we might as well use the brute force
method of checking every %a \in {2,..., \lfloor \sqrt(%m) \rfloor}.

<!--
If we do no filtering, one drawback of this approach is that if %m is composite, in the worst case we may
find only one factor in the set {2,...,\lfloor \sqrt(%m) \rfloor}. In other words, for some %m, the probability of detecting that %m is composite
by choosing some candidate factor in {2,...,\lfloor \sqrt(%m) \rfloor} uniformly at random is about 1/\sqrt(%m). Note that \sqrt(%m) grows
exponentially with the representation size of %m.
-->

To define a more predictable testing approach for our algorithm, we derive a theorem that is frequently used in applications
of modular arithmetic (in fact, this fact underlies the prime number generators found in many software applications).

<a name="fermat-little-theorem"></a>
<div class="mathenv fact proposition_to_know">
<b>Fact (Fermat's little theorem):</b> For any %p \in \N, for any %a \in {0,...,%p-1}, if %p is prime then it is true that:
\begin{eqnarray}
 %a^{%p-1} & \equiv & 1 (\mod %p)
\end{eqnarray}
</div>

We have already shown that if %p is a prime then %R defined as below is a permutation:
\begin{eqnarray}
 %R & = & { (1, (1 \cdot %a) \mod %p), (2, (2 \cdot %a) \mod %p), ..., (%p-1, ((%p-1) \cdot %a) \mod %p) } \\
    & = & { (%i, (%i \cdot %a) \mod %p) | %i \in {1,...,%p-1} }
\end{eqnarray}

Next, to make our notation more concise, note that:
\begin{eqnarray}
1 \cdot 2 \cdot ... \cdot %p-1 & = & (%p - 1)! \\
(1 \cdot %a) \cdot (2 \cdot %a) \cdot ... \cdot ((%p-1) \cdot %a) & = & %a^{%p-1} (%p - 1)! \\
\end{eqnarray}

Recall that %p is prime, so %p does not divide (%p - 1)!. Thus, we can divide by (%p - 1)! both sides of the following equation:
\begin{eqnarray}
  %a^{%p-1} (%p - 1)! & \equiv & 1 \cdot (%p - 1)!  \\
  %a^{%p-1} & \equiv & 1 \\
\end{eqnarray}
We now have derived the statement of the theorem.

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> A number %p \in \N is prime iff %p > 1 and for all %a \in {1,...,%p-1}, %a^{%p-1} \mod %p = 1. 
</div>

If we negate the statement above, we can define
when a number is composite (i.e., when it is not prime) in a way that suggests a straightforward algorithm.

<div class="mathenv fact proposition_to_know">
<b>Definition:</b> A number %m \in \N is composite iff %m > 1 and there exists %a \in {1,...,%m-1} such that %a^{%m-1} \mod %m \neq 1. In this case,
%a is a <i>Fermat witness</i> to the compositeness of %m.
</div>

<div class="mathenv fact proposition_to_know">
<b>Definition:</b> If for composite %m \in \N and %a \in {1,...,%m-1}, we have that %a^{%m-1} \mod %m = 1, then %a is a <i>Fermat liar</i> and
%m is a <i>pseudoprime</i> with respect to %a.
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> We now extend our algorithm. The following algorithm can be used to test whether a number is probably prime.

<b>Algorithm (Fermat primality test):</b>
<ol style="list-style-type:none;">
 <li><b>inputs:</b> %m \in \N, %k \in \N</li>
 <li>
 repeat %k times:
   <ol style="list-style-type:none;">
     <li>%a := a number from {2,...,%m-1}</li>
     <li>if gcd(%a,%m) \neq 1 then return <b><i>composite</i></b></li>
     <li>else if %a^{%m-1} \mod %m \neq 1 then return <b><i>composite</i></b></li>
   </ol>
 </li>
 <li>return <b><i>probably prime</i></b></li>
</ol>

If %m is a prime, the above algorithm will always return <b><i>probably prime</i></b></li>.
</div>


For any given candidate %a in the above algorithm, if the first test fails and gcd(%a,%m) \neq 1 then %a is a factor of %m. Thus, in the worst case,
the first is gcd(%a,%m) = 1 for all %k instances of %a that we consider. How many of these %k instances must pass
the second test before we are confident that %m is prime? In fact, for most composite numbers %m, %k can be very low. 

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> If for a composite %m \in \Z there is at least one Fermat witness %a \in {2,...,%m-1} such that \gcd(%a,%m) = 1,
then at least half of all %a such that gcd(%a,%m) = 1 are Fermat witnesses.
</div>

Suppose that %a is a Fermat witness and %a_1,...,%a_%n are distinct Fermat liars. Then for every Fermat liar we have that:
\begin{eqnarray}
  (%a \cdot %a_%i)^{%n-1} & \equiv & %a^{%n-1} \cdot %a_%i^{%n-1} \\
                          & \equiv & %a^{%n-1}
\end{eqnarray}

But %a is a Fermat witness, so %a^{%n-1} \mod %m \neq 1. Thus, (%a \cdot %a_%i)^{%n-1} \mod %m \neq 1, so %a \cdot %a_%i
is also Fermat witness. Since there is a witness for every liar, there are at least as many witness as liars, so at least half
the values are witnesses.

How many numbers %m have at least one Fermat witness? Equivalently, how many numbers have no Fermat witnesses?

<a name="carmichael-number"></a>
<div class="mathenv fact proposition_to_know">
<b>Definition:</b> For any %m \in \Z, if %m has no <b style="color:firebrick;">coprime</b> Fermat 
witnesses, then %m is a <i>Carmichael number</i>, also known as a
<i>Fermat pseudoprime</i>.
</div>

The distribuation of Carmichael numbers is high enough that the Fermat primality test is usually not used in favor of slightly
more complex tests for probable primes. However, those tests follow a similar principle. The Fermat primality test is used in some
deployed software applications (such as <a href="http://en.wikipedia.org/wiki/Pretty_Good_Privacy">PGP</a>).

<table class="fig_table">
 <tr>
  <td><b>for the chosen<br/>%a we have...</b></td>
  <td><b>what it means</b></td>
  <td><b>probability of this occurring<br/>if %m is a non-Carmichael composite</b></td>
 </tr>
 <tr> 
  <td>gcd(%a,%m) \neq 1</td>
  <td>%m and %a have a non-trivial factor,<br/>so %m is composite</td>
  <td>(# integers in {2,...,%m-1} that share factors with %m) / (%m-2)</td>
 </tr>
 <tr> 
  <td>%a^{%m-1} \mod %m \neq 1</td>
  <td>%a is a Fermat witness<br/>that %m is composite</td>
  <td>at least 1/2</td>
 </tr>
</table>

<!--assignment2-->
<br/><hr/>
<a name="3.8"></a>
<a name="assignment2"></a>
<b>Assignment #2: Modular Arithmetic, Random Sequences, and Primes</b>
<!--span class="btn_assignment">(<a href="materials.php?hw=2">show only this assignment</a>)</span-->

  <p>For this assignment, you will submit a single Python source file <code>a2.py</code>.

  <b style="color:firebrick;">Your file may not import any modules or employ any external library functions associated with
  integers and sets (unless the problem statement explicitly permits this). 
  You will be graded on the correctness, concision, and mathematical legibility of your code.
  The different problems and problem parts rely on each other; carefully consider whether you can use functions you define
  in one part within subsequent parts.</b>

<ol>
  <li> <b style="color:firebrick;">To receive credit for each part below, your solutions must employ <code>forall</code>, <code>exists</code>,
       and/or list comprehensions. Solutions that are more than 2-5 lines in length will receive no credit.</b>

    <ol style="list-style-type:lower-alpha;">
      <li> Define a Python function <code>commutative(op,S)</code> that takes two arguments and returns <code>True</code> only if the
           first argument <code>op</code>, an operator that takes two arguments, is commutative on the finite set <code>S</code>.
           <pre class="Pythoncode">
def commutative(op,S) :
  return forall(S, lambda x: forall(S, lambda y: op(x,y) == op(y,x)))</pre>
      </li>

      <li> Define a Python function <code>associative(op,S)</code> that takes two arguments and returns <code>True</code> only if the
           first argument <code>op</code>, an operator that takes two arguments, is associative on the finite set <code>S</code>.
           <pre class="Pythoncode">
def associative(op,S) :
  return\
    forall(S, lambda x: forall(S, lambda y: forall(S, lambda z:\
      op(op(x,y),z) == op(x,op(y,z)))))</pre>
      </li>

      <li> Define a Python function <code>identity(op,S)</code> that takes two arguments and returns <code>True</code> only if the
           first argument <code>op</code> (which is itself a function that takes two arguments) has an identity element in <code>S</code>.
           Note that the identity must be both a left and right identity.
           <pre class="Pythoncode">
# It is important to have the right order for the quantifiers.
# There must exist at least one identity element that behaves
# like the identity for /all/ the elements of S:
#
#   exists i in S s.t. for all x in S, op(x,i) == op(i,x) == x
#
# Notice that this is different from a statement such as the one
# below:
#
#   for all x in S, exists i in S s.t. op(x,i) == op(i,x) == x # Incorrect.
#
 
def identity(op,S) :
  return exists(S, lambda i: forall(S, lambda x: op(x,i) == op(i,x) == x))</pre>
      </li>
      <li> Define a Python function <code>inverses(op,S)</code> that takes two arguments and returns <code>True</code> only if for
           every element in <code>S</code>, there is an inverse element with respect to <code>op</code>.
           Note that this is only possible if there is an identity with respect to <code>op</code>. You may want to write a few
           helper functions in order to avoid deeply-nested quantifiers.
           <pre class="Pythoncode">
# The following is the correct formula:
#
#   there exists i in S s.t.
#       i is an identity for S
#     and
#       for all x in S, exists y in S s.t. op(x,y) == i
#
# However, equivalents of the following will also be
# accepted:
#
#   for all x in S, exists y in S s.t.
#     op(x,y) == i and i is an identity for S
#
# For either of the above, "i is an identity for S" should
# be a formula equivalent to:
#
#   for all x in S, op(x,i) == op(i,x) == x
#
# Since we did not explicitly specify whether the identity
# must be left- or right-, "op(x,i) == x" or "x == op(x,i)"
# alone would be sufficient.
 
def inverses(op,S) :
  return\
    exists(S, lambda i:\
        #i is an identity
        forall(S, lambda x: op(i,x) == op(x,i) == x)\
      and\
        forall(S, lambda x: exists(S, lambda y: op(x,y) == i)))</pre>
      </li>
    </ol>
  </li>
  <li>
    <ol style="list-style-type:lower-alpha;">
      <li> Define a Python function <code>randFromPrime()</code> that takes a single input <code>p</code>, a prime number,
           and generates a set of <code>p</code> distinct
           lists, each of length <code>p</code>, and each being a "random" reording of the list <code>[ i for i in range(0,p) ]</code>.
           <ul style="margin-top:7px; margin-bottom:7px;">
             <li>Each list must contain <code>p</code> distinct integers from the set <code>{ i for i in range(0,p) }</code>.</li>
             <li>No individual list should be an ascending or descending sequence of the integers from <code>{ i for i in range(0,p) }</code>.</li>
           </ul>
      </li>
      <li> Define a Python function <code>rand()</code> that takes a single input <code>n</code> (which might not be prime)
            and generates a set of <code>n</code> distinct
           lists, each of length <code>n</code>, and each being a "random" reording of the list <code>[ i for i in range(0,n) ]</code>.
           <ul style="margin-top:7px; margin-bottom:7px;">
             <li>Each list must contain <code>n</code> distinct integers from the set <code>{ i for i in range(0,n) }</code>.</li>
             <li>No individual list should be an ascending or descending sequence of the integers from <code>{ i for i in range(0,n) }</code>.</li>
           </ul>
           You may find the following points useful:
           <ul style="margin-top:7px; margin-bottom:7px;">
             <li>Implement the \gcd function.</li>
             <li>Recall the fact that if \gcd(%a,%m) = 1, then {(%i, (%i \cdot %a) \mod %m) | %i \in {0,...,%m-1}} is a permutation.
                 Implement an algorithm that finds a suitable %a quickly for a given %m (think about how you can use the \gcd
                 function to accomplish this).
             </li>
             <li>Python provides a built-in function <code>floor()</code>. To use it, add <code>from math 
                 import floor</code> to the top of your file.
             </li>
           </ul>
      </li>
      <li> <b style="color:firebrick;">Extra credit:</b> 
           Define a Python function <code>randExtra()</code> that takes a single input <code>n</code> (which might not be prime)
            and generates a set of <code style="color:firebrick;"><b>n*n</b></code> distinct
           lists, each of length <code>n</code>, and each being a "random" reording of the list <code>[ i for i in range(0,n) ]</code>.
           <ul style="margin-top:7px; margin-bottom:7px;">
             <li>Each list must contain <code>n</code> distinct integers from the set <code>{ i for i in range(0,n) }</code>.</li>
             <li>No individual list should be an ascending or descending sequence of the integers from <code>{ i for i in range(0,n) }</code>.</li>
           </ul>
      </li>
    </ol>
  </li>

  <li>
    <ol style="list-style-type:none;">
      <li> Define a Python function <code>randByIndex()</code> that takes two inputs <code>n</code> and <code>i</code>. It should return
           the <code>i</code>th element in a "random" sequence of length <code>n</code> that contains every number in the set
           <code>{ k for k in range(0,n) }</code>. You should <b>not</b> generate the whole list of length <code>n</code> in memory.
      </li>
    </ol>
  </li>

  <li>
    <ol style="list-style-type:lower-alpha;">
      <li> Define a Python function <code>generatePrime()</code> that takes a single input <code>d</code> and generates a %d-digit (in base 10)
           probable prime. Your algorithm should be efficient enough to fairly quickly generate a 1000-digit probable prime, and should not run out
           of memory (although it may take quite some time) when generating a 10000-digit probable prime.
           
           
           <ul style="margin-top:5px;">
             <li>Make use of your solution from <b>Problem #3</b> above.</li>
             <li>Define a separate helper function <code>probablePrime()</code> that checks if its input is a probable prime.</li>
             <li>Python provides a built-in function <code>pow(a,b,m)</code> that efficiently computes %a^{%b} \mod %m.</li>
             <li>For the purposes of this assignment, you need not handle Carmichael numbers in any special way that avoids the high
                 likelihood that they are categorized as probably prime. Thus, you may use the Fermat primality test.</li>
             
             
             <!-- <li>Python provides a built-in function <code>randint(x,y)</code>, which efficiently generates a random integer between 
                 <code>x</code> and <code>y</code>. To use it, add <code>from random import randint</code> to the top of your
                 file.
             -->
             </li>
           </ul>
      </li>
    </ol>
  </li>
</ol>
<hr/><br/>
<!--/assignment2-->

<a name="3.9"></a>
<h3>Chinese remainder theorem and applications</h3>

<a name="chinese-remainder-theorem"></a>
<div class="mathenv theorem proposition_to_know">
<b>Theorem (Chinese remainder theorem):</b> Given primes %p_1,...,%p_%k \in \N, for any %a_1,...,%a_%k \in \Z there exists a solution %x \in \Z to the system of equations:
\begin{eqnarray}
  %x mod %p_1 & = & %a_1 \\
              & \vdots & \\
  %x mod %p_%k & = & %a_%k
\end{eqnarray}
We can also state the theorem in terms of congruences.
Given primes %p_1,...,%p_%k \in \N, for any %a_1 \in \Z/%p_1\Z, ..., %a_%k \in \Z/%p_%k\Z there exists a <i>unique</i> 
solution %x \in \Z/(%p_1 \cdot ... \cdot %p_%k)\Z to the system of equations:
\begin{eqnarray}
  %x & \equiv & %a_1 (\mod %p_1)\\
              & \vdots & \\
  %x & \equiv & %a_%k (\mod %p_%k)
\end{eqnarray}
In other words, all the solutions to the first system above are from the same congruence class of \Z/(%p_1 \cdot ... \cdot %p_%k)\Z.
The theorem applies even if %p_1,...,%p_%k are only <i>relatively prime</i>.
</div>

<b>Example:</b> Suppose we want to perform a large number of arithmetic operations in sequence (e.g., 2^{2048} operations). However,
we know that the final result of the computation will be less than 2^{256}. Since there are 2^{2048} operations, half of these may
be addition by 1, and half may be subtraction by 1. In that case, the maximum value at any given moment will be
2^{2047}. How many bits of working memory do we need to perform all the operations in sequence to obtain the final result?

Choose %p_1,...,%p_{32} such that for all %i \in {1,...,32}, 2^8 < %p_%i < 2^{16}. Notice that 
\begin{eqnarray}
  %p_1 \cdot ... \cdot %p_{32} & > & 2^8 \cdot ... \cdot 2^8 \\
                               & > & 2^{8*32} \\
                               & > & 2^{256}
\end{eqnarray}
However, since %p_%i < 2^{16} for all %i, we only need 32 \cdot 2^{16} = 2^{21} bits to represent any single point in the computation.
Once we obtain the results %a_1,...,%a_{32}, we can apply the Chinese remainder theorem to obtain %x. Since the product of the primes
is greater than 2^{256}, the value %x will be the result of the computation.

<b>Example (variant of range ambiguity resolution):</b> Suppose we want to build a radar or other sensing device that sends 
signals out and listens for reflections of those signals 
in order to detect the distances of obstacles in the environment. The device has a clock that counts up from 0, one integer per second. 
If the device sends a single signal out that travels at 1 km per second at time 0 and receives a response in 12 seconds at time 12,
it knows that the distance to the object and back is 12 km.

However, what if we cannot wait 12 seconds or more? For example, the obstacle may be moving quickly and we want to constantly update
our best guess of the distance to that object. We would need to send signals more frequently (for example, every 5 seconds). But then
if an object is 12 seconds away, we would have no way to tell when running in a steady state which of the signals we just received.

However, we can obtain some information in this scenario. Suppose we send a signal every 5 seconds, only when the clock's timer is at
a multiple of 5. Equivalently, imagine the clock counts up modulo 5 (i.e., 0,1,2,3,4,0,1,2,3,4,0,...) and we only send signals when
the clock is at 0. What information can we learn about the object's distance in this scenario? If the distance to the object and back
is %d, then we would learn %d \mod 5, because we would get the signal back when the clock is at 0, 1, 2, 3, or 4.

We can use multiple instances of the above device (each device using its own distinct frequency for sending signals)
to build a device that can check for obstacles more frequently while not giving up too
much accuracy. Pick a collection of primes %p_1,..., %p_%n such that their product is greater than the distance to any possible obstacle
(e.g., if this is a ship or plane, we could derive this by considering the line of sight and the Earth's curvature). Take %n instances
of the above devices, each with their own clock that counts in cycles through \Z/%p_%i\Z and sends out a signal when the clock is at 0.
Running in a steady state, if at any point in time the known offsets are %a_1,...,%a_%n, we would know the following about the distance %d to an obstacle:
\begin{eqnarray}
  %d & \equiv & %a_1 (\mod %p_1)\\
              & \vdots & \\
  %d & \equiv & %a_%n (\mod %p_%n)
\end{eqnarray}
We can then use the Chinese remainder theorem to derive the actual distance %d < %p_1 \cdot ... \cdot %p_%n.

<a name="lecture7"></a>
<b>Example (Shamir secret sharing):</b> Suppose there are %N participants and we want to divide some secret information among them into %N parts
so that any %k or greater number of participants can reconstruct the secret information, but no subset of fewer than %k participants can reconstruct
it. Let %s \in \Z be the secret information.

Collect a set of randomly chosen relatively prime integers %M = {%m_1,...,%m_%N} such that:
<ul>
  <li>the product of any collection of at least %k integers in %M is greater than %s;</li>
  <li>the product of any collection of %k-1 integers in %M is less than %s.</li>
</ul>
Give each participant %i \in {1,...,%N} the value %s \mod %m_%i. Now, any number of participants %n \geq %k can
use the Chinese remainder theorem to solve for %s.

<b><i>Note:</i></b> There are many alternative ways to implement Shamir secret sharing. Consider the following example using curve-fitting.
We choose some large %m \in \Z, and then randomly select integers %c_1,...,%c_%k \in \Z/%m\Z. 
We then use these integers as coefficients in a polynomial:
\begin{eqnarray}
  %f(%x) & = & %s + %c_1 %x + %c_2 %x^2 + ... + %c_%k %x^{%k}
\end{eqnarray}
Each participant %i \in {1,...,%N} is given %f(%i). Any %k participants can now use curve-fitting techniques or techniques for
solving collections of equations (e.g., computing the reduced row echelon form of a matrix) to determine all the coefficients of %f and, thus,
solve for %s.

<a name="bezout-identity"></a>
<div class="mathenv fact proposition_to_know">
<b>Fact (B&eacute;zout's identity):</b> For any two integers %x \in \Z, %y \in \Z where %x \neq 0 or %y \neq 0, let %z = \gcd(%x,%y). Then
there exist %a \in \Z and %b \in \Z such that:
\begin{eqnarray}
  %a \cdot %x + %b \cdot %y & = & %z
\end{eqnarray}
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> For any two integers %x \in \Z, %y \in \Z where %x \neq 0 or %y \neq 0, and \gcd(%x,%y) = 1, there exist %a \in \Z and %b \in \Z 
such that:
\begin{eqnarray}
  %a \cdot %x + %b \cdot %y & = & 1
\end{eqnarray}
This fact is a special case of B&eacute;zout's identity (i.e., the case in which \gcd(%x,%y) = 1).
</div>

<a name="algorithm-extended-euclidean"></a>
<div class="mathenv fact proposition_to_know">
<b>Fact:</b> The collection of equations considered in the Chinese remainder theorem can be solved constructively (i.e., in a way that provides
a concrete solution and not just a proof that a solution exists) by applying an extended version of the greatest common divisor
algorithm. We provide the definition of the algorithm below.

<ol style="list-style-type:none;">
 <li><b>extended Euclidean algorithm:</b> %x \in \Z, %y \in \Z</li>
 <li>
   <ol style="list-style-type:none;">
     <li>if %y = 0
       <ol style="list-style-type:none;">
         <li>(%s,%t) := (1, 0)</li>
         <li>return (%s,%t)</li>
       </ol>
     </li>
     <li>otherwise
       <ol style="list-style-type:none;">
         <li>(%s,%t) := <b>extended Euclidean algorithm</b>(%y, %x \mod %y)</li>
         <li>return (%t, %s - (\lfloor %x/%y \rfloor \cdot %t) )</li>
       </ol>
     </li>
   </ol>
 </ol>

Given two inputs %x \in \Z, %y \in \Z, the extended Euclidean algorithm returns two integres %u, %v such that
\begin{eqnarray}
  %u \cdot %x + %v \cdot %y & = & \gcd(%x,%y)
\end{eqnarray}
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> For two coprime %m \in \Z and %n \in \Z and any %a \in \Z and %b \in \Z, suppose we have the following system:
\begin{eqnarray}
  %x & \equiv & %a (\mod %m)\\
  %x & \equiv & %b (\mod %n)
\end{eqnarray}
Since \gcd(%m,%n) = 1, we can use the extended Euclidean algorithm to find %u and %v \in \Z such that:
\begin{eqnarray}
  %u \cdot %m + %v \cdot %n & = & 1
\end{eqnarray}
Then the solutions to the system are in the congruence class:
\begin{eqnarray}
  %x & \equiv & (%u \cdot %m) \cdot %b + (%v \cdot %n) \cdot %a (\mod (%m \cdot %n))
\end{eqnarray}
</div>

We can check that the above is indeed a solution to %x \equiv %a (\mod %m). Consider the following:
\begin{eqnarray}
  %u \cdot %m + %v \cdot %n & = & 1 \\
  %v \cdot %n & = & 1 - %u \cdot %m\\
  %v \cdot %n & \equiv & 1 (\mod %m)\\
\end{eqnarray}
Furthermore, we have that:
\begin{eqnarray}
  ((%u \cdot %m) \cdot %b) \mod %m & = & 0 
\end{eqnarray}
Then, we can conclude:
\begin{eqnarray}
  ((%u \cdot %m) \cdot %b + (%v \cdot %n) \cdot %a) \mod %m & = & 0 + ((%v \cdot %n) \cdot %a) \mod %m \\
                                                            & = & 0 + (1 \cdot %a) \mod %m \\
                                                            & = & %a \mod %m
\end{eqnarray}
Using a similar argument, we can show that the solution is also equivalent to %b (\mod %m).

<div class="mathenv example_to_know">
<b>Example:</b> Suppose we want to solve the following system:
\begin{eqnarray}
  %x & \equiv & 23 (\mod 100)\\
  %x & \equiv & 31 (\mod 49)
\end{eqnarray}

We use the extended Euclidean algorithm to find that:
\begin{eqnarray}
  (-24) \cdot 100 + 49 \cdot 49 & = & 1
\end{eqnarray}
Then the solutions to the system are in the congruence class:
\begin{eqnarray}
  %x & \equiv & (-24 \cdot 100) \cdot 31 + (49 \cdot 49) \cdot 23 (\mod (100 \cdot 49)) \\
     & \equiv & -19177 \mod 4900 \\
     & \equiv & 423
\end{eqnarray}
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> Suppose we are given a collection of equations of the following form such that %m_1,...,%m_%k are all pairwise coprime.

\begin{eqnarray}
  %x & \equiv & %a_1 (\mod %m_1)\\
              & \vdots & \\
  %x & \equiv & %a_%k (\mod %m_%k)
\end{eqnarray}

Let %C be the set of these equations, where %C_%i is the %ith equation. The following algorithm can be used to find a solution for this
system of equations.

<ol style="list-style-type:none;">
 <li><b>solve system of equations:</b> %C is a set of constraints %x \equiv %a_%i \mod %m_%i</li>
 <li>
   <ol style="list-style-type:none;">
     <li> while |%C| > 1
       <ol style="list-style-type:none;">
         <li>remove two equations %C_%i and %C_%j from %C and solve them to obtain a new equation %x \equiv %c (\mod %m_%i \cdot %m_%j)</li>
         <li>add the new equation to %C</li>
       </ol>
     </li>
     <li> return the one equation left in %C</li>
   </ol>
 </li>
</ol>
</div>

<a name="lecture8"></a>
<a name="3.10"></a>
<h3>Euler's totient function, multiplicative inverses in \Z/%m\Z, and applications</h3>

<a name="additive-inverse-modulo"></a>
<div class="mathenv fact proposition_to_know">
<b>Fact:</b> For any %m \in \N, every element in the set \Z/%m\Z has an inverse with respect to addition defined over \Z/%m\Z (i.e., an <i>additive inverse</i>).
Consider any %x \in \Z/%m\Z. Then %p - %x \in \Z/%m\Z and
\begin{eqnarray}
  %x + (%p - %x) & \equiv & %p (\mod %p)\\
                 & \equiv & 0
\end{eqnarray}
We denote by -%x the additive inverse of %x.
</div>

<div class="mathenv example_to_know">
<b>Example:</b> What is the additive inverse of 2 \in \Z/5\Z?

The additive inverse is 5-2 = 3, since 2 + 3 \mod 5 = 0.
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> For any %m \in \N, an %x \in \Z/%m\Z has an inverse with respect to multiplication defined over \Z/%m\Z 
(i.e., a <i>multiplicative inverse</i>)
iff \gcd(%x,%m) = 1. If a multiplicatice inverse %a \in \Z/%m\Z of %x exists, then:
\begin{eqnarray}
  %a \cdot %x & \equiv & 1 (\mod %m)
\end{eqnarray}
We usually denote the multiplicative inverse of %x using the notation %x^{-1}.
</div>

<a name="lecture9"></a>
<div class="mathenv definition proposition_to_know">
<b>Definition:</b> For any input %m \in \N, define <i>Euler's totient function</i> \phi by:
\begin{eqnarray}
  \phi(%m) & = & |{%k | %k \in {1,...,%m}, \gcd(%k,%m) = 1}|\\
\end{eqnarray}
</div>

<div class="mathenv example_to_know">
<b>Example:</b> Compute \phi(15).

\begin{eqnarray}
  \phi(15) & = & |{%k | %k \in {1,...,15}, \gcd(%k,15) = 1}| \\ 
           & = & |{1,2,4,7,8,11,13,14}| \\
           & = & 7
\end{eqnarray}
</div>

<div class="mathenv example_to_know">
<b>Example:</b> Suppose %p \in \N is a prime number. What is \phi(%p)?

\begin{eqnarray}
  \phi(%p) & = & |{%k | %k \in {1,...,%p}, \gcd(%k,%p) = 1}| \\ 
           & = & |{1,2,3,...,%p-1}| \\
           & = & %p-1
\end{eqnarray}
</div>

<div class="mathenv example_to_know">
<b>Example:</b> What is \phi(15)?
\begin{eqnarray}
  \phi(15) & = & |{%k | %k \in {1,...,15}, \gcd(%k,15) = 1}| \\ 
           & = & 15 - |{%k | %k \in {1,...,15}, \gcd(%k,15) \neq 1}| \\
           & = & 15 - |{3,6,9,12,15} \cup {5,10,15}| \\
           & = & 15 - |{3,6,9,12}| - |{5,10}| - |{15}| \\
           & = & 15 - (5-1) - (3-1) - 1 \\
           & = & 15 - 5 - 3 + 1 + 1 - 1 \\
           & = & 15 - 5 - 3 + 1 \\
           & = & (3 \cdot 5) - 5 - 3 + 1 \\
           & = & (3-1) \cdot (5-1)
\end{eqnarray}
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> For any %x \in \N and %y \in \N, if \gcd(%x,%y) = 1 then:
\begin{eqnarray}
  \phi(%x) \cdot \phi(%y) & = & \phi(%x \cdot %y)
\end{eqnarray}
</div>

<div class="mathenv example_to_know">
<b>Example:</b> Suppose %p \in \N and %q \in \N are prime numbers. What is \phi(%p \cdot %q)?

\begin{eqnarray}
  \phi(%p \cdot %q) & = & \phi(%p) \cdot \phi(%q) \\ 
                    & = & (%p-1) \cdot (%q-1)
\end{eqnarray}
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> For any prime %p \in \N, we have that:
\begin{eqnarray}
  \phi(%p^{%k}) & = & %p^{%k} - %p^{%k-1}
\end{eqnarray}
</div>

<div class="fact">
<b>Fact:</b> For any %a \in \N and %m \in \N, if %a^{%m-1} \mod %m = 1 then:
\begin{eqnarray}
  %a^{%m-1} \mod %m & = & 1 \\
  %a^{%m-1} & = & 1 + %k \cdot %m \\
  1 & = & \gcd(1 + %k \cdot %m, %k \cdot %m)  \\
    & = & \gcd(%a^{%m-1}, %k \cdot %m) \\
    & = & \gcd(%a, %k \cdot %m) \\
    & = & \gcd(%a, %m) \\
\end{eqnarray}
Thus, %a and %m are coprime.
</div>

<div class="">
<b>Example:</b> Suppose %m \in \N is a Carmichael number. At most how many Fermat liars does %m have?
</div>

<div class="fact">
<b>Fact:</b> We can use \phi to provide a formula for the probability that the Fermat primality test
will detect that a Carmichael number %m \in \N is actually composite. It is approximately:
\begin{eqnarray}
  (%m - \phi(%m)) / %m
\end{eqnarray}
To be more precise (since we do not check 0 or 1 in our actual implementation), it is:
\begin{eqnarray}
  ((%m - 3) - \phi(%m)) / (%m - 3)
\end{eqnarray}
</div>

Unfortunately, Euler's totient function does not in general have a better upper bound than %f(%m) = %m.

<div class="mathenv example_to_know">
<b>Example:</b> How many elements of \Z/%m\Z have a multiplicative inverse in \Z/%m\Z?

Since an %x \in \Z/%m\Z has an inverse iff \gcd(%x,%m) = 1. Thus, the set of such %x is exactly the set
{%x | %x \in {1,...,%m}, \gcd(%k,%m) = 1}. But this is the definition of \phi(%m). Thus, there are \phi(%m)
elements in \Z/%m\Z that have a multiplicative inverse.
</div>

<a name="euler-theorem"></a>
<div class="mathenv fact proposition_to_know">
<b>Fact (Euler's theorem):</b> For any %m \in \N and %a \in \Z/%m\Z, if \gcd(%m,%a) = 1 then we have that:
\begin{eqnarray}
  %a^{\phi(%m)} \mod %m & = & 1
\end{eqnarray}
</div>

Notice that if %m is a prime number, then \phi(%m) = %m-1. Then for any %a \in \Z/%m\Z, \gcd(%a,%m) = 1 and
%a^{%m-1} \mod %m = 1. This is exactly the statement of <a href="#fermat-little-theorem">Fermat's little theorem</a>. Thus,
Euler's theorem is a generalization of Fermat's little theorem.

<a name="euler-theorem"></a>
<div class="mathenv fact proposition_to_know">
<b>Fact:</b> For any %m \in \N and %a \in \Z/%m\Z, if \gcd(%m,%a) = 1 then for any %i \in \Z/\phi(%m)\Z such that %i \equiv 0 we have that
\begin{eqnarray}
  %a^{%i} \mod %m & = & 1
\end{eqnarray}
This is because:
\begin{eqnarray}
  %i & \equiv & 0 (\mod \phi(%m)) \\
     & = & %k \cdot \phi(%m) \\
  %a^{\phi(%m) \cdot %k} \mod %m & = & (%a^{\phi(%m)})^{%k} \mod %m \\
                                 & = & 1^{%k} \mod %m\\
                                 & = & 1 \mod %m
\end{eqnarray}
</div>

We saw above that there is a <a href="#additive-inverse-modulo">simple closed formula</a> for computing an additive 
inverse of an element %a \in \Z/%m\Z: %m-%a. In \Q (the set of rational numbers), computing the multiplicative inverse
%a^{-1} is straightforward: the inverse of an integer %a \in \Q is 1/%a. Is there a way to compute %a^{-1} \in \Z/%m\Z if it exists?

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> For any %m \in \N and %a \in \Z/%m\Z where \gcd(%m,%a) = 1, we can use the
<a href="#algorithm-extended-euclidean">extended Euclidean algorithm</a> to find the inverse of %a.
Given an input %a and %m, the algorithm returns %s and %t such that:
\begin{eqnarray}
  %s \cdot %a + %t \cdot %m & = & 1 \\
  %s \cdot %a - (-%t) \cdot %m & = & 1 \\
  %s \cdot %a & = & 1 + ((-%t) \cdot %m)\\
  (%s \cdot %a) \mod %m& = & 1
\end{eqnarray}
Thus, %s \mod %m is the multiplicative inverse of %a in \Z/%m\Z.
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> For any %m \in \N and %a \in \Z/%m\Z where \gcd(%m,%a) = 1, we can use the
<a href="#euler-theorem">Euler's theorem</a> to find the inverse of %a. Notice that:
\begin{eqnarray}
  %a^{\phi(%m)} \mod %m & = & 1 \\
  (%a^{\phi(%m)-1} \cdot %a) \mod %m & = & 1
\end{eqnarray}
Thus, %a^{\phi(%m)-1} \mod %m is the multiplicative inverse of %a in \Z/%m\Z.
</div>

<div class="mathenv example_to_know">
<b>Example:</b> Find the multiplicative inverse of 5^2 \mod 7 in \Z/7\Z.

It is sufficient to notice that 5^6 \equiv 1 (\mod 7), so 5^2 \cdot 5^4 \equiv 1, so 5^4 is the inverse of 5^2 in \Z/7\Z.
</div>

<div class="mathenv example_to_know">
<b>Example:</b> Does 11 have an inverse in \Z/22\Z (i.e., is it true that 11 \in (\Z/22\Z)*)?
</div>

<div class="mathenv definition proposition_to_know">
<b>Definition:</b> For %m \in \N, We define (\Z/%m\Z)* to be the following subset of
\Z/%m\Z:
\begin{eqnarray}
  (\Z/%m\Z)* & = & { %a | %a \in \Z/%m\Z, %a has an inverse in \Z/%m\Z }
\end{eqnarray}
</div>

<div class="mathenv example_to_know">
<b>Example:</b> Compute |(\Z/35\Z)*|.

\begin{eqnarray}
  |(\Z/35\Z)*| & = & |{ %a | %a \in \Z/35\Z, %a has an inverse in \Z/35\Z }| \\
               & = & |{ %a | %a \in \Z/35\Z, \gcd(%a,35) = 1 }| \\
               & = & |{ %a | %a \in \Z/35\Z, \gcd(%a,35) = 1 }| \\
               & = & \phi(35) \\
               & = & \phi(5 \cdot 7) \\
               & = & \phi(5) \cdot \phi(7) \\
               & = & 4 \cdot 6 \\
               & = & 24 \\
\end{eqnarray}
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> For any %m \in \N, (\Z/%m\Z)* is closed under multiplication modulo %m.
That is, for any %a \in \Z/%m\Z and %b \in \Z/%m\Z, if there exist %a^{-1} \in \Z and %b^{-1} \in \Z
then (%a \cdot %b) has an inverse (%a^{-1} \cdot %b^{-1}). We can use the commutativity of multiplication to show this:
\begin{eqnarray}
 (%a \cdot %b) \cdot (%a^{-1} \cdot %b^{-1}) & \equiv & (%a \cdot %a^{-1}) \cdot (%b \cdot %b^{-1}) \\
                                             & \equiv & 1 \cdot 1 \\
                                             & \equiv & 1
\end{eqnarray}
</div>

<a name="RSA-protocol"></a>
<div class="mathenv example_to_know">
<b>Example (RSA protocol):</b> We introduce the RSA public-key cryptographic protocol. This protocol is useful in many scenarios, such
as the following:
<ul>
  <li>a sender wants to send the receiver a secret message over a public channel;</li>
  <li>a receiver wants to allow any number of senders to send him messages over a public channel, 
      and the receiver does not yet know who the senders will be.</li>
</ul>
This protocol can also be used to prove the identity of the receiver.

<ul>
  <li><b>Key generation (performed by the receiver):</b> 
    <ol>
      <li>Randomly choose two <b>secret</b> prime numbers %p \in \N and %q \in \N of similar size.</li>
      <li>Compute a <b>public key</b> value %n = %p \cdot %q.</li>
      <li>Compute the <b>secret</b> value \phi(%n) = (%p-1) \cdot (%q-1).</li>
      <li>Choose a <b>public key</b> value %e \in {2,...,\phi(%n)-1} such that \gcd(%e, \phi(%n)) = 1.</li>
      <li>Compute the <b>secret private key</b> %d = %e^{-1} \mod \phi(%n)</li>
    </ol>
  </li>
  <li><b>Protocol (encryption and decryption):</b> There are two participants: the sender and the receiver. 
    <ol>
      <li>The sender wants to send a <b>message</b> %m \in {0,...,%n-1} where \gcd(%m,%n) = 1 to the receiver.</li>
      <li>The receiver reveals the public key (%n,%e) to the sender.</li>
      <li>The sender computes the <b>ciphertext</b> (encrypted message) %c = %m^{%e} \mod %n.</li>
      <li>The sender sends %c to the receiver.</li>
      <li>The receiver can recover the original message by computing %m = %c^{%d} \mod %n.</li>
    </ol>
  </li>
</ul>
</div>

The above encryption-decryption process works because for some %k \in \Z:

\begin{eqnarray}
  %e \cdot %d & \equiv & 1 (\mod \phi(%n)) \\
              & = & 1 + \phi(%n) \cdot %k \\
  (%m^{%e})^{%d} \mod %n & = & (%m^{1 + \phi(%n) \cdot %k}) \mod %n\\
                         & = & (%m \cdot (%m^{\phi(%n) \cdot %k})) \mod %n\\
                         & = & (%m \cdot (%m^{\phi(%n) \cdot %k})) \mod %n\\
                         & = & (%m \cdot %m^{\phi(%n)}) \mod %n \\
                         & = & (%m \cdot 1) \mod %n \\
                         & = & %m \mod %n
\end{eqnarray}

Besides the message %m, there are three pieces of secret information that an eavesdropper cannot know in order for the
encryption to provide any privacy:
<ul>
  <li>%p and %q</li>
  <li>\phi(%n)</li>
  <li>%d = %e^{-1}</li>
</ul>

Notice that if an eavesdropper knows %p and %q where %n = %p \cdot %q, the eavesdropper can easily compute \phi(%n) (which was supposed to be private).
If the eavesdropper can compute \phi(%n), then they can use the <a href="#algorithm-extended-euclidean">extended Euclidean algorithm</a> to compute
the inverse %d = %e^{-1} of the public key value %e. They can then use %d to decrypt messages.

Suppose the eavesdropper only knows \phi(%n). Then the eavesdropper can compute %d and decrypt any message. Can the eavesdropper also recover
%p and %q? 

<a name="find-p-q-with-phi-n"></a>
<div class="mathenv fact proposition_to_know">
<b>Fact:</b> Suppose that %n = %p \cdot %q for two primes %p \in \N and %q \in \N. Given only %n and \phi(%n), it is possible
to compute %p and %q. Consider the following:
\begin{eqnarray}
 \phi(%n) & = & (%p-1)(%q-1) \\
 \phi(%n) & = & %p \cdot %q - %p - %q + 1 \\
 \phi(%n) & = & %n - %p - %q + 1 \\
 \phi(%n) - %n & = & %p - %q + 1\\
 \phi(%n) - %n - 1 & = & %p - %q
\end{eqnarray}
Thus, it is sufficient to solve the following system of equations for %p and %q:
\begin{eqnarray}
 %n & = & %p \cdot %q \\
 \phi(%n) - %n - 1 & = & %p - %q
\end{eqnarray}
</div>

<div class="mathenv example_to_know">
<b>Example:</b> Suppose that %n = 15 and \phi(%n) = 8. Factor %n.
</div>

<!--assignment3-->
<br/><hr/>
<a name="3.11"></a>
<a name="assignment3"></a>
<b>Assignment #3: CRT, Totient Function, Inverses, and Applications</b>
<!--span class="btn_assignment">(<a href="materials.php?hw=3">show only this assignment</a>)</span-->

  <p>For this assignment, you will submit a single Python source file <code>a3.py</code>.

  <b style="color:firebrick;">Your file may not import any modules or employ any external library functions associated with
  integers and sets (unless the problem statement explicitly permits this). 
  You will be graded on the correctness, concision, and mathematical legibility of your code.
  The different problems and problem parts rely on each other; carefully consider whether you can use functions you define
  in one part within subsequent parts.</b>

<ol>
  <li>
    <ol style="list-style-type:lower-alpha;">
      <li> 
           Define a Python function <code>egcd()</code> that takes two integer inputs <code>x</code> and <code>y</code>
           and returns a tuple <b style="color:firebrick;">of two integers</b> <code>(s,t)</code> that satisfies the following property:
           <ul style="margin-top:7px; margin-bottom:7px; list-style-type:none;">
             <li><code>s * x + t * y == gcd(x,y)</code></li>
           </ul>
      </li>
      <li>
           Define a Python function <code>inverse()</code> that takes two integer inputs <code>x</code> and <code>m</code>
           and returns the multiplicative inverse of <code>x</code> in \Z/%m\Z if it exists, or returns <code>None</code>
           if it does not.
      </li>
    </ol>
  </li>

  <li>
    <ol style="list-style-type:lower-alpha;">
      <li style="margin-bottom:10px;"> 
           Define a Python function <code>CRT2()</code> that takes two inputs, each of which is a pair of integers. Each of the two pairs
           of integers, call them <code>(a,m)</code> and <code>(b,n)</code>, represents one of the equations in the system of equations below:
\begin{eqnarray}
  %x & \equiv & %a (\mod %m)\\
  %x & \equiv & %b (\mod %n)
\end{eqnarray}
           <b style="color:firebrick;">You should assume %m and %n are coprime.</b>
           The function should return a single integer %x \in \Z/(%m \cdot %n)\Z that is the solution to the two equations above.
      </li>
      <li style="margin-bottom:10px;">
           Define a Python function <code>CRTN()</code> that takes one input, which is a list of pairs, each of which is of the
           form <code>(a,m)</code>. Each of the pairs in the list represents a distinct equation in the system of equations below:
\begin{eqnarray}
  %x_1 & \equiv & %a_1 (\mod %m_1)\\
     & \vdots & \\
  %x_{%k} & \equiv & %a_{%k} (\mod %m_{%k})
\end{eqnarray}
           <b style="color:firebrick;">You should assume that for every %i, %j \in {1,...,%k} where %i \neq %j, %m_{%i} and %m_{%j} are coprime.</b>
           The function should return a single integer %x \in \Z/(%m_1 \cdot ... \cdot %m_{%k})\Z that is the solution to the system of equations above.
      </li>
    </ol>
  </li>

  <li>
    <ol style="list-style-type:lower-alpha;">
      <li> 
           Define a very efficient Python function <code>pow2ModPrime()</code> that takes four integer inputs <code>x</code>,
           <code>y</code>, <code>z</code>, and <code>p</code>. This function always assumes that <code>p</code> is prime
           (it need not return a correct output if <code>p</code> is not prime, and it should not check whether
           <code>p</code> is prime). The function should return the result of the computation:
\begin{eqnarray}
  %x<sup>%y<sup>%z</sup></sup> \mod %p
\end{eqnarray}
           Your implementation may employ the built-in Python function <code>pow()</code>, which takes three inputs
           <code>a</code>, <code>b</code>, and <code>m</code> and returns %a<sup>%b</sup> \mod %m. 
           
           <b style="color:firebrick;">However, your function must be able to handle very large inputs. For example:</b>
<pre>   pow2ModPrime(3,3,1000000000000000000000,84199) # Should return 42526 quickly.
   pow(3,pow(3,1000000000000000000000),84199)     # Should be much slower than the above.
</pre>
           <b>Hint: consider the way <a href="#euler-theorem">Euler's theorem</a> 
           and the totient function \phi are used in the <a href="#RSA-protocol">RSA cryptographic protocol</a>.</b>
      </li>

      <li> Define a very efficient Python function <code>diffPows()</code> that takes three inputs: two integer inputs <code>x</code> and
           <code>y</code> and a list of distinct primes <code>ps</code>. Let %P be the product of the primes in <code>ps</code>.
           The function should return an output equivalent to:
\begin{eqnarray}
  (3<sup>3<sup>%x</sup></sup> - 2<sup>2<sup>%y</sup></sup>) \mod %P
\end{eqnarray}
           <b style="color:firebrick;">Your function must be able to handle very large inputs. For example:</b>
<pre>
   primes =[\
         15481619,15481633,15481657,15481663,15481727,15481733,15481769,15481787 
        ,15481793,15481801,15481819,15481859,15481871,15481897,15481901,15481933 
        ,15481981,15481993,15481997,15482011,15482023,15482029,15482119,15482123 
        ,15482149,15482153,15482161,15482167,15482177,15482219,15482231,15482263 
        ,15482309,15482323,15482329,15482333,15482347,15482371,15482377,15482387 
        ,15482419,15482431,15482437,15482447,15482449,15482459,15482477,15482479 
        ,15482531,15482567,15482569,15482573,15482581,15482627,15482633,15482639 
        ,15482669,15482681,15482683,15482711,15482729,15482743,15482771,15482773 
        ,15482783,15482807,15482809,15482827,15482851,15482861,15482893,15482911 
        ,15482917,15482923,15482941,15482947,15482977,15482993,15483023,15483029 
        ,15483067,15483077,15483079,15483089,15483101,15483103,15483121,15483151 
        ,15483161,15483211,15483253,15483317,15483331,15483337,15483343,15483359 
        ,15483383,15483409,15483449,15483491,15483493,15483511,15483521,15483553 
        ,15483557,15483571,15483581,15483619,15483631,15483641,15483653,15483659 
        ,15483683,15483697,15483701,15483703,15483707,15483731,15483737,15483749 
        ,15483799,15483817,15483829,15483833,15483857,15483869,15483907,15483971 
        ,15483977,15483983,15483989,15483997,15484033,15484039,15484061,15484087 
        ,15484099,15484123,15484141,15484153,15484187,15484199,15484201,15484211 
        ,15484219,15484223,15484243,15484247,15484279,15484333,15484363,15484387 
        ,15484393,15484409,15484421,15484453,15484457,15484459,15484471,15484489 
        ,15484517,15484519,15484549,15484559,15484591,15484627,15484631,15484643 
        ,15484661,15484697,15484709,15484723,15484769,15484771,15484783,15484817 
        ,15484823,15484873,15484877,15484879,15484901,15484919,15484939,15484951 
        ,15484961,15484999,15485039,15485053,15485059,15485077,15485083,15485143 
        ,15485161,15485179,15485191,15485221,15485243,15485251,15485257,15485273 
        ,15485287,15485291,15485293,15485299,15485311,15485321,15485339,15485341 
        ,15485357,15485363,15485383,15485389,15485401,15485411,15485429,15485441 
        ,15485447,15485471,15485473,15485497,15485537,15485539,15485543,15485549 
        ,15485557,15485567,15485581,15485609,15485611,15485621,15485651,15485653 
        ,15485669,15485677,15485689,15485711,15485737,15485747,15485761,15485773 
        ,15485783,15485801,15485807,15485837,15485843,15485849,15485857,15485863]
        
   # The code below should take at most a second or two to evaluate.
   diffPows(100000000000000000000, 100000000000000000000, primes)
   
   # The output of the above should be:
   1014583418021155147669596086281029838529720782206361091583595823689719157476532284
   8987189887167799660866466205679182087923947730758196605113875528351517618438642265
   3581039473366623112437577201358820794341439719440271391920116932817847656116153368
   7265432104820323843042836554017993078689112459259244886127618081567160190817432495
   2143410149340178452973885327762236756547669499168330784109081344938468727993713195
   3169678339499877031537565519050932012817516387739533522394516718093516017690196562
   7101427207866265547550708480269630690614590278546972352636005909708527043821426318
   4521095281729009794902244831649627645067744531132354275086194660115820734317391275
   9128112857042672881445685539242864388276070829222553398880738035689262514826688173
   6913562704802954300877406726543052076808476120620371564427614984332631535660033277
   8189204900085569366429138226629079794533371458002969316578012640171885098224952913
   3491159071950682951158132515447103910101337602328824428482135061810959708064341298
   2041798901080878626343050467586243536238154444445605344046612862002597217912264786
   0824335665138449552625836001208039714421654922433127769977323976312559879889522757
   1709222772581924582016690799105293131715244224202006451140406716336817962814141853
   2115825675072522109019428377974687020928180075572057614974579410052738475293483072
   3761795114940096414122259399758778638409278794055719938284333607939097874832982043
   1353079076167862532446907487602733400201159484031421148157283172670287937374484685
   4508879443653756784061411297770071775372502147954692284657158826404250380999506744
   2785210787255712896681508731293497639546329245604994768139819393571953247354217371
   7900740573848181518094539324832238278064519569345203659830437641031472046598369915
   89585651957609932891856423136539428409811645597728586100980931
</pre>
      </li>
    </ol>
  </li>

  <li> In this problem you will implement the three component algorithms of the 
       <a href="#RSA-protocol">RSA cryptographic protocol</a> described in lecture.
    <ol style="list-style-type:lower-alpha; margin-top:5px;">
      <li> Define a Python function <code>generate()</code> that takes a single integer input <code>k</code> and
           returns a tuple <code>(n,e,d)</code> corresponding to the public values %n and %e and private key %d in the RSA
           cryptographic protocol. The output <code>n</code> must be the product of two distinct, randomly chosen 
           <code>k</code>-digit primes.          
           <ul style="margin-top:5px;">
             <li>You may import and use the Python random number generator (<code>from random import random</code> or
             <code>from random import randint</code>).</li>
             <li>Your algorithm does not need to be efficient, but it should always be correct.</li>
           </ul>  
      </li>
      <li> Define a Python function <code>encrypt()</code> that takes two inputs: an integer <code>m</code> and a tuple
           <code>(n,e)</code>. It should return a single integer: the ciphertext <code>c</code>.
      </li>
      <li> Define a Python function <code>decrypt()</code> that takes two inputs: an integer <code>c</code> representing the ciphertext and a
           pair of integers <code>(n,d)</code> representing the private key. It should decrypt <code>c</code> and return the original message
           <code>m</code>.
      </li>
    </ol>
  </li>

</ol>
<hr/><br/>
<!--/assignment3-->

<a name="lecture10"></a>
<a name="4"></a>
<!--<hr style="margin-bottom:80px;"/>-->
<h2>Complexity of Modular Arithmetic Algorithms</h2>

<a name="4.1"></a>
<h3>Complexity of (probably) intractable problems</h3>

Below, we review a small set of definitions and facts from complexity theory. We will only use these facts as they relate to problems in modular arithmetic
and abstract algebra. A course on computational complexity theory would go into more detail.

Informally, for some formula %F, we call a statement of the following form a <i>problem</i>:
<ul style="list-style-type:none;">
  <li>"<i>Given %X, find %Y such that %F(%X, %Y) is true.</i>"</li>
</ul>

In the above, %X can be viewed as the input describing the problem, and %Y can be viewed as the solution to the problem.

The <i>complexity</i> of a problem refers to the running time of the most efficient algorithm that solves the problem.

<div class="mathenv fact proposition_to_know">
<b>Definition:</b> A problem can be solved in polynomial time (it is in %P) iff there exists for some constant %c an algorithm that solves all instances of
the problem in time O(%n^{%c}).
</div>

<div class="mathenv fact proposition_to_know">
<b>Definition:</b> A problem can be solved in exponential time iff there exists an algorithm that solves all instances of
the problem in time O(2^{%n}).
</div>

<div class="mathenv fact proposition_to_know">
<b>Definition:</b> There exists a <i>polynomial-time reduction</i> from a problem %X to a problem %Y iff there exists a polynomial-time algorithm that
can convert any instance of problem %X into an instance of problem %Y.
</div>

<div class="mathenv fact proposition_to_know">
<b>Conjecture (factoring):</b> The following problem is not in P: given any integer %n \in \N where %n = %p \cdot %q and %p and %q 
are prime, find %p and %q.
</div>

<div class="mathenv fact proposition_to_know">
<b>Conjecture (computing \phi):</b> The following problem is not in P: given any integer %n \in \N where %n = %p \cdot %q and %p and %q are prime, find
\phi(%n).

If we can compute \phi(%n), then <a href="#find-p-q-with-phi-n">we can compute %p and %q</a>. If computing \phi(%n) were any easier than
factoring %n (e.g., if we had a polynomial-time algorithm for computing \phi(%n)), then our claim about the hardness of factoring %n would 
be a contradiction. In other words, factoring %n can be <i>reduced</i> to solving \phi(%n).
</div>

The above fact (i.e., that if factoring %n is not in P, then neither is computing \phi(%n))
holds for arbitrary %n, not just a product of two primes. However, the proofs in those cases are more
sophisticated [<a href="http://www.shoup.net/ntb/ntb-v2.pdf">Shoup</a>].

<div class="mathenv fact proposition_to_know">
<b>Conjecture (RSA problem):</b> The following problem is not in P: given %n = %p \cdot %q for two primes %p and %q in \N, 
%e \in \Z/\phi(%n)\Z, and %m^{%e} \mod %n for an unknown %m \in \Z/%n\Z, compute %m.

Notice that the RSA problem is analogous to computing the %eth root of %m^{%e}:
\begin{eqnarray}
 ^{%e}\sqrt(%m^{%e}) & = & %m
\end{eqnarray}

Note that this can be accomplished by first finding \phi(%n) and then computing the inverse of %e, but this is as difficult as factoring
%n, and we assume that is not in P. Is there another way to
compute %m? We do not know, but we assume that there is no other <i>faster</i> (i.e., polynomial-time) way to do so.
</div>

<a name="lecture11"></a>

<div class="mathenv fact proposition_to_know">
<b>Conjecture (discrete logarithm assumption):</b> The following problem is not in P: 
given %n in \N, %m \in {1,...,%n-1}, and %m^{%e} \mod %n for an unknown %e \in \N,
compute %e.

Notice that this is analogous to computing the logarithm of a value with respect to a known base %m:
\begin{eqnarray}
 \log_{%m} (%m^{%e}) & = & %e
\end{eqnarray}
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b>
Given some %n \in \N and some %y \in \Z/%n\Z, we say that %y is a <i>quadratic residue</i> in \Z/%n\Z if
there exists %x \in \Z/%n\Z such that %x^2 \equiv %y.
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b>
Given some %n \in \N and some %y \in \Z/%n\Z, if %y is a <i>quadratic residue</i> in \Z/%n\Z then
there exist <i>at least</i> two %a,%b \in \Z/%n\Z such that %a \neq %b, %a^2 \equiv %y, and %b^2 \equiv %y.

Note that this is analogous to square roots in \Z (since \sqrt(%z) \in \Z and -\sqrt(%z) \in \Z are both square roots of %z \in \Z if they exist).

We can prove this fact in the following way: suppose that %y is a quadratic residue. Then there exists at least one %x \in \Z/%n\Z such that:
\begin{eqnarray}
 %x^2 \mod %n & = & %y
\end{eqnarray}
But this means that (%n-%x) \in \Z/%n\Z is such that:
\begin{eqnarray}
  ((%n-%x)^2) \mod %n & = & (%n^2 - (2 \cdot %n \cdot %x) + %x^2) \mod %n \\
                      & = & %x^2 \mod %n \\
                      & = & %y \mod %n \\
\end{eqnarray}
Thus, %x and (%n-%x) are both roots of %y.
</div>

<div class="mathenv example_to_know">
<b>Example:</b> It is the case that 4 \in \Z/5\Z is a quadratic residue in \Z/5\Z, with two roots 2 and 3:
\begin{eqnarray}
 2^2 \mod 5 & = & 4 \\
 3^2 \mod 5 & = & 9 \mod 5 \\
            & = & 4 \\
\end{eqnarray}
</div>

In fact, there may exist <i>more than two</i> roots of a value in \Z/%n\Z.

<div class="mathenv example_to_know">
<b>Example:</b> It is the case that 1,-1,6,-6 \in \Z/35\Z are all square roots of 1 \in \Z/35\Z:
\begin{eqnarray}
 1^2 \mod 35 & = & 1 \\
 (-1)^2 \mod 35 & = & 34^2 \mod 35 \\
                & = & 1156 \mod 35 \\
                & = & ((33 \cdot 35)+1) \mod 35 \\
                & = & 1 \mod 35 \\
 6^2 \mod 35 & = & 36 \mod 35 \\
                & = & 1 \mod 35 \\
 (-6)^2 \mod 35 & = & 29^2 \mod 35 \\
                & = & 841 \mod 35 \\
                & = & ((24 \cdot 35)+1) \mod 35 \\
                & = & 1 \mod 35
\end{eqnarray}
</div>

Let us consider the problem of finding all of the square roots of a member of \Z/%n\Z.
Notice that this problem is analogous to computing <i>all</i> the square roots of %y in \Z/%n\Z:
\begin{eqnarray}
 \sqrt(%y) & = & \pm %x
\end{eqnarray}
This problem is believed to be computationally difficult.

<div class="mathenv fact proposition_to_know">
<b>Conjecture (finding congruent squares):</b> The following problem is not in P: given %n = %p \cdot %q for two primes %p and %q in \N and
%y \in \Z/%n\Z, find an %x \in \Z/%n\Z such that %x^2 \equiv %y^2 but %x \not\equiv \pm %y.

Factoring can be reduced to finding congruent squares. Suppose we want to factor %n. We find %x and %y such that:
\begin{eqnarray}
 %x^2 \mod %n & = & %y^2 \mod %n \\
 0 \mod %n & = & (%x^2-%y^2) \mod %n \\
           & = &  ((%x+%y) \cdot (%x-%y)) \mod %n \\
 %n & | & (%x+%y) \cdot (%x-%y)
\end{eqnarray}
Since %n cannot divide (%x+%y) (because %x \not\equiv \pm %y, so %x + %y \neq %n), and it cannot divide (%x-%y) (since (%x+%y) < %n), and
(%x-%y) \neq 0 (since %x \not\equiv \pm %y), it must be that %n shares factors with both (%x+%y) and (%x-%y). Thus, it must be that either
\gcd(%n,%x + %y) or \gcd(%n,%x - %y) is a non-trivial factor of %n, and this can be computed efficiently.
</div>

<a name="lecture12"></a>

Suppose that for a prime %p, we can solve the congruent squares problem efficiently (in fact, we have such algorithms
for %p \equiv 3, %p \equiv 5, and %p \equiv 7 in \Z/8\Z, but for primes where %p \equiv 1 (\mod 8), no efficient
algorithm is known). Then we can use the <a href="#chinese-remainder-theorem">Chinese remainder theorem</a> to solve the congruent squares
problem for %n = %p \cdot %q where %p and %q are prime.

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> Let %p \in \N be a prime such that %p \mod 4 = 3, and suppose that %y \in \Z/%p\Z. Then %y has either 0, 1, or 2 roots in \Z/%p\Z.
</div>

<div class="mathenv fact example_to_know">
<b>Example:</b> Consider 3 \in \Z/7\Z. We have that:
\begin{eqnarray}
 0^2 \equiv 0 (\mod 7) \\
 1^2 \equiv 1 (\mod 7) \\
 2^2 \equiv 4 (\mod 7) \\
 3^2 \equiv 2 (\mod 7) \\
 4^2 \equiv 2 (\mod 7) \\
 5^2 \equiv 4 (\mod 7) \\
 6^2 \equiv 1 (\mod 7)
\end{eqnarray}
Notice that 3, 5, and 6 are not quadratic residues in \Z/7\Z. Thus, %x^2 \equiv 3, %x^2 \equiv 5, and %x^2 \equiv 6 have solutions in \Z/7\Z.
</div>

<div class="mathenv fact example_to_know">
<b>Example:</b> Consider 0 \in \Z/3\Z. We have that:
\begin{eqnarray}
 0^2 \equiv 0 (\mod 3) \\
 1^2 \equiv 1 (\mod 3) \\
 2^2 \equiv 1 (\mod 3)
\end{eqnarray}
Thus, x^2 \equiv 0 has exactly one solution in \Z/3\Z.
</div>

<div class="mathenv fact example_to_know">
<b>Example:</b> Consider 3 \in \Z/5\Z. We have that:
\begin{eqnarray}
 0^2 \equiv 0 (\mod 5) \\
 1^2 \equiv 1 (\mod 5) \\
 2^2 \equiv 4 (\mod 5) \\
 3^2 \equiv 4 (\mod 5) \\
 4^2 \equiv 1 (\mod 5)
\end{eqnarray}
Notice that 2 and 3 are not quadratic residues in \Z/5\Z. Thus, neither %x^2 \equiv 2 nor %x^2 \equiv 3 have solutions in \Z/5\Z.
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> Let %p \in \N be a prime such that %p \mod 4 = 3, and suppose that %y \in \Z/%p\Z is a quadratic residue with two roots in \Z/%p\Z.
Then we can compute the roots using the following formula:
\begin{eqnarray}
 %x \equiv \pm %y<sup>(%p+1)/4</sup> (\mod %p)
\end{eqnarray}
</div>

<div class="mathenv example_to_know">
<b>Example:</b> Suppose we are given an instance of the congruent squares problem where %y = 2 and %n = 15. We want to find %x \in \Z/15\Z
such that %x \not\equiv \pm %y but %x^2 \equiv %y^2 \equiv 2^2 \equiv 4.

Notice that we have that:
\begin{eqnarray}
 %y       & \equiv & 2 \mod 3 \\
 %y^2     & \equiv & 2^2 \mod 3 \\
          & \equiv & 1 \mod 3 \\
 (3-%y)^2 & \equiv & 1^2 \mod 3 \\
          & \equiv & 1 \mod 3
\end{eqnarray}
Notice also that we have that:
\begin{eqnarray}
 %y       & \equiv & 2 \mod 5 \\
 %y^2     & \equiv & 2^2 \mod 5 \\
          & \equiv & 4 \mod 5 \\
 (5-%y)^2 & \equiv & 3^2 \mod 5 \\
          & \equiv & 4 \mod 5
\end{eqnarray}
Thus, the square roots of 4 in \Z/3\Z are 1 and 2, and the square roots of 4 in \Z/5\Z are 2 and 3. We can then apply the Chinese
remainder theorem to every pair of combinations:
\begin{eqnarray}
 %r_1 & \equiv & 1 \mod 3 \\
 %r_1 & \equiv & 2 \mod 5 \\
 <b>%r_1</b> & \equiv & <b>7 \mod 15</b> \\
 %r_2 & \equiv & 2 \mod 3 \\
 %r_2 & \equiv & 2 \mod 5 \\
 <b>%r_2</b> & \equiv & <b>2 \mod 15</b> \\
 %r_3 & \equiv & 1 \mod 3 \\
 %r_3 & \equiv & 3 \mod 5 \\
 <b>%r_3</b> & \equiv & <b>13 \mod 15</b> \\
 %r_4 & \equiv & 2 \mod 3 \\
 %r_4 & \equiv & 3 \mod 5 \\
 <b>%r_4</b> & \equiv & <b>8 \mod 15</b>
\end{eqnarray}

Thus, %x = 8 and %x = 7 are solutions to %x \not\equiv \pm 3 and %x^2 \equiv 4.
</div>

Above, we have shown that several problems are not in P. There is another complexity class to which they definitely belong.

<div class="mathenv fact proposition_to_know">
<b>Definition:</b> A problem %X is in <i>NP</i> iff there exists a polynomial-time algorithm that, when given a problem instance and 
a candidate solution, can always verify whether the candidate solution is indeed a solution.

Another (equivalent) definition: a problem %X is in <i>NP</i> iff a polynomial-time non-deterministic Turing machine can solve every
instance of the problem.
</div>

<div class="mathenv fact proposition_to_know">
<b>Definition:</b> A problem %X is <i>NP-complete</i> iff it is in NP and for every problem in NP there is a polynomial-time reduction to %X.
</div>


<!--
<div class="mathenv fact proposition_to_know">
<b>Definition:</b> A problem %X is <i>NP-hard</i> iff there is a polynomial-time reduction from an NP-complete problem to %X.
</div>

Note that it is equivalent to say that an NP-hard problem is one to which polynomial-time reductions exist from every problem in NP (i.e.,
a problem that satisfies only the second condition of the definition of NP-complete).

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> A problem %X is NP-hard if there exists a polynomial-time reduction to it from another NP-hard problem %Y.

Suppose that %X is not NP-hard but is in NP (or in P). Then there is a polynomial-time reduction from %Y to %X, which means %Y is also in NP (or, respectively, in P).
Since this is a contradiction, it must be that %X is NP-hard.
</div>
-->

<a name="D-H-protocol"></a>
<div class="mathenv example_to_know">
<b>Example (Diffie-Hellman key exchange):</b> We introduce the Diffie-Hellman key exchange protocol. This protocol is useful if two parties who
cannot meet physically want to agree on a secret value that only they know.

<ul>
  <li><b>Public key generation (performed by one party):</b> 
    <ol>
      <li>Randomly choose a <b>public</b> large prime number %p \in \N and an element %g \in \Z/%p\Z.</li>
    </ol>
  </li>
  <li><b>Private key generation (performed by both parties):</b> 
    <ol>
      <li>Party <b>A</b> randomly chooses a secret %a \in \Z/\phi(%p)\Z.</li>
      <li>Party <b>B</b> randomly chooses a secret %b \in \Z/\phi(%p)\Z.</li>
    </ol>
  </li>
  <li><b>Protocol:</b> 
    <ol>
      <li>Party <b>A</b> computes (%g^{%a} \mod %p) and sends this public value to party <b>B</b>.</li>
      <li>Party <b>B</b> computes (%g^{%b} \mod %p) and sends this public value to party <b>A</b>.</li>
      <li>Party <b>A</b> computes (%g^{%b} \mod %p)^{%a} \mod %p.</li>
      <li>Party <b>B</b> computes (%g^{%a} \mod %p)^{%b} \mod %p.</li>
      <li>Since multiplication over \Z/\phi(%p)\Z is commutative, both parties now share a secret %g^{%a \cdot %b} \mod %p.</li>
    </ol>
  </li>
</ul>

This protocol's security only relies on the discrete logarithm assumption.
</div>

It is not known whether the discrete logarithm problem is related to the factoring problem. Factoring <i>can</i> be reduced using a probabilistic
approach to the discrete logarithm problem modulo %p \cdot %q.

<a name="Rabin-cryptosystem"></a>
<div class="mathenv example_to_know">
<b>Example (Rabin cryptosystem):</b> We introduce the Rabin cryptosystem protocol. It is similar to the RSA scheme, but it does
not rely on the difficulty of the RSA problem.

<ul>
  <li><b>Key generation (performed by the receiver):</b> 
    <ol>
      <li>Randomly choose two <b>secret</b> prime numbers %p \in \N and %q \in \N of similar size.</li>
      <li>Compute a <b>public key</b> value %n = %p \cdot %q.</li>
    </ol>
  </li>
  <li><b>Protocol (encryption and decryption):</b> There are two participants: the sender and the receiver. 
    <ol>
      <li>The sender wants to send a <b>message</b> %m \in {0,...,%n-1} to the receiver.</li>
      <li>The receiver reveals the public key %n to the sender.</li>
      <li>The sender computes the <b>ciphertext</b> (encrypted message) %c = %m^2 \mod %n.</li>
      <li>The sender sends %c to the receiver.</li>
      <li>The receiver can recover the original message by computing \sqrt(%c) in \Z/%p\Z and \Z/%q\Z,
          and then finding the four solutions to the following system by using the Chinese remainder theorem:
\begin{eqnarray}
%m & \equiv & \sqrt(%c) \mod %p\\
%m & \equiv & \sqrt(%c) \mod %q.
\end{eqnarray}
      </li>
    </ol>
  </li>
</ul>

Notice that the receiver must guess which of the square roots corresponds to the original message.
</div>

The following diagram summarizes the relationships between the problems that are conjectured to be intractable (i.e., not in P). Each directed edge represents that
there exists a polynomial-time reduction from the source problem to the destination problem. All of the nodes in the graph are conjectured to be not in P.

<img src="images/reductions.png"/>

<a name="lecture13"></a>
<a name="4.2"></a>
<h3>Complexity of algorithms for solving tractable problems</h3>

In this subsection we consider the complexity of efficient algorithms for performing common arithmetic operations. We consider the complexity of
arithmetic operations on each of the following domains:
<ul>
  <li>unbounded positive integers;</li>
  <li>integers modulo 2^{%n};</li>
  <li>integers modulo %k for some %k \in \N.</li>
</ul>
All of our arithmetic algorithms will operate on bit string representations of positive integers. A bit string representation such as
\begin{eqnarray}
 %a_{%n-1}...%a_0
\end{eqnarray}
is defined to represent the integer
\begin{eqnarray}
 2^0 \cdot %a_0 + ... + 2^{%n-1} \cdot %a_{%n-1}
\end{eqnarray}
Since the operations we consider usually take two arguments, we will follow the following conventions:
<ul>
  <li>the first (left-hand side) input is %x, an %n-bit integer;</li>
  <li>the second (right-hand side) input is %y, an %m-bit integer.</li>
</ul>
Thus, %x \leq 2^{%n} - 1 and %y \leq 2^{%m} - 1.

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> There exists an algorithm that can compute the sum of an %n-bit integer %x and an %m-bit integer %y in time O(\max(%n,%m)+1). The size
of the output is O(\max(%n,%m)+1).

<ol style="list-style-type:none;">
 <li><b>addition of unbounded positive integers:</b> %n-bit integer %x, %m-bit integer %y</li>
 <li>
   <ol style="list-style-type:none;">
     <li>%r (a bit vector to store the result)</li>
     <li>%c := 0 (the carry bit)</li>
     <li>for %i from 0 to \max(%n,%m)-1
       <ol style="list-style-type:none;">
         <li>%r[%i] := (%x[%i] <b>xor</b> %y[%i]) <b>xor</b> %c</li>
         <li>%c := (%x[%i] <b>and</b> %y[%i]) <b>or</b> (%x[%i] <b>and</b> %c) <b>or</b> (%y[%i] <b>and</b> %c)</li>
       </ol>
     </li>
     <li>%r[\max(%n,%m)+1] := %c</li>
     <li>return %r</li>
   </ol>
 </li>
</ol>
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> There exists an algorithm that can compute the product of an %n-bit integer %x and an %m-bit integer %y in 
time O(%n \cdot (%\max(%n,%m)+1+%n)) or O(\max(%n,%m)^2). The size of the output is O(%n+%m) (because we do not shift left
for the 2^1 case, the %m-bit integer is shifted left at most %n-1 times, but there may still be a carried bit on the last addition operation
performed).

<ol style="list-style-type:none;">
 <li><b>multiplication of unbounded positive integers:</b> %n-bit integer %x, %m-bit integer %y</li>
 <li>
   <ol style="list-style-type:none;">
     <li>%r (a bit vector to store the result)</li>
     <li>for %i from 0 to %n-1
       <ol style="list-style-type:none;">
         <li>if %x[%i] is 1
           <ol style="list-style-type:none;">
             <li>%r := %r + %y (using unbounded integer addition)</li>
           </ol>
         </li>
         <li>shift the bits of %y left by one bit (i.e., multiply %y by 2)</li>
       </ol>
     </li>
     <li>return %r</li>
   </ol>
 </li>
</ol>
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> There exists an algorithm that can compute the exponentiation %x^{%y} of an %n-bit integer %x and an %m-bit integer %y in 
time O(%n \cdot 2^{%m}). The size of the output is O(%n \cdot 2^{%m}). Notice that this means that for unbounded integer outputs, the algorithm runs
in exponential time.

<ol style="list-style-type:none;">
 <li><b>exponentiation of unbounded positive integers:</b> %n-bit integer %x, %m-bit integer %y</li>
 <li>
   <ol style="list-style-type:none;">
     <li>%r (a bit vector to store the result)</li>
     <li>for %i from 0 to %m-1
       <ol style="list-style-type:none;">
         <li>if %y[%i] is 1
           <ol style="list-style-type:none;">
             <li>%r := %r \cdot %x (using unbounded integer multiplication)</li>
           </ol>
         </li>
         <li>%x := %x \cdot %x (using unbounded integer multiplication)</li>
       </ol>
     </li>
     <li>return %r</li>
   </ol>
 </li>
</ol>
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> There exists an algorithm that can compute the integer quotient \lfloor %x / %y \rfloor
of an %n-bit integer %x and an %m-bit integer %y in 
time O((%n \cdot %n) + (%n \cdot (2 \cdot %n))) or O(%n^2).

<ol style="list-style-type:none;">
 <li><b>integer division of unbounded positive integers:</b> %n-bit integer %x, %m-bit integer %y</li>
 <li>
   <ol style="list-style-type:none;">
     <li>if %y > %x
       <ol style="list-style-type:none;">
         <li>return 0</li>
       </ol>
     </li>
     <li>for %i from 0 to %n-1
       <ol style="list-style-type:none;">
         <li>shift %y left by one bit</li>
       </ol>
     </li>
     <li>%r (a bit vector to store \lfloor %x / %y \rfloor \cdot %y)</li>
     <li>%q (a bit vector to store the integer quotient)</li>
     <li>%p := 2^{%n-1} (to keep track of the current power of 2)</li>
     <li>for %i from 0 to %n-1
       <ol style="list-style-type:none;">
         <li>if %r+%y < %x
           <ol style="list-style-type:none;">
             <li>%r := %r+%y (using unbounded integer addition)</li>
             <li>%q := %q+%p (using unbounded integer addition)</li>
           </ol>
         </li>
         <li>shift %y right by one bit</li>
         <li>shift %p right by one bit</li>
       </ol>
     </li>
     <li>return %q</li>
   </ol>
 </li>
</ol>
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> There exists an algorithm that can compute %x \mod %y of an %n-bit integer %x and an %m-bit integer %y in 
time O(%n^2).

This is accomplished by first performing integer division, then an integer multiplication, and then a subtraction. This corresponds
to the formula for the modulus operation:
\begin{eqnarray}
%x \mod %y & = & %x - \lfloor %x/%y \rfloor \cdot %y
\end{eqnarray}
</div>

When we consider the operations above as operating on integers modulo 2^{%n} (with results also in 2^{%n}, this corresponds to simply
dropping any bits beyond the %n least-significant bits when performing the computation.

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> There exists an algorithm that can compute the sum of two %n-bit integers %x and %y in time O(%n). The size
of the output is O(%n).

<ol style="list-style-type:none;">
 <li><b>addition of %n-bit integers:</b> %n-bit integers %x, %y</li>
 <li>
   <ol style="list-style-type:none;">
     <li>%r (an %n-bit vector to store the result)</li>
     <li>%c := 0 (the carry bit)</li>
     <li>for %i from 0 to %n-1
       <ol style="list-style-type:none;">
         <li>%r[%i] := (%x[%i] <b>xor</b> %y[%i]) <b>xor</b> %c</li>
         <li>%c := (%x[%i] <b>and</b> %y[%i]) <b>or</b> (%x[%i] <b>and</b> %c) <b>or</b> (%y[%i] <b>and</b> %c)</li>
       </ol>
     </li>
     <li>return %r</li>
   </ol>
 </li>
</ol>
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> There exists an algorithm that can compute the product of two %n-bit integers %x and %y in time O(%n^2). The size
of the output is O(%n).
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> There exists an algorithm that can compute %x^{%y} for two %n-bit integers %x and %y in time O(%n^3). The size
of the output is O(%n).
</div>

<!--
We begin by considering arithmetic operations in \Z/2^{%n}\Z. Notice that this is semantically
equivalent to performing arithmetic on bit representations and keeping only the %n least significant bits. 

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> There exists an algorithm that can add two %n-bit integers in \Z/(2^{%n})\Z in time O(%n).
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> There exists an algorithm that can multiply two %n-bit integers in \Z/(2^{%n})\Z in time O(%n^2).
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> There exists an algorithm that can compute %x^{%y} for two %n-bit integers %x and %y in \Z/(2^{%n})\Z  in time O(%n^3).
</div>

Notice that, in general, if the output to an exponentiation procedure 
is not bounded (i.e., we multiply in \Z rather than in \Z/(2^{%n})\Z), the output may be
exponentially larger than the input, and so the output size may be exponentially larger than the input size. That is:
\begin{eqnarray}
 %y & \mapsto & 2^{%y} \\
 \log(%y) & \mapsto & \log(2^{%y}) \\
\end{eqnarray}
And we know that the representation size %y is exponentially larger than the representation size \log(%y):
\begin{eqnarray}
 %y & = & 2^{\log(%y)}
\end{eqnarray}

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> There exists an algorithm that can compute %x \mod %y for two %n-bit integers %x and %y in \Z/(2^{%n})\Z  in time O(%n^3).
</div>

-->




















<div class="mathenv fact proposition_to_know">
<b>Fact:</b> The recursive algorithm for \gcd (and the extended Euclidean algorithm) makes O(\log (\max(%x,%y))) recursive calls on an integer 
inputs %x \in \N and %y \in \N. Notice that this means that the number of recursive calls is <i>linear</i>, or O(\max(%n,%m)), for inputs 
consisting of an %n-bit integer %x and an %m-bit integer %y.
</div>

To see the above, consider the following fact: for any %a \in \N, %b \in \N, if %b \leq %a then %a \mod %b < (1/2) \cdot %a. Consider the two
possibilities for %a and %b:
<ul>
  <li>if %b \leq (1/2) \cdot %a, then \lfloor %a / %b \rfloor > 1, so:
\begin{eqnarray}
 (%a \mod %b) & < & %b & \leq & (1/2) \cdot %a
\end{eqnarray}
  </li>
  <li>if %b > (1/2) \cdot %a, then \lfloor %a / %b \rfloor = 1, so:
\begin{eqnarray}
 %a \mod %b & = & %a - \lfloor %a/%b \rfloor \cdot %b \\
            & = & %a - 1 \cdot %b \\
            & = & %a - %b \\
            & < & %a - ((1/2) \cdot %a) \\
            & < & (1/2) \cdot %a
\end{eqnarray}
  </li>
</ul>
Thus, every time %a \mod %b is computed in the algorithms, size of the second paramter is halved.
Since every other invocation switches the two parameters, both parameters are halved. Thus, the number of
invocations or iterations for an input %m is \log(%m).

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> The recursive algorithm for the <a href="#algorithm-extended-euclidean">extended Euclidean algorithm</a> on inputs consisting 
of an %n-bit integer %x and an %m-bit integer %y
runs in time O(\max(%n,%m) \cdot (2 \cdot \max(%n,%m)^2 + \max(%n,%m))), or O(\max(%n,%m)^3).

The number of recursive calls is about \max(%n,%m), and each recursive call involves an integer division, a multiplication, and a subtraction.
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> The following problem can be solved in polynomial time: given %x \in (\Z/%n\Z)*, compute %x^{-1}.

This can be reduced to running the extended Euclidean algorithm, which has a polynomial running time.
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> There exists an O(\max(%n,%m)^3 + (%n+%m)^2) algorithm that can solve the following system of two equations 
(for %n-bit integers %x,%x' and %m-bit integers %y,%y') using the Chinese remainder theorem:
\begin{eqnarray}
  %s & \equiv & %x' (\mod %x) \\
  %s & \equiv & %y' (\mod %y)
\end{eqnarray}
This algorithm calls the <a href="#algorithm-extended-euclidean">extended Euclidean algorithm</a> on %x and %y, and then performs 
four multiplications modulo (%x \cdot %y).
</div>

<div class="mathenv example_to_know">
<b>Example:</b> Suppose we have a set of distinct prime numbers {%p_1,...%p_{%j}} such that each prime has an %n-bit representation.
Let %P be the product of these primes. We must perform the following number of operations modulo %P:
<ol>
  <li>%k multiplications;</li>
  <li>%k exponentiations.</li>
</ol>
For each of the above, how large must %k be in order for us to choose to employ the Chinese remainder theorem instead of simply
performing the operations modulo %P directly using
the multiplication or exponentiation algorithms?

<ol>
  <li>Since the representation size of %P is %j \cdot %n bits, the multiplication operation modulo %P has a running time of O((%j \cdot %n)^2). 
      Multiplication operations modulo any of the
      primes %p_{%i} \in {%p_1,...%p_{%j}} have a running time of O(%n^2). Thus, the crossover point is the solution for %k given the following equation:
\begin{eqnarray}
  %k \cdot (%j \cdot %n)^2 & = & %k \cdot %j \cdot (%n^2) + (%j \cdot (%j \cdot %n)^3)
\end{eqnarray}
  </li>
</ol>
</div>

<!--assignment4-->
<br/><hr/>
<a name="4.3"></a>
<a name="assignment4"></a>
<b>Assignment #4: Reductions, Quadratic Residues, and Review</b>
<!--span class="btn_assignment">(<a href="materials.php?hw=4">show only this assignment</a>)</span-->

  <p>For this assignment, you will submit a single Python source file <code>a4.py</code>. You
  may include answers to the written problems inside a comment block at the beginning of the
  file (e.g., using <code>''' This is a comment. '''</code>).

  <b style="color:firebrick;">For the written problems #1-5, you may <span style="text-decoration:underline;">NOT</span>
  use a programming language or calculator, and you 
  must show your work. When making a claim in an argument, you should reference the fact you are applying.</b>

  <b style="color:firebrick;">For the programming problems #6-7, your file may not import any modules or 
  employ any external library functions associated with
  integers and sets (unless the problem statement explicitly permits this). 
  You will be graded on the correctness, concision, and mathematical legibility of your code.
  You may reuse functions that you defined on previous assignments.</b>

<ol>
  <li>
    <ol style="list-style-type:lower-alpha; margin-top:6px;">
      <li style="padding-bottom:12px;"> Suppose the following set %S and relation %R on %S are defined:
\begin{eqnarray}
 %S & = & {0,1,2,3,4,5,6,7} \\
 %R & = & {(0,0),(1,1),(1,7),(7,1),(2,2),(2,4),(4,2),(3,3),(4,3),(3,4),(2,3),(3,2),(4,4),(5,5),(6,6),(7,7)}
\end{eqnarray}
Define explicitly the quotient set %S/%R.
        <solution>
          Since %R is reflexive, symmetric, and transitive, it is an equivalence relation. Thus, we can
          divide %S into a collection of subsets of %S so that the members of each subset of mutually equivalent
          according to %R.
          <br/><br/>
          Thus, we have %S/%R = {{0}, {1, 7}, {2, 3, 4}, {5}, {6}}.
        </solution>
      </li>
      <li style="padding-bottom:12px;">
Let %n \in \N and %a \in \Z/%n\Z. Suppose that gcd(%a,%n) = 1. Determine the exact size of the following set:
\begin{eqnarray}
 { %a \cdot %i \mod %n | %i \in {0,...,%n-1} }
\end{eqnarray}
        <solution>
          We know that the above set is a permutation of {0,...,%n-1}, so the size is %n.
        </solution>
      </li>
      <li style="padding-bottom:12px;">
Let %n \in \N and %a \in \Z/%n\Z. Suppose that gcd(%a,%n) = 1. Determine the exact size of the following set:
\begin{eqnarray}
 { %i \cdot (%a^{\phi(%n)}) \mod %n | %i \in {0,...,%n-1} }
\end{eqnarray}
        <solution>
          We know by <a href="euler-theorem">Euler's theorem</a> that %a^{\phi(%n)} \mod %n = 1 since %a and %n are coprime.
          Thus, the size of the set is %n, since this is exactly the set {0,...,%n-1}.
        </solution>
      </li>
      <li style="padding-bottom:12px;">
Let %p \in \N be a prime number. Determine the exact size of the following set:
\begin{eqnarray}
 { %a^{\phi(%p)} \mod %p | %a \in {1,...,%p-1} }
\end{eqnarray}
        <solution>
          We know by <a href="euler-theorem">Euler's theorem</a> that %a^{\phi(%p)} \mod %p = 1 if %a and %p are coprime.
          Thus, the size of the set is 1.
        </solution>
      </li>
    </ol>
  </li>

  <li> Find the multiplicative inverse of each of the following if it exists, or explain why it does not exist (the
       solution may be a formula in terms of the variables in the expression).
    <ol style="list-style-type:lower-alpha; margin-top:6px;">
      <li style="padding-bottom:12px;">2 \in \Z/5\Z</li>
      <li style="padding-bottom:12px;">3 \in \Z/10\Z</li>
      <li style="padding-bottom:12px;">5 \in \Z/21\Z</li>
      <li style="padding-bottom:12px;">(2 \cdot 3) \in \Z/11\Z</li>
      <li style="padding-bottom:12px;">6 \in \Z/7\Z</li>
      <li style="padding-bottom:12px;">(3 \cdot %b) \in \Z/(%a \cdot %b)\Z</li>
      <li style="padding-bottom:12px;">%a \in \Z/(%a+1)\Z</li>
      <li style="padding-bottom:12px;">(%a \cdot %b) \in \Z/((%a \cdot %b)-1)\Z</li>
    </ol>
    <solution>
    <ol style="list-style-type:lower-alpha; margin-top:6px;">
      <li style="padding-bottom:12px;">2^{\phi(5)-1} \mod 5 &nbsp;&nbsp;=&nbsp;&nbsp; 2^3 \mod 5 &nbsp;&nbsp;=&nbsp;&nbsp; 8 \mod 5 = 3</li>
      <li style="padding-bottom:12px;">
        3^{\phi(10)-1} \mod 10 &nbsp;&nbsp;=&nbsp;&nbsp; 3^{((5-1) \cdot (2-1)) - 1} \mod 10 &nbsp;&nbsp;=&nbsp;&nbsp; 3^3 \mod 10 = 7
      </li>
      <li style="padding-bottom:12px;">
Using the formula for inverses in terms of \phi:
\begin{eqnarray}
 5^{\phi(21)-1} \mod 21 & = & 5^{((7-1) \cdot (3-1)) - 1} \mod 21 \\
                        & = & 5^{11} \mod 21 \\
                        & = & 5 \cdot (5^2)^5 \mod 21 \\
                        & = & 5 \cdot (4)^5 \mod 21 \\
                        & = & 5 \cdot 4 \cdot (2^2)^4 \mod 21 \\
                        & = & 20 \cdot (2^8) \mod 21 \\
                        & = & 20 \cdot 256 \mod 21 \\
                        & = & 20 \cdot 4 \mod 21 \\
                        & = & 80 \mod 21 \\
                        & = & 17 \mod 21
\end{eqnarray}
      </li>
      <li style="padding-bottom:12px;">
For purposes of illustration, we solve this by finding the inverses of
the components, then multiplying:
\begin{eqnarray}
 2 \cdot 6 & \equiv & 12 & \equiv & 1 \mod 11 \\
 3 \cdot 4 & \equiv & 12 & \equiv & 1 \mod 11 \\
\end{eqnarray}
\begin{eqnarray}
 (2 \cdot 3)^{-1} & \equiv & 6 \cdot 4 \\
                  & \equiv & 24 \\
                  & \equiv & 2 (\mod 11) \\
\end{eqnarray}
      </li>
      <li style="padding-bottom:12px;">6 \in \Z/7\Z, since 6 \cdot 6 = 36 \equiv 1 (\mod 7)</li>
      <li style="padding-bottom:12px;">
        If %b > 1, then there is no inverse, since \gcd(3 \cdot %b, %a \cdot %b) \geq %b.
        If %b = 1, then the inverse is (3 \cdot %b)^{\phi(%a \cdot %b)-1} \mod (%a \cdot %b).
        Either or both of these answers are acceptable.
      </li>
      <li style="padding-bottom:12px;">
        We know that \gcd(%a, %a+1) = 1. Thus, we can find %s and %t that satisfy <a href="#bezout-identity">B&eacute;zout's identity</a>:
\begin{eqnarray}
 %s \cdot %a + %t \cdot (%a + 1) & = & \gcd(%a, %a+1) \\
 (-1) \cdot %a + (1) \cdot (%a + 1) & = & 1 \\
 %s & = & -1 \\
 %t& = & 1
\end{eqnarray}
        But (%s,%t) is the output of the <a href="#algorithm-extended-euclidean">extended Euclidean algorithm</a>, and if
        the greatest common divisor is 1, then %s is
        the multiplicative inverse of the first argument modulo the second argument,
        which is %a in this case. Thus, -1 \in \Z/(%a+1)\Z, or (%a+1)-1 = %a, is the multiplicative inverse
        of %a in \Z/(%a+1)\Z.
        Alternatively, %a^{-1} \equiv %a^{\phi(%a+1)-1} \mod (%a+1).
        Either or both of these answers are acceptable.
      </li>
      <li style="padding-bottom:12px;">
        We know that (%a \cdot %b) \equiv 1 (\mod ((%a \cdot %b) - 1)). Thus, the inverse is
        1 \in \Z/((%a \cdot %b) - 1)\Z.
      </li>
    </ol>
    </solution>
  </li>

  <li> Compute each of the following.
    <ol style="list-style-type:lower-alpha; margin-top:6px;">
      <li style="padding-bottom:12px;">11<sup>1025</sup> \mod 17
        <solution>
      Since 11 and 17 are coprime, we have that 11<sup>1025</sup> \equiv 11<sup>1025 \mod \phi(17)</sup>.
      Then, we have that:
\begin{eqnarray}
               1025 \mod \phi(17) & \equiv & 1025 (\mod 16) \\
                                  & \equiv & (2^{10} + 1) (\mod 2^4) \\
                                  & \equiv & 1 (\mod 2^4) \\
                11<sup>1025</sup> & \equiv & 11^1 (\mod 17) \\
                                  & \equiv & 11 (\mod 17)
\end{eqnarray}
        </solution>
      </li>
      <li style="padding-bottom:12px;">2<sup>(2<sup>100000001</sup>)</sup> \mod 7
        <solution>
        Since \gcd(2,7) = 1, we can compute 2<sup>100000001</sup> \mod \phi(7) to 
        make the exponent more manageable. We know that the powers of 2 modulo 6 are
        2,4,2,4,2,4,2,4,... Thus, since 100000001 is odd, we have:
\begin{eqnarray}
               2<sup>100000001</sup> & \equiv & 2^1 (\mod 6) \\
 2<sup>(2<sup>100000001</sup>)</sup> & \equiv & 2<sup>(2^1)</sup> (\mod 7) \\
                                     & \equiv & 4 (\mod 7)
\end{eqnarray}
        </solution>
      </li>
      <li style="padding-bottom:12px;">{ %x | %x \in \Z/17\Z, %x^2 \equiv 16 \mod 17 }
        <solution>
        Since 17 is prime, we know there are at most two solutions. Since 16 < 17, we
        know that they are 4 and -4 = 17-4 = 13. Thus, this set is {4, 13}.
        </solution>
      </li>
      <li style="padding-bottom:12px;">{ %x | %x \in \Z/10\Z, %x^2 \equiv 9 \mod 10 }
        <solution>
        The two obvious solutions to the equation %x^2 \equiv 9 (\mod 10) are 3 and -3 = 10-3 = 7. 
        However, there may be as many as four solutions since 10 = 2 \cdot 5.
        <br/><br/>
        In \Z/2\Z, 9 \equiv 1. The two solutions in \Z/2\Z are thus 1 and -1. However, since
        -1 = 2-1 = 1, there is only one solution in \Z/2\Z.
        <br/><br/>
        In \Z/5\Z, 9 \equiv 4, and the two solutions are 2 and -2 = 5-2 = 3. Thus, there are two
        distinct systems of equations that can be set up, so there are two distinct solutions %x_1 and %x_2:
\begin{eqnarray}
 %x_1 & \equiv & 1 (\mod 2) \\
 %x_1 & \equiv & 2 (\mod 5)
\end{eqnarray}
\begin{eqnarray}
 %x_2 & \equiv & 1 (\mod 2) \\
 %x_2 & \equiv & 3 (\mod 5)
\end{eqnarray}
        The two solutions are still 3 and 7. Thus, the set is {3,7}.
        </solution>
      </li>
      <li style="padding-bottom:12px;">|{ %x | %x^2 \equiv 4 \mod (7 \cdot 23 \cdot 31 \cdot 59) }|
        <solution>
        We know that 2 and -2 are solutions to %x^2 \equiv 4 in \Z/7\Z, \Z/23\Z, \Z/31\Z, and \Z/59\Z
        because these moduli are greater than 4.
        Thus, there are 2^4 possible distinct systems of equations for which we can use CRT to find solutions.
        Thus, there are 2^4 = 16 solutions, so the size of this set is 16.
        </solution>
      </li>
      <li style="padding-bottom:12px;">(\Z/6\Z)*
        <solution>
       Using the definition, we have that:
\begin{eqnarray}
 (\Z/6\Z)* & = & {%x | %x \in \Z/6\Z, %x^{-1} \in \Z/6\Z} \\
           & = & {%x | %x \in \Z/6\Z, \gcd(%x,6) = 1} \\
           & = & {1, 5}
\end{eqnarray}
        </solution>
      </li>
    </ol>
  </li>

  <li> At some point in the past, Alice used Bob's public RSA key (%n,%e) to send him several encrypted messages. 
       Bob stored the encrypted versions of these messages without decrypting them. Some time later,
       Bob decides to read the messages. However, he discovers he has misplaced his public key (%n,%e), his private key %d,
       and one of his primes %p; he only knows %q and \phi(%n) (he cannot ask anyone else for the lost information).
       Can Bob find a way to recover some or all of the lost information and read
       Alice's old messages? Explain in detail.
       <solution>
       Bob can use %q and \phi(%n) to recover %p, since:
\begin{eqnarray}
 \phi(%n) & = & (%p-1) \cdot (%q-1) \\
       %p & = & (\phi(%n)/(%q-1)) + 1
\end{eqnarray}
       However, %e was chosen at random from (\Z/\phi(%n)\Z)^\ast, and %p and %q do not help in reproducing it.
       Thus, even though Bob could compute %d for a given %e, %e cannot be recovered, so Bob cannot recover the lost
       information.
       </solution>
  </li>

  <li> Suppose that an efficient algorithm has been discovered for computing discrete logarithms modulo primes. That is,
       given some value %g^{%a} \mod %p, it is now possible to efficiently compute %a if %g is known 
       <b style="color:firebrick;">(i.e., \log_{%g} (%g^{%a}) \equiv %a)</b>.
       Assuming that no other discoveries have been made, explain how Alice and Bob can <b style="color:firebrick;">(possibly 
       using some other method, not necessarily D-H)</b> still securely agree on a shared secret integer %s \in \Z
       without meeting in person. You must explain why this <b style="color:firebrick;">alternate</b> method is still secure 
       despite the new discovery.
       
       <solution>
       Because none of the other problems we considered (factoring, computing \phi, congruent squares, and the RSA problem)
       have any known polynomial-time reductions to the discrete logarithm problem, the existence of an efficient algorithm for computing
       discrete logarithms does not imply an efficient solution for any of the other problems. Thus, it is no more risky than before
       to assume that cryptographic protocols such as RSA are secure.
       <br/><br/>
       Bob and Alice could use the RSA 
       or Rabin cryptographic protocol. For example, Alice chooses a secret, and Bob generates a public RSA key.
       Alice then encrypts and sends the secret value to Bob. Bob decrypts that secret value. At this point, Alice and Bob share a secret
       that no one else knows (assuming RSA is secure).</solution>
  </li>

  <li>
    Consider the following problem (call it "<i><b>\phi-four</b></i>"):
    <b>"given an integer %n that is the product of four distinct primes, find \phi(%n)."</b> Notice that
    the four distinct primes <i>are not known</i> in the specification of the problem. It is only known that %n is the product
    of some four distinct primes.
  
    <ol style="list-style-type:lower-alpha; margin-top:6px;">
      <li style="margin-bottom:10px;">
           Given our assumptions about the intractability of various problems (i.e., that certain problems are not in P), you must show
           that \phi-four is also not in P. To do so, you must implement a solver for some existing intractable problem that
           uses a solver for \phi-four (call it <code>phi_four()</code>) as a subroutine. The algorithm you implement must represent
           a polynomial-time reduction to \phi-four from the intractable problem you choose.
           <b>Note: remember that the four primes must be distinct; your reduction must work for <i>all</i> possible instances of the
           intractable problem.</b>
      </li>
      <li style="margin-bottom:10px;">
           Suppose that we discover an efficient algorithm <code>getFactor()</code> that takes a single integer input and
           returns exactly one <b style="color:firebrick;">prime</b> factor of its input.
           Implement a Python function that solves \phi-four efficiently by calling <code>getFactor()</code> as a subroutine.
      </li>
      <!--<li style="margin-bottom:10px;">
           <b style="color:firebrick;">Suppose that we discover an efficient algorithm <code>getFactor()</code> that takes a single integer input and
           returns exactly one prime factor of its input.
           Implement a Python function that solves \phi-four efficiently by calling <code>getFactor()</code> as a subroutine.</b>
      </li>-->
    </ol>
  </li>

  <li> Implement a Python function <code>roots()</code> that takes two arguments: an integer %y as its first argument, and a list of primes
       as its second argument. You may assume that all the primes %p are such that %p \equiv 3 \mod 4. Let %P be the product of all the primes
       in the list. The function should return a set of all the distinct square roots of %y^2 in \Z/%P\Z.
       <b>Your implementation must be efficient (i.e., it may not iterate over all possible values in \Z/%P\Z to look for square roots).</b>

  </li>
</ol>
<hr/><br/>
<!--/assignment4-->


<a name="lecture14"></a>
<a name="5"></a>
<!--<hr style="margin-bottom:80px;"/>-->
<h2>Review #1</h2>

This section contains a comprehensive collection of review problems going over the course material covered until this point. These problems are an
accurate representation of the kinds of problems you may see on an exam.

<div class="mathenv">
<b>Problem:</b> It is the case that 2 \cdot 3 + (-1) \cdot 5 = 1. Solve the following system of equations:
\begin{eqnarray}
  %x & \equiv & 2 (\mod 3)\\
  %x & \equiv & 3 (\mod 5)
\end{eqnarray}

<solution>
Given %u = 2, %m = 3, %a = 2, %v = -1, %n = 5, and %b = 3, the formula for the solution is:
\begin{eqnarray}
  %x & \equiv & (%u \cdot %m \cdot %b + %v \cdot %n \cdot %a) \mod (%m \cdot %n) \\
     & \equiv & (2 \cdot 3 \cdot 3 + (-1) \cdot 5 \cdot 2) \mod (3 \cdot 5) \\
     & \equiv & (18 - 10) \mod 15 \\
     & \equiv & 8 \mod 15 \\
\end{eqnarray}
</solution>
</div>

<div class="mathenv">
<b>Problem:</b> Solve the following system of equations:
\begin{eqnarray}
  %x & \equiv & 2 (\mod 7)\\
  %x & \equiv & 3 (\mod 5)
\end{eqnarray}

<solution>
We can list the positive members of the equivalence classes 2 \in \Z/7\Z and 3 \in \Z/5\Z that are less than 35.
The one element that appears in both lists is the solution in \Z/35\Z to the above system.
\begin{eqnarray}
  2 + 7\Z & = & {..., 2, 9, 16, <b style="color:firebrick;">23</b>, 30, ...} \\
  3 + 5\Z & = & {..., 3, 8, 13, 18, <b style="color:firebrick;">23</b>, 28, 33, ...}
\end{eqnarray}
</solution>
</div>

<div class="mathenv">
<b>Problem:</b> Determine the size of the following set:
\begin{eqnarray}
  {%x | %x \in \Z/(11 \cdot 13)\Z, %x \equiv 5 \mod 11, %x \equiv 7 \mod 13}
\end{eqnarray}

<solution>
By the Chinese remainder theorem, we know there exists exactly one solution in \Z/(11 \cdot 13)\Z to the following system of equations:
\begin{eqnarray}
  %x & \equiv & 5 (\mod 11)\\
  %x & \equiv & 7 (\mod 13)
\end{eqnarray}
Thus, the size of the set is 1.
</solution>
</div>

<div class="mathenv">
<b>Problem:</b> Determine the size of the following set:
\begin{eqnarray}
  {%x | %x \in \Z/(11 \cdot 13)\Z, %s \in \Z/11\Z, %t \in \Z/13\Z, %x \equiv %s \mod 11, %x \equiv %t \mod 13 }
\end{eqnarray}

<solution>
Consider the following set. Notice that the right-hand side of the comprehension is exactly the same as that of the above.
The only difference is that the left-hand side %x in the above expression has been replaced with (%x, %s, %t).
\begin{eqnarray}
  {(%x, %s, %t) | %x \in \Z/(11 \cdot 13)\Z, %s \in \Z/11\Z, %t \in \Z/13\Z, %x \equiv %s \mod 11, %x \equiv %t \mod 13 }
\end{eqnarray}
By the Chinese remainder theorem, we know that exactly one tuple (%x, %s, %t) for each %x \in \Z/(11 \cdot 13)\Z will satisfy
the conditions in the comprehension,
because for each distinct pair (%s, %t), exactly one %x \in \Z/(11 \cdot 13)\Z will be a solution to the system of equations:
\begin{eqnarray}
  %x & \equiv & %s (\mod 11)\\
  %x & \equiv & %t (\mod 13)
\end{eqnarray}
Thus, the conditions in the comprehension will be satisfied at least once for every %x \in \Z/(11 \cdot 13)\Z. Thus, the entire
set is exactly the set \Z/(11 \cdot 13)\Z, and it is the case that
\begin{eqnarray}
  |\Z/(11 \cdot 13)\Z| & = & 11 \cdot 13 & = & 143
\end{eqnarray}
</solution>
</div>

<div class="mathenv">
<b>Problem:</b>Suppose that %n \in \N is even <b style="color:firebrick;">and %n/2 - 1 is odd</b>. Determine the size of the following set:
\begin{eqnarray}
  {%i \cdot (%n/2 - 1) \mod %n | %i \in {0,...,%n-1} }
\end{eqnarray}

<solution>
We know that \gcd(%n/2 - 1, %n/2) = 1. Since %n/2 - 1 is odd, 2 is not a factor of %n/2 - 1, so \gcd(%n/2 - 1, %n) = 1.
Thus, %n/2 - 1 and %n are coprime. Thus, the above set <a href="#coprime-multiples-permutation">must be a permutation</a>.
</solution>
</div>

<div class="mathenv">
<b>Problem:</b> For any <b style="color:firebrick; text-decoration:line-through;">prime</b> %n \in \N, let %a \in \Z/%n\Z have an inverse %a^{-1} \in \Z/%n\Z.
Determine the size of the following set:
\begin{eqnarray}
  { (%a \cdot %i) \mod %n | %i \in \Z/%n\Z }
\end{eqnarray}

<solution>
If %a has an inverse in \Z/%n\Z (whether or not %n is prime), then \gcd(%a, %n) = 1, so 
the above set <a href="#coprime-multiples-permutation">must be a permutation</a>.
</solution>
</div>

<div class="mathenv">
<b>Problem:</b> Solve the following system of equations for %x \in \Z/21\Z (find all solutions):
\begin{eqnarray}
  %x^2 & \equiv & 1 (\mod 3)\\
  %x^2 & \equiv & 1 (\mod 7)
\end{eqnarray}

<solution>
We know that there is exactly one solution %y \in \Z/21\Z to the following system:
\begin{eqnarray}
  %y & \equiv & 1 (\mod 3)\\
  %y & \equiv & 1 (\mod 7)
\end{eqnarray}
The solution is simply %y = 1, and since there is only one solution, this is the only possibility.
Thus, we are looking for all the solutions to the following equation:
\begin{eqnarray}
  %x^2 & \equiv & 1 (\mod 21)
\end{eqnarray}
Since 3 \mod 4 = 7 \mod 4 = 3, we know that there are two solutions to each of the following equations:
\begin{eqnarray}
  %x^2 & \equiv & 1 (\mod 3)\\
  %x^2 & \equiv & 1 (\mod 7)
\end{eqnarray}
The solutions are as follows:
\begin{eqnarray}
  %x & \equiv & 1 (\mod 3)\\
  %x & \equiv & 2 (\mod 3)\\
  %x & \equiv & 1 (\mod 7)\\
  %x & \equiv & 6 (\mod 7)
\end{eqnarray}
Taking every pair of combinations with one solution from \Z/3\Z and one solution from \Z/7\Z, we get:
\begin{eqnarray}
  %x_1 & \equiv & 1 (\mod 3)\\
  %x_1 & \equiv & 1 (\mod 7)\\
  %x_1 & \equiv & 1 (\mod 21)\\
  %x_2 & \equiv & 2 (\mod 3)\\
  %x_2 & \equiv & 1 (\mod 7)\\
  %x_2 & \equiv & 8 (\mod 21)\\
  %x_3 & \equiv & 1 (\mod 3)\\
  %x_3 & \equiv & 6 (\mod 7)\\
  %x_3 & \equiv & 13 (\mod 21)\\
  %x_4 & \equiv & 2 (\mod 3)\\
  %x_4 & \equiv & 6 (\mod 7)\\
  %x_4 & \equiv & 20 (\mod 21)
\end{eqnarray}
</solution>
</div>

<div class="mathenv">
<b>Problem:</b> How many solutions %x \in \Z/(33 \cdot 35)\Z does the following system of equations have:
\begin{eqnarray}
  %x^2 & \equiv & 4 (\mod 33)\\
  %x^2 & \equiv & 4 (\mod 35)
\end{eqnarray}

<solution>
We know that each of the following equations have two solutions (2 and -2 in the respective sets). Notice that 4 \mod 3 = 1.
\begin{eqnarray}
  %x^2 & \equiv & 1 (\mod 3)\\
  %x^2 & \equiv & 4 (\mod 11)\\
  %x^2 & \equiv & 4 (\mod 5)\\
  %x^2 & \equiv & 4 (\mod 7)
\end{eqnarray}
Thus, there are two possible choices for each of the variables %r_1 \in {-2,2}, %r_2 \in {-2,2}, %r_3 \in {-2,2}, %r_4 \in {-2,2}, so there
are 2 \cdot 2 \cdot 2 \cdot 2 = 2^4 = 16 possible systems of the form:
\begin{eqnarray}
  %x & \equiv & %r_1 (\mod 3)\\
  %x & \equiv & %r_2 (\mod 11)\\
  %x & \equiv & %r_3 (\mod 5)\\
  %x & \equiv & %r_4 (\mod 7)
\end{eqnarray}
Each system has a unique solution because the tuple (%r_1, %r_2, %r_3, %r_4) is unique, so there are 16 solutions for %x in \Z/(33 \cdot 35)\Z.

Alternatively, we could break the problem down into two subproblems. First, we solve the following equation:
\begin{eqnarray}
  %x^2 & \equiv & 4 (\mod 33)
\end{eqnarray}
We obtain four distinct solutions (%r_1, %r_2, %r_3, %r_4) in \Z/33\Z. Next, we solve the following equation:
\begin{eqnarray}
  %x^2 & \equiv & 4 (\mod 35)
\end{eqnarray}
We then have four distinct solutions in (%s_1, %s_2, %s_3, %s_4) \Z/35\Z. Since \gcd(33,35) = 1, we can then take any combination of solutions
%r_{%i} and %s_{%i} and set up the system:
\begin{eqnarray}
  %x & \equiv & %r_{%i} (\mod 33)\\
  %x & \equiv & %s_{%i} (\mod 35)
\end{eqnarray}
There will be exactly one solution to each of the above systems. There are 4^2 = 16 distinct systems, so there will be 16 distinct solutions.
</solution>
</div>

<div class="mathenv">
<b>Problem:</b> For a given %y \in \Z/(%p \cdot %q)\Z where %p and %q are distinct primes,
how many solutions does the following system of equations have:
\begin{eqnarray}
  %x & \equiv & %y^2 (\mod %p)\\
  %x & \equiv & %y^2 (\mod %q)
\end{eqnarray}

<solution>
The value %y^2 \in \Z/(%p \cdot %q)\Z is a constant with respect to %x, so by the Chinese remainder theorem, there
is exactly one solution %x \in \Z/(%p \cdot %q)\Z to the above system.
</solution>
</div>

<div class="mathenv">
<b>Problem:</b> For a given %n \in \Z and %a \in (\Z/n\Z)*, does the following equation have a solution %x \in \Z/%n\Z?
\begin{eqnarray}
  %x^{-1} & \equiv & %a^2 (\mod %n)
\end{eqnarray}

<solution>
Suppose we take the inverse of both sides.
\begin{eqnarray}
  %x^{-1} & \equiv & %a^2 (\mod %n)\\
  (%x^{-1})^{-1} & \equiv & (%a^2)^{-1} (\mod %n) \\
  %x & \equiv & (%a^2)^{-1} (\mod %n)
\end{eqnarray}
Thus, we are searching for the multiplicative inverse of %a^2. Since %a \in \Z/n\Z has a multiplicative inverse %a^{-1} \in \Z/n\Z,
we can multiply (%a^2)^{-1} by %a^{-1} twice to obtain 1 \in \in \Z/n\Z.
\begin{eqnarray}
  (%a^{-1} \cdot %a^{-1}) \cdot (%a^2) & \equiv & (%a^{-1} \cdot %a^{-1}) \cdot (%a \cdot %a)\\
                                       & \equiv & %a^{-1} \cdot (%a^{-1} \cdot %a) \cdot %a\\
                                       & \equiv & %a^{-1} \cdot 1 \cdot %a\\
                                       & \equiv & %a^{-1} \cdot %a\\
                                       & \equiv & 1
\end{eqnarray}
Thus, %a^{-1} \cdot %a^{-1} = (%a^{-1})^2 is the multiplicative inverse of %a^2.
</solution>
</div>

<div class="mathenv">
<b>Problem:</b> For some %a \in \N, suppose that %a^{-1} \in \Z/21\Z and %a^{-1} \in \Z/10\Z (that is, %a has an inverse in \Z/21\Z, and it also has
an inverse in \Z/10\Z). Determine whether or not %a has an inverse in \Z/210\Z. Explain why or why not.

<solution>
If %a has an inverse in \Z/10\Z and \Z/21\Z, then \gcd(%a,10) = 1 and \gcd(%a,21) = 1. Since \gcd(10,21) = 1, %a shares no factors with the product
10 \cdot 21 = 210, so \gcd(%a, 210) = 1. Thus, %a must have a multiplicative inverse in \Z/210\Z.
</solution>
</div>

<div class="mathenv">
<b>Problem:</b> Let %p be a large prime. Compute the set difference \Z/%p\Z - (\Z/%p\Z)*.

<solution>
Since (\Z/%p\Z)* is the set of elements of \Z/%p\Z that have multiplicative inverses, it is the set of elements %a \in \Z/%p\Z such that
\gcd(%a, %p) = 1. However, because %p is prime, all of the elements in \Z/%p\Z except 0 have this property (since \gcd(%p, 0) = %p; recall that
0/%p \in \Z and %p|0). Thus,
\begin{eqnarray}
  \Z/%p\Z - (\Z/%p\Z)* & = & {0}
\end{eqnarray}
</solution>
</div>

<div class="mathenv">
<b>Problem:</b> Suppose Alice and Bob decide to use the RSA protocol so that Alice can send encrypted messages to Bob.

<ol style="list-style-type:lower-alpha;">
  <li>Bob picks two primes %p = 3 and %p = 7. What are Bob's possible choices for the public key %e?
    <solution>
    Bob can choose any element in:
\begin{eqnarray}
    (\Z/\phi(21)\Z)* & = & (\Z/(3-1)\cdot(7-1)\Z)* & = & (\Z/12\Z)*
\end{eqnarray}
    </solution>
  </li>
  <li>Suppose Bob chooses %e = 7. What is Bob's private key %d?
    <solution>
    Since \phi(21) = 12 and (7 \cdot 7) \mod 12 = 49 \mod 12 = 1 \mod 12, we have that:
\begin{eqnarray}
    %d & \equiv & 7^{-1} (\mod 12) \\
       & \equiv & (7 \mod 12)
\end{eqnarray}
    </solution>
  </li>
  <li>If Alice wants to send the message 2, what encrypted message
      should she send?
    <solution>
    In this case, Alice should send 2, because the encrypted form of 2 is 2:
\begin{eqnarray}
    2^{%e} & \equiv & 2^7 (\mod 21) \\
           & \equiv & 128 (\mod 21) \\
           & \equiv & 2 (\mod 21) \\
\end{eqnarray}
    This is one of the situations in which the ciphertext happens to be the same as the message.
    This is why padding is important when implementing RSA for real-world applications.
    </solution>
  </li>
  <li>How can Bob decrypt Alice's message?
    <solution>
\begin{eqnarray}
    2^{%d} & \equiv & 2^7 (\mod 21) \\
           & \equiv & 128 (\mod 21) \\
           & \equiv & 2 (\mod 21) \\
\end{eqnarray}
    </solution>
  </li>
</ol>
</div>

<div class="mathenv">
<b>Problem:</b> Suppose Eve asks Alice for some sensitive information, so Alice requests that they employ the RSA protocol.
However, Eve wants to conserve resources, so she cheats. Eve chooses a large prime %p, picks an %e \in \Z/(%p-1)\Z, and tells
Alice that (%p,%e) is her public key.

<ol style="list-style-type:lower-alpha;">
  <li>Suppose another eavesdropper, Carl, learns that Eve is cheating this way.
      Can he decrypt Alice's messages if he intercepts them in transit?</li>
      <solution>
      Yes. Carl can easily compute %d = %e^{-1} \mod \phi(%p) because he can compute \phi(%p) = %p-1 given the
      public value %p. Given any ciphertext %m^{%e} \mod %p, he can compute (%m^{%e})^{%d} \mod %p = %m
      to decrypt it.
      </solution>
  <li>What can Alice do to check whether Eve is cheating 
      before she transmits any "encrypted" messages to her?
      <solution>
      Alice can use the Fermat primality test to check whether the %n in Eve's public key (%n,%e) is probably prime or composite.
      If the Fermat primality test indicates that %n is composite (i.e., Alice finds a witness %a \in \Z/%n\Z that %n is composite
      because %a^{%n-1} \mod %n \neq 1), Alice can agree to send encrypted messages to Eve.
      </solution>
  </li>
  <li>What can Eve do to keep cheating but make it computationally more difficult for Alice to catch her?
      <solution>
      If Eve tells Alice that she will always use a Carmichael number %n for all her public keys, Alice will have
      a harder time detecting when Eve is cheating (i.e., if Alice is unable to find witnesses, Alice has no way of
      knowing whether this is because Eve is cheating and using a prime, or because Eve is using a Carmichael number for %n).

      However, Alice can adopt a policy that makes it impossible for Eve to cheat if she wants to communicate with Alice. Alice can
      announce that she will only send messages to Eve if Alice is able to quickly find a Fermat witness for %n. If Alice cannot
      find a witness quickly, Alice will request that the receiver generate a new %n and a new public key (%n, %e).

      Assuming Eve does not want to cheat, but wants to communicate with Alice, it is likely that any %n Eve generates will not be
      a Carmichael number, and if so, it is likely that Alice will be able to quickly detect that the %n is composite. Thus, adopting
      such a policy is very unlikely to impair Alice's ability to communicate with an honest receiver.

      Notice that simply encrypting some test messages and then trying to decrypt them in order to detect whether Eve is cheating
      can lead to false positive. As we saw in the previous problem, some ciphertexts may be exactly the same as the message being
      sent (by coincidence).
      </solution>
  </li>
</ol>

</div>

<div class="mathenv">
<b>Problem:</b> In gambling game, you win if you can guess correctly whether a large number %n is prime in under a minute. You are given a
handheld calculator that can only perform addition, subtraction, multiplication, division, exponentiation, and modulus (the calculator can represent
arbitrarily large numbers, and can provides quotients to any precision).
Under what conditions would you have a high chance of winning the game?

<solution>
The possibility that is most favorable is if the number is composite and not a Carmichael number. In that case, at least half of the
numbers in {2,...,%n-1} are Fermat witnesses. If you pick a few random %a \in {2,...,%n-1} and compute %a^{%n-1} \mod %n, it is
likely for at least one %a the result will be greater than 1, which would make %a a witness that %n is composite. You would then be
able to say with certainty that %p is not prime, winning the game.

If %n is a composite Carmichael number, you are unlikely to find any witnesses in only a few tries unless the number has many factors.
Thus, you won't have much more information after a minute of trial-and-error than you did when the number was first revealed to you.
If %n is a prime number, you have no chance of finding any witnesses.
</solution>
</div>

<a name="lecture15"></a>
<a name="6"></a>
<hr style="margin-bottom:80px;"/>
<h2>Algebraic Structures</h2>

In this section we present the definitions for common algebraic structures frequently encountered in computer science. We identify
what properties these structures do and do not share with \Z/%n\Z, and generalize many of the definitions and results we have seen
when studying modular arithmetic to these algebraic structures.

<a name="6.1"></a>
<h3>Algebraic Structures and Axioms</h3>

We define several common algebraic structures. These structures are all sets that are closed under a binary operator. They are
distinguished by what <i>other</i> common axioms the set and operator satisfy.

<a name="definition_closure"></a>
<div class="mathenv fact proposition_to_know">
<b>Definition:</b> Let %S be a set, and let \oplus be a binary operator. Let closure(%S,\oplus) be the closure of %S under \oplus. We can
define this set in the following way:
\begin{eqnarray}
closure(%S, \oplus) & = & { %x_1 \oplus %x_2 | %x_1,%x_2 \in %S } \cup { %x_1 \oplus (%x_2 \oplus %x_3) | %x_1,%x_2,%x_3 \in %S } \cup { (%x_1 \oplus %x_2) \oplus %x_3 | %x_1,%x_2,%x_3 \in %S } \cup ...
\end{eqnarray}
Alternatively, we could define it in the following way using recursion:
\begin{eqnarray}
closure_0(%S, \oplus) & = & %S \\
closure_%n(%S, \oplus) & = & { %x \oplus %y | %x,%y \in (closure_{%n-1}(%S, \oplus) \cup ... \cup closure_0(%S, \oplus)} \\
closure(%S, \oplus) & = & closure_0(%S, \oplus) \cup closure_1(%S, \oplus) \cup closure_2(%S, \oplus) \cup ... \\
\end{eqnarray}
</div>

Notice that if a set %S is finite, there is a natural way to algorithmically
list all elements in closure(%S, \oplus) by starting with the elements in %S and "building up" all
the elements in each of the closure_%i(%S, \oplus) subsets.

<div class="mathenv fact proposition_to_know">
<b>Definition:</b> Let %S be a set, and let \oplus be a binary operator. Let %A be the closure of %S under \oplus. Thus, we have that
\oplus: %A \times %A \rightarrow %A. In this case, we call %A a <i>magma</i> and we call %S the <i>generating set</i> or the <i>set of generators</i>
of %A.

In other words, a set %A is a <i>magma</i> under \oplus if:
<ul>
  <li>%A is closed under \oplus (that is, for all %x \in %A, for all %y \in %A, %x \oplus %y \in %A)</li>
</ul>
</div>

<div class="mathenv fact proposition_to_know">
<b>Definition:</b> A set %A is a <i>semigroup</i> under \oplus if:
<ul>
  <li>%A is closed under \oplus</li>
  <li>\oplus is associative on %A</li>
</ul>
</div>

<div class="mathenv fact proposition_to_know">
<b>Definition:</b> A set %A is a <i>monoid</i> under \oplus if:
<ul>
  <li>%A is closed under \oplus</li>
  <li>\oplus is associative on %A</li>
  <li>\oplus has an identity \1 in %A</li>
</ul>
</div>

<div class="mathenv fact proposition_to_know">
<b>Definition:</b> A set %A is a <i>group</i> under \oplus if:
<ul>
  <li>%A is closed under \oplus</li>
  <li>\oplus is associative on %A</li>
  <li>\oplus has an identity \1 in %A</li>
  <li>%A has inverses with respect to \oplus (for all %x \in %A, there exists %x^{-1} \in %A such that %x \oplus %x^{-1} = \1)</li>
</ul>
</div>

<div class="mathenv fact proposition_to_know">
<b>Definition:</b> A set %A is an <i>abelian group</i> under \oplus if:
<ul>
  <li>%A is closed under \oplus</li>
  <li>\oplus is associative on %A</li>
  <li>\oplus is commutative on %A</li>
  <li>\oplus has an identity \1 in %A</li>
  <li>%A has inverses with respect to \oplus (for all %x \in %A, there exists %x^{-1} \in %A such that %x \oplus %x^{-1} = \1)</li>
</ul>
</div>

Any of the above terms can be prefixed with <i>free</i> to indicate that <i>no other axioms</i> apply.

<div class="mathenv fact proposition_to_know">
<b>Definition:</b> A set %A is a <i>free magma</i> under \oplus if the <b>only</b> axiom that applies to %A and \oplus is:
<ul>
  <li>%A is closed under \oplus (that is, for all %x \in %A, for all %y \in %A, %x \oplus %y \in %A)</li>
</ul>
That is, a free magma's operator \oplus is strictly <b>not</b> associative, cannot have an identity in %A, cannot have inverses, and so on.
</div>

Any of the above terms can be prefixed with <i>finite</i> to indicate that %A is finite. The set of generators of an algebraic
structure may be finite or infinite.

<div class="mathenv fact proposition_to_know">
<b>Definition:</b> A set %A is a <i>finite group</i> under \oplus if %A is a finite set.
</div>

Any of the above terms can be prefixed with <i>commutative</i> to indicate that the operator is commutative over the set.

<div class="mathenv fact proposition_to_know">
<b>Definition:</b> A set %A is a <i>commutative semigroup</i> under \oplus if %A is a semigroup under \oplus and it is also true that:
<ul>
  <li>for all %x \in %A, for all %y \in %A, %x \oplus %y = %y \oplus %x</li>
</ul>
</div>

Typically, we call a commutative group an <i>abelian group</i>.

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> A set %A is an <i>abelian group</i> under \oplus if it is a commutative group under \oplus.
</ul>
</div>

<div class="mathenv example_to_know">
<b>Example:</b> For each of the following algebraic structures, find:
<ol style="list-style-type:lower-alpha;">
  <li>which algebraic structure it is (i.e., which axioms apply and which do not);</li>
  <li>a generating set for the structure;</li>
  <li>whether the algebraic structure is finite.</li>
</ol>
<ol>
  <li>The set of binary trees (i.e., nodes with exactly two children, and leaves at the bottom); \oplus corresponds to 
      joining two trees with a node.</li>
  <li>The set of all strings consisting of the characters <b>a</b>, <b>b</b>, and <b>c</b> 
      (including the empty string), and string concatenation.</li>
  <li>The set of positive integers and integer addition.</li>
  <li>The set of positive integers and integer multiplication.</li>
  <li>The set \Z/%n\Z and addition modulo %n.</li>
  <li>The set \Z/%n\Z and multiplication modulo %n.</li>
  <li>The set (\Z/%n\Z)^\ast and multiplication modulo %n.</li>
  <li>The set \N and the \max operation.</li>
  <li>The set of subsets of {1,2,3} and the set union operation \cup.</li>
  <li>The set of subsets of {1,2,3} and the set intersection operation \cap.</li>
</ol>
</div>

<a name="lecture16"></a>
<a name="6.2"></a>
<h3>Implementations of Algebraic Structures and Operations</h3>

The properties of an algebraic structure (i.e., associativity, identity, commutativity, and so on) influence how we can
store individual elements in these structures, and how we can implement algorithms that perform operations over those elements.

<div class="mathenv example_to_know">
<b>Example:</b> Suppose we have an algebra consisting of the set \N and the binary operator \max. Which algebraic
properties does this algebraic structure satisfy?
<ul>
  <li>%A is closed under \max</li>
  <li>\max is associative on %A</li>
  <li>\max is commutative on %A</li>
</ul>
Notice that there are no identities or inverses. Thus, %A is a commutative semigroup.

Suppose that we have a distributed database (i.e., different parts of the database are on different
computers) containing records that indicate the ages of individual people. 
These age values are represented as elements in \N. How can we compute the age of the oldest individual that has
a record in the database?

Because \max is associative and commutative over %A, each computer can compute \max over the records that are stored on
it. Once each computer has computed its maximum, it can broadcast it to the other computers. One computer can then
be designated to receive these maxima and take their maximum to obtain the final result.
</div>

<div class="mathenv example_to_know">
<b>Example:</b> Consider the following set %A:
\begin{eqnarray}
%A & = & {<b>unknown</b>} \cup {(%a,%n) | %a \in \N, %n \in \N}
\end{eqnarray}
Consider the following definition of a binary operator \oplus over %A: given (%a,%n) and (%b,%m):
<ul>
  <li>if \gcd(%n,%m) = 1, then (%a, %n) \oplus (%b, %m) = (%c, (%n \cdot %m)) where %c is the unique solution
      to the system of equations:
\begin{eqnarray}
%c & \equiv & %a (\mod %n) \\
%c & \equiv & %b (\mod %m)
\end{eqnarray}
  </li>
  <li>if \gcd(%n,%m) \neq 1, then (%a, %n) \oplus (%b, %m) = <b>unknown</b>;</li>
  <li>for any (%a,%n) \in %A, <b>unknown</b> \oplus (%a, %n) = <b>unknown</b>;</li>
  <li>for any (%a,%n) \in %A, (%a, %n) \oplus <b>unknown</b> = <b>unknown</b>.</li>
</ul>
Is %A an algebraic structure? What are its algebraic properties? 
What does this tell us about how we can implement an algorithm that
performs this operation over many elements in %A?
</div>

<div class="mathenv example_to_know">
<b>Example:</b> Suppose a customer wants us to store a very large individual element %x from each of the following sets
in a distributed manner (i.e., we want to store it in parts on multiple computers). 
We assume that the customer does not care if we store an <i>equivalent</i> element.
What additional annotation information will we need in order to reconstruct the element?
What information can we eliminate, thus optimizing our use of storage space?
<ul>
  <li>%x \in %A_1, where %A_1 is a free magma</li>
  <li>%x \in %A_2, where %A_2 is a monoid</li>
  <li>%x \in %A_3, where %A_3 is a group and has an element %y \in %A_3 s.t. %y \oplus %x takes much
       less space to store than %x
  </li>
  <li>%x \in %A_4, where %A_4 is a commutative semigroup</li>
</ul>
</div>

<a name="lecture18"></a>

The following table lists the correspondences between the parts of an algebraic structure and how they might
correspond to a concrete data structure.

<table class="fig_table">
 <tr>
  <td><b>abstract algebraic structure</b></td>
  <td><b>concrete data structure</b></td>
 </tr>
 <tr> 
  <td>element in set of generators %S</td>
  <td>individual character, string, or data object</td>
 </tr>
 <tr> 
  <td>set of generators %S</td>
  <td>base cases; alphabet; data containers</td>
 </tr>
 <tr> 
  <td>operator \oplus</td>
  <td>constructor for node with children; operator/function/method on data items</td>
 </tr>
 <tr> 
  <td>element in closure of %S under \oplus</td>
  <td>individual data object</td>
 </tr>
 <tr> 
  <td>closure of %S under \oplus</td>
  <td>set of all possible data objects</td>
 </tr>
</table>

Suppose a concrete data structure corresponds to an algebraic structure with certain properties.
The following table summarizes how those properties can inform or constrain implementations of algorithms
or applications that operate on the concrete data sttructure.

<table style="font-size:12px;" class="fig_table">
 <tr>
  <td></td>
  <td><b>magma</b></td>
  <td><b>commutative<br/>magma</b></td>
  <td><b>semigroup</b></td>
  <td><b>commutative<br/>semigroup</b></td>
  <td><b>monoid</b></td>
  <td><b>group</b></td>
  <td><b>abelian<br/>group</b></td>
 </tr>
 <tr> 
  <td><b>typical<br/>data<br/>structures</b></td>
  <td>binary trees<br/>under node<br/>constructor</td>
  <td>binary trees<br/>with unordered<br/>branches under<br/>node constructor</td>
  <td>lists with<br/>list concatenation;<br/>strings with<br/>string concatenation</td>
  <td>sets with<br/>duplicates</td>
  <td>lists with<br/>list concatenation<br/>and empty list;<br/>strings with<br/>string concatenation<br/>and empty string</td>
  <td></td>
  <td></td>
 </tr>
 <tr> 
  <td><b>distributed<br/>computation</b></td>
  <td>must operate on<br/>data in its<br/>original<br/>ordering and<br/>hierarchization</td>
  <td>must operate on<br/>data in its<br/>original<br/>hierarchization</td>
  <td>must operate over<br/>original ordering</td>
  <td>can operate on<br/>data in any<br/>order</td>
  <td>can employ identity<br/>as a base case;<br/>can ignore<br/>identity entries</td>
  <td>can "cancel" pairs of<br/>adjacent inverses</td>
  <td>can "cancel" all<br/>elements that<br/>can be paired<br/>with an inverse</td>
 </tr>
 <tr> 
  <td><b>distributed<br/>storage</b></td>
  <td>must store original ordering<br/>and hierarchization</td>
  <td>must store original<br/>hierarchization</td>
  <td>must store original ordering</td>
  <td>can store in any order</td>
  <td>no need to<br/>store identities</td>
  <td></td>
  <td></td>
 </tr>
 <tr> 
  <td><b>compression</b></td>
  <td>common subtrees</td>
  <td>common hierarchies</td>
  <td>run-length encoding</td>
  <td>distinct elements<br/>with quantities</td>
  <td>can ignore<br/>identity entries</td>
  <td>can "cancel" pairs of<br/>adjacent inverses;<br/>can apply<br/>invertible<br/>transformations</td>
  <td>can "cancel" all<br/>elements that<br/>can be paired<br/>with an inverse</td>
 </tr>
 <tr> 
  <td><b>example/<br/>test case<br/>enumeration</b></td>
  <td colspan="7">can enumerate examples/test cases automatically</td>
 </tr>
 <tr> 
  <td><b>proving<br/>implementation<br/>works correctly<br/>for all inputs</b></td>
  <td colspan="7">can show this by structural induction</td>
 </tr>
</table>

<a name="lecture21"></a>
<a name="6.2a"></a>
<h3>Group of all permutations (symmetric group)</h3>

Recall that a permutation on a set %X is a bijective relation between %X and %X. Since a permutation is a map (i.e., a function),
we can reason about composition of permutations (it is just the composition of functions). Thus, we can study sets of permutations
as algebraic structures under the composition operation \circ.

Notice that for any set %X of finite size %n, we can relabel the elements of %X to be {0,...,%n-1} (that is, we can define a bijection
between %X and {0,...,%n-1}). Thus, we can study permutations on {0,...,%n-1} without loss of generality. 

<div class="mathenv fact proposition_to_know">
<b>Definition:</b> For the identity permutation on %n elements, we adopt the notation [0,1,2,3,4,5,...,%n-1]. Any other permutation is
represented as a rearranged list of the elements in [0,1,2,3,4,5,...,%n-1].
</div>

<div class="mathenv fact proposition_to_know">
<b>Definition:</b> Any permutation that swaps exactly two elements is called a <i>swap</i>. Examples of swaps are 
[0,<b style="color:firebrick;">3</b>,2,<b style="color:firebrick;">1</b>],
[<b style="color:firebrick;">1</b>,<b style="color:firebrick;">0</b>], and
[0,<b style="color:firebrick;">6</b>,2,3,4,5,<b style="color:firebrick;">1</b>].
</div>

<div class="mathenv fact proposition_to_know">
<b>Definition:</b> Any permutation that swaps exactly two adjacent elements is called an <i>adjacent swap</i>. 
Examples of adjacent swaps are [0,1,<b style="color:firebrick;">3</b>,<b style="color:firebrick;">2</b>],
[<b style="color:firebrick;">1</b>,<b style="color:firebrick;">0</b>,2,3,4], and
[0,1,<b style="color:firebrick;">3</b>,<b style="color:firebrick;">2</b>,4,5,6].
</div>

<div class="mathenv fact proposition_to_know">
<b>Definition:</b> Define %S_%n to be the set of permutations of the set {0,...,%n-1}. Together with the composition operation on permutations,
%S_%n is a <i>group</i>, and we call it the <i>symmetric group</i> on %n element:
<ul>
  <li>%S_%n is closed under composition of permutations (since %S_%n contains all of them);</li>
  <li>composition of functions (including permutations) is associative;</li>
  <li>there is an identity permutation [0,1,2,3,4,5,...,%n-1];</li>
  <li>every permutation has an inverse (see <a href="#permutations_inverses_proof">proof by induction</a>).</li>
</ul>
Notice that %S_%n is not commutative.
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> The symmetric group %S_%n contains %n! permutations.

Suppose we want to construct a permutation [%a_1,...,%a_%n] using the elements in {0,...,%n-1}, where we are only allowed to take each
element in the set once and assign it to an unassigned entry %a_%i. Then for the first slot, we have %n possibilities; for the second,
we have %n-1 possibilities. For the third, we have %n-2 possibilities, and so on until we have only one possibility left.
Thus, the number of possible permutations we can make is:
\begin{eqnarray}
%n! & = & %n \cdot (%n-1) \cdot (%n-2) \cdot ... \cdot 2 \cdot 1
\end{eqnarray}
</div>

<div class="mathenv example_to_know">
<b>Example:</b> The group of permutations of {0,1} is %S_2 = {[0,1], [1,0]}.
</div>

<div class="mathenv example_to_know">
<b>Example:</b> The group of permutations of {0,1,2} is %S_3 = {[0,1,2], [0,2,1], [1,0,2], [1,2,0], [2,0,1], [2,1,0]}.
</div>

<a name="permutations_inverses_proof"></a>
<div class="mathenv example_to_know">
<b>Example:</b> Suppose we want to show that every permutation in %S_%n has an inverse. We know that the set of
adjacent swaps is a generating set for %S_%n. Thus, if the operator \circ represents composition and %B represents
the set of adjacent swaps, we have that %S_%n = closure(%B, \circ).

For the base cases in %B: every swap is its own inverse.

Next, suppose a permutation %p \in %S_%n and another permutation %q \in %S_%n both have inverses %p^{-1} and %q^{-1}.
Then %p \circ %q also has an inverse %q^{-1} \circ %p^{-1}:
\begin{eqnarray}
(%p \circ %q) \circ (%q^{-1} \circ %p^{-1}) & = & %p \circ (%q \circ %q^{-1}) \circ %p^{-1} \\
                                            & = & %p \circ [0,...,%n-1] \circ %p^{-1} \\
                                            & = & %p \circ %p^{-1} \\
                                            & = & [0,...,%n-1]
\end{eqnarray}
</div>

<a name="sorting_algorithms"></a>
<div class="mathenv fact proposition_to_know">
<b>Fact:</b> The sorting algorithms bubble sort, insertion sort, selection sort, and quicksort all rely on swap permutations as their
basic operation:
<ul>
  <li>bubble sort uses only adjacent swaps;</li>
  <li>insertion sort uses only adjacent swaps;</li>
  <li>selection sort uses only swaps;</li>
  <li>quicksort uses only swaps.</li>
</ul>
If any of the above algorithms recorded the swap operations performed in a sort of a permutation %p \in %S_%n,
they would effectively decompose the permutation %p into a list of swap permutations %q_1,...,%q_%k such that if the
swap permutations were composed in reverse, they would yield %p:
\begin{eqnarray}
%p & = & %q_1 \circ ... \circ %q_%k \circ [0,...,%n-1]
\end{eqnarray}
This also implies that the complexity of determining the adjacent swaps that can be composed to form an arbitrary %p \in %S_%n is
at most O(%n^2)
(using either insertion sort or bubble sort), while the complexity of
determining the swaps that can be composed to form an arbitrary %p \in %S_%n is at most O(%n \log %n) (using quicksort).
</div>

<a name="6.2b"></a>
<h3>Groups of circular shift permutations (cyclic groups)</h3>

<div class="mathenv fact proposition_to_know">
<b>Definition:</b> Any permutation that performs a circular shift on elements is a <i>circular shift permutation</i>, or just
a <i>shift</i>. Examples of shifts are [6,7,0,1,2,3,4,5], [2,3,4,0,1], and [4,0,1,2,3].
</div>

<div class="mathenv fact proposition_to_know">
<b>Definition:</b> Let %p = [%n-1,0,1,2,...,%n-2] be a shift by one element. Then we call %C_%n = closure(%p, \circ) the
<i>cyclic group</i> on %n elements.
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> For any %n \in \N, the cyclic group %C_%n is commutative.
</div>

<a name="lecture17"></a>
<!--assignment5-->
<br/><hr/>
<a name="6.3"></a>
<a name="assignment5"></a>
<b>Assignment #5: Algebraic Structures and Permutations</b>
<!--span class="btn_assignment">(<a href="materials.php?hw=5">show only this assignment</a>)</span-->

  <p>For this assignment, you will submit a single Python source file <code>a5.py</code>.

  <b style="color:firebrick;">Your file may not import any modules or 
  employ any external library functions associated with
  integers and sets (unless the problem statement explicitly permits this). 
  You will be graded on the correctness, concision, and mathematical legibility of your code.
  The different problems and problem parts rely on each other; carefully consider whether you
  can use functions you define in one part within subsequent parts.
  You may reuse functions that you defined on previous assignments.</b>

<ol>
  <li>Suppose that we decide to represent permutations as lists of integers, such as <code>[2,1,0]</code>. For example,
      given some ordered list of elements such as <code>['a','b','c']</code>, after the permutation <code>[2,1,0]</code>
      is applied:
      <ul>
        <li>the element <code>'a'</code>with index <code>0</code> in <code>['a','b','c']</code> should move to the location with
            index <code>2</code> in the result;
        </li>
        <li>the element <code>'b'</code>with index <code>1</code> in <code>['a','b','c']</code> should move to the location with
            index <code>1</code> in the result;
        </li>
        <li>the element <code>'c'</code>with index <code>2</code> in <code>['a','b','c']</code> should move to the location with
            index <code>0</code>.
        </li>
      </ul>
    <ol style="list-style-type:lower-alpha; margin-top:6px;">
      <li style="padding-bottom:12px;">
        Implement a function <code>permute()</code> that takes two arguments: a list <code>a</code> of length %n and a permutation 
        <code>p</code> on %n elements. It should return the permuted list. For example:
        <pre class="snippet">permute(['a','b','c'], [2,1,0]) # Should evaluate to ['c','b','a'].</pre>

      </li>
      <li style="padding-bottom:12px;">
        Implement a function <code>compose()</code> that takes two permutations <code>p1</code> and <code>p2</code>,
        both of the same length, and returns a single permutation that is the composition of those two permutations.
        That is, it returns a permutation <code>p3</code> that, when applied to a list, will produce the same result as
        applying the first permutation to the second permutation:
        <pre class="snippet"># Should be "True" for any inputs if they are all of the same length.
permute(a, compose(p1,p2)) == permute(permute(a, p1), p2)</pre>

      </li>
      <li style="padding-bottom:12px;">
        Implement a function <code>composeList()</code> that takes as its one input a list of permutations, and returns a single
        permutation that is the result of composing the permutations in the list (according to the order
        they appear in the list).

      </li>
      <li style="padding-bottom:12px;">
        Recall that for the set of permutations on %n elements, the generating set can be the set of permutations that
        swap only two elements.
        Implement a function <code>generators()</code> that takes a single positive integer argument <code>n</code> and
        returns the set of generators for the set of permutations on %n elements. An example is provided below.
        <pre class="snippet">generators(4) # Should return {[1,0,2,3], [0,2,1,3], [0,1,3,2]}.
generators(5) # Should return {[1,0,2,3,4], [0,2,1,3,4], [0,1,3,2,4], [0,1,2,4,3]}.</pre>
      </li>
      <li style="padding-bottom:12px;">
        Implement a function <code>factor()</code> that takes a single permutation on %n elements as an input and returns
        a list of generating permutations that can be composed to reconstruct it:
        <pre class="snippet"># Should be "True" for any permutation "p".
composeList(factor(p)) == p</pre>
        <b style="color:firebrick;">See <a href="#sorting_algorithms">this fact about sorting algorithms</a> for one approach
        that can be used to implement <code>factor()</code>.</b>
        <pre class="Pythoncode">
# Part (e).
def factor(p):
    # If the permutation is the identity, return a list containing two
    # instances of the same transposition.
    if list(p) == list(range(len(p))):
        transposition = list(p)
        transposition[0:2] = [1, 0]
        return [transposition, transposition]
    factors = []
    for i in range(0, len(p)):
        if p[i] != i:
            for j in range(0, len(p)):
                if p[j] == i:
                    factors = factors + [swapTwo([x for x in range(0, len(p))], i, j)]
                    p[j] = p[i]
                    p[i] = i
    # Reverse the list because the :func:`composeList` function expects the
    # permutations to be applied from left to right (instead of right to left
    # as in the mathematical definition of function composition).
    return list(reversed(factors))</pre>
      </li>
    </ol>
  </li>

  <li>Suppose that we use Python classes to represent algebraic structures, so that objects of those classes correspond to
      elements of the algebraic structures. We define the following superclass; all algebraic structures will be subclasses
      of this superclass.
      <pre class="snippet">class AlgebraicStructure():
    def __repr__(self):    return str(self)
    def __str__(self):     return str(self.elem)
    def __hash__(self):    return hash(self.elem)
 
    def generators(self):  return {}
    def associative(self): return False
    def identity(self):    return None
    def inverses(self):    return {}
    def commutative(self): return False
 
    def __eq__(x, y):
        return x.elem == y.elem
 
    def __init__(self, elem):
        self.elem = elem
 
    def __add__(x, y):
 
        # Complete this function for #2.
 
        # You may want to check wither either or both
        # of the inputs "x" and "y" are simply members
        # of the generating set, and transform them first
        # to make your code more uniform.
 
        return None</pre>
      It should be possible to define a new algebraic structure by
      defining a subclass and overloading a few of the member methods. For example,
      the following subclass represents a group with the generators <code>'a'</code>, <code>'b'</code>, and <code>'c'</code>:      
      <pre class="snippet">class G(AlgebraicStructure):
    def generators(self):  return {'a','b','c'}
    def associative(self): return True
    def identity(self):    return 'c'
    def inverses(self):    return {{'a','b'}, {'c','c'}}
    def commutative(self): return True</pre>
      Complete the definition of the <code>__add__()</code> method so that it works in at least the following cases. That is,
      the <code>__add__()</code> should behave differently in all of these cases, and it should decide how to behave by
      calling the member methods <code>generators()</code>, <code>associative()</code>, <code>identity()</code>, <code>identity()</code>,
      <code>inverses()</code>, and <code>commutative()</code>.
      <ol style="list-style-type:lower-alpha; margin-top:6px;">
        <li>If the algebraic structure is a free magma, use nested lists to represent an element.</li>
        <li>If the algebraic structure is a commutative magma, use nested sets to represent an element.</li>
        <li>If the algebraic structure is a free semigroup, use a single list to represent an element.</li>
        <li>If the algebraic structure is a commutative semigroup, use a single set to represent an element.</li>
        <li>If the algebraic structure is a monoid, do not store the identity element unless it is necessary.</li>
        <li>If the algebraic structure is a group or commutative group, "cancel" as many elements with their inverses as possible
            in an element's representation.</li>
      </ol>
      <pre class="Pythoncode">
    def __add__(x, y):
 
        # If the arguments are not from the same subclass,
        # do not return a result.
        if type(y) != type(x):
            return None
        constructor = type(x)
        c = x
 
        # Helper method for cancelling inverses in
        # non-commutative structures.
        def cancelNonCommutative(l):
            repeat = True
            while repeat:
                repeat = False
                for i in range(0,len(l)-1):
                    if frozenset([l[i],l[i+1]]) in c.inverses():
                        l = l[:i] + l[i+2:]
                        repeat = True
                        break
            return l
 
        # Helper methods for cancelling inverses in
        # non-commutative structures.
        def cancelCommutative(s):
            r = frozenset([])
            for (g1,q1) in s:
                qNew = q1
                for (g2,q2) in s:
                    if frozenset([g1,g2]) in c.inverses():
                        qNew = max(0, q1-q2)
                if qNew > 0:
                    r = r.union({(g1, qNew)})
            return r
 
        # Free magmas.
        # Part (a).
        if not c.associative() and not c.commutative() and\
           c.identity() == None and len(c.inverses()) == 0:
 
            # We use lists because both order and hierarchization
            # matter.
            return constructor((x.elem,y.elem))
 
        # Commutative magmas.
        # Part (b).
        if not c.associative() and c.commutative() and\
           len(c.inverses()) == 0:
 
            # We use sets because order should not matter,
            # but they are nested since hierarchization
            # still matters.
            return constructor(frozenset([x.elem,y.elem]))
 
        # Free semigroups, free monoids, and free groups.
        # Parts (c), (e), and (f).
        if c.associative() and not c.commutative():
 
            # If either argument is the identity,
            # simply return the other argument.
            # This only applies to monoids.
            if x.elem == c.identity(): return y
            if y.elem == c.identity(): return x
 
            # We turn both argument representations into lists
            # so that we can operate on generators as single-item
            # lists.
            x = [x.elem] if not type(x.elem) is list else x.elem
            y = [y.elem] if not type(y.elem) is list else y.elem
 
            # We use list concatenation, which is associative.
            result = x + y
 
            # If inverses exist, we cancel as necessary.
            result = cancelNonCommutative(result)
 
            if len(result) == 0:
                result = c.identity()
 
            # If the resulting list has length 1, then use the alternate
            # representation of the group element as just the element itself
            # instead of a singleton list.
            if isinstance(result, list) and len(result) == 1:
                result = result[0]
 
            return constructor(result)
 
        # Commutative semigroups, commutative monoids, and commutative groups.
        # Parts (d), (e), and (f).
        if c.associative() and c.commutative():
 
            # If either argument is the identity,
            # simply return the other argument.
            # This only applies to monoids.
            if x.elem == c.identity(): return y
            if y.elem == c.identity(): return x
 
            # We use a relation mapping generators to counts
            # (which is just a set of pairs).
            x = [(x.elem,1)] if not type(x.elem) is frozenset else x.elem
            y = [(y.elem,1)] if not type(y.elem) is frozenset else y.elem
 
            # Collect all the generators found in "x" and "y".
            gs = set([g for (g,q) in x] + [g for (g,q) in y])
 
            def lookup(g,x):
                d = dict(x)
                if g in d: return d[g]
                return 0
 
            # Add up the generator counts in "x" and "y" and
            # return the resulting relation.
            result = {(g, lookup(g,x) + lookup(g,y)) for g in gs}
            result = {(g,q) for (g,q) in result if q > 0}
 
            # If inverses exist, we cancel as necessary.
            result = cancelCommutative(result)
 
            if len(result) == 0:
                result = c.identity()
 
            # If the resulting multiset has cardinality one, then use the
            # alternate representation of the group element as just the element
            # itself instead of a singleton multiset.
            if isinstance(result, frozenset) and len(result) == 1:
                element, count = list(result)[0]
                if count == 1:
                    result = element
 
            return constructor(result)
  
        return None</pre>
      
      <b style="color:firebrick;">Additional test cases are provided below.</b>
      <pre class="snippet">class M(AlgebraicStructure):
    def generators(self):  return {'A','B','C','D','E'}
 
M('A') + M('B') == M('B') + M('A') # False.
M('A') + M('C') + M('B') == M('A') + M('B') + M('B') # False.
M('A') + (M('B') + M('C')) == M('A') + (M('B') + M('C')) # True.
 
class CM(AlgebraicStructure):
    def generators(self):  return {'A','B','C'}
    def commutative(self): return True
 
CM('A') + CM('B') == CM('B') + CM('A') # True.
(CM('A') + CM('C')) + CM('B') == CM('B') + (CM('C') + CM('A')) # True.
(CM('A') + CM('B')) + CM('C') == CM('A') + (CM('B') + CM('C')) # False.
 
class S(AlgebraicStructure):
    def generators(self):  return {1,2,3}
    def associative(self): return True
 
(S(1) + S(2)) + S(3) == S(1) + (S(2) + S(3)) # True.
S(2) + S(1) + S(3) == S(3) + S(1) + S(2) # False.
 
class CS(AlgebraicStructure):
    def generators(self):  return {1,2,3}
    def associative(self): return True
    def commutative(self): return True
 
(CS(1) + CS(2)) + CS(3) == CS(1) + (CS(2) + CS(3)) # True.
CS(2) + CS(1) + CS(3) == CS(3) + CS(1) + CS(2) # True.
 
class N(AlgebraicStructure):
    def generators(self):  return {1,2,3}
    def associative(self): return True
    def identity(self):    return 1
 
(N(3) + N(2)) + N(3) == N(3) + (N(2) + N(3)) # True.
N(2) + N(1) + N(3) == N(3) + N(1) + N(2) # False.
N(1) + N(2) == N(2) + N(1) == N(2) # True.
 
class CG(AlgebraicStructure):
    def generators(self):  return {-1,0,1}
    def associative(self): return True
    def commutative(self): return True
    def identity(self):    return 0
    def inverses(self):    return frozenset([frozenset([-1,1]), frozenset([0,0])])
 
CG(-1) + CG(1) == CG(0) # True.
CG(1) + CG(1) + CG(-1) + CG(-1) + CG(1) == CG(0) + CG(1) # True.
CG(-1) + CG(1) == CG(1) + CG(1) # False.</pre>  
  </li>

  <li>Implement a new member method <code>enumerate()</code> for the <code>AlgebraicStructure</code> class. This method should take
      a single positive integer argument <code>n</code>, and should return a set of <i>all</i> the elements in the algebraic
      structure the representations of which contain %n or fewer generators. <b style="color:firebrick;">See the 
      <a href="#definition_closure">definition of closure</a> for one approach that can be used to implement this method.</b>
      <pre class="Pythoncode">
    # Any approach for accessing the subclass that works is
    # acceptable. Here, we assume that ".generate()" is always
    # invoked on an object of the subclass.
    def enumerate(self, n):
        def remove_duplicates(l):
            """Inefficiently returns a new list which contains the elements of
            `l` with duplicates removed.
 
            If `l` is a set of hashable objects, use ``set(l)`` instead. This
            is primarily intended for lists of unhashable objects, like other
            lists.
 
            """
            result = []
            for x in l:
                if x not in result:
                    result.append(x)
            return result
        s = []
        if n == 1:
            for g in self.generators():
                s.append(self.__class__(g))
        else:
            for i in range(1,n):
                for x in self.enumerate(i):
                    for y in self.enumerate(n - i):
                        s.append(x + y)
        return remove_duplicates(s)</pre>
  </li>

  <li>In this problem, you will implement methods for splitting an individual element from an algebraic structure
      (i.e., an object) into multiple parts that can later be reassembled back together to obtain an equivalent object.
    <ol style="list-style-type:lower-alpha; margin-top:6px;">
      <li style="padding-bottom:12px;">
        Implement a method <code>split()</code> for the <code>AlgebraicStructure</code> class that takes a single argument,
        a positive integer <code>n</code> <b style="color:firebrick">(note that the definition will also have <i>self</i>
        as the first argument)</b>. This method should return a list; each entry in the list should be an ordered pair <code>(a,e)</code>
        such that <code>e</code> is an element in the algebraic structure that contains at most <code>n</code> generators,
        and <code>a</code> is an annotation for rebuilding the split-up element.
        <b style="color:firebrick">You will need to decide what information, and how much of it, 
        <code>a</code> must contain to solve part (b) below.</b>
        
        For example, if the element is from a commutative semigroup (defined as a class <code>CS</code>) such that
        elements are represented using sets of generators, you may find that you do not need to store any information in
        <code>a</code> to reconstruct the object. <b style="color:firebrick;">Note the corrected example output below.</b>.
<pre class="snippet">x = CS('a') + CS('b') + CS('c') + CS('d') + CS('e')
 
# Evaluates to [(None, CS('a') + CS('b')), (None, CS('c') + CS('e')), (None, CS('d'))]
x.split(2)            
 
# Evaluates to "True".
join(x.split(2)) == x</pre>
      </li>
      <li style="padding-bottom:12px;">
        Implement a static method <code>join()</code> for the <code>AlgebraicStructure</code> class that takes a single argument,
        a list of pairs of the form <code>(a,e)</code>, and restores the original element that was split using <code>split()</code>.
        In other words, we should have for any element <code>x</code> that <code>M.join(x.split(n, p))</code> is equivalent to
        <code>x</code> for any positive <code>n</code>.

        <b style="color:firebrick">You may not assume that the list given as input to <code>join()</code> has its elements in the same order as the list
        returned by <code>split()</code>.</b>

        Your <code>join()</code> implementation should be as efficient as possible given the properties of a particular algebraic
        structure.
        <ul>
          <li>A split-up element of a commutative semigroup should be reassembled in linear time (in terms of the number of generators).</li>
          <li>A split-up element of a magma should be reassembled in at most quadratic time  (in terms of the number of generators).
          Is it possible to reassemble the element in time O(%n \log %n)?</li>
        </ul>
      </li>
    </ol>
  </li>
</ol>
<hr/><br/>
<!--/assignment5-->

<a name="lecture19"></a>
<a name="lecture20"></a>
<a name="6.4"></a>
<h3>Isomorphism: Equivalence of Algebraic Structures</h3>

<div class="mathenv fact proposition_to_know">
<b>Definition:</b> Let %A be an algebraic structure with operator \oplus and let %B be an algebraic structure with operator \otimes.
We say that %A is <i>isomorphic</i> to %B, which we denote as (%A,\oplus) \cong (%B,\otimes) or simply %A \cong %B, if the following
conditions hold:
<ul>
  <li>there exists a bijection between %A and %B, whic we denote =;</li>
  <li>for all %a, %a' \in %A and %b,%b' \in %B, %a=%b and %a' = %b' implies %a \oplus %a' = %b \oplus %b'.</li>
</ul>
</div>

<a name="6.5"></a>
<h3>Reasoning about Algebraic Structures using Induction</h3>

Suppose an algebraic structure %A with operator \oplus has a finite generating set. Since the generating set is finite
and there is only a single binary operator \oplus, we are able to construct very short proofs about properties that
apply to <i>all</i> elements in %A.

<div class="mathenv fact proposition_to_know">
<b>Definition:</b> Let %A be an algebraic structure with a generating set %S = {%g} and an operator \oplus. Then the following <i>formula</i>
is the <i>induction assumption</i> or <i>(weak) axiom of induction</i> for %A.
The <i><b style="color:firebrick">inductive hypothesis</b></i> is in red.
<ol style="list-style-type:none;">
 <li>for all predicates %P,</li>
 <li>
   <ol style="list-style-type:none;">
     <li>
       <ol style="list-style-type:none;">
         <li>
           <ol style="list-style-type:none;">
             <li>%P(%g)</li>
           </ol>
         </li>
         <li>and</li>
         <li>
           <ol style="list-style-type:none;">
             <li>for all %a \in %A, for all %b \in %A,
               <ol style="list-style-type:none;">
                 <li><b style="color:firebrick">%P(%a) and %P(%b)</b></li>
                 <li>implies</li>
                 <li>%P(%a \oplus %b)</li>
               </ol>
             </li>
           </ol>
         </li>
       </ol>
     </li>
     <li>implies</li>
     <li>
       <ol style="list-style-type:none;">
         <li>for all %a \in %A, %P(%a)</li>
       </ol>
     </li>
   </ol>
 </li>
</ol>
</div>

<div class="mathenv example_to_know">
<b>Example:</b> Let \N be an algebraic structure with the generating set {0,1} and the integer addition operator +. Then the following formula
is the axiom of induction for \N:
<ol style="list-style-type:none;">
 <li>for all predicates %P,</li>
 <li>
   <ol style="list-style-type:none;">
     <li>
       <ol style="list-style-type:none;">
         <li>
           <ol style="list-style-type:none;">
             <li>%P(0) and %P(1)</li>
           </ol>
         </li>
         <li>and</li>
         <li>
           <ol style="list-style-type:none;">
             <li>for all %m \in \N, for all %n \in \N,
               <ol style="list-style-type:none;">
                 <li>%P(%m) and %P(%n)</li>
                 <li>implies</li>
                 <li>%P(%m + %n)</li>
               </ol>
             </li>
           </ol>
         </li>
       </ol>
     </li>
     <li>implies</li>
     <li>
       <ol style="list-style-type:none;">
         <li>for all %n \in \N, %P(%n)</li>
       </ol>
     </li>
   </ol>
 </li>
</ol>
Because + is commutative and associative over \N, and because 1 = 0 + 1, we can simplify the above axiom to the more familiar
axiom of induction over natural numbers:
<ol style="list-style-type:none;">
 <li>for all predicates %P,</li>
 <li>
   <ol style="list-style-type:none;">
     <li>
       <ol style="list-style-type:none;">
         <li>
           <ol style="list-style-type:none;">
             <li>%P(0)</li>
           </ol>
         </li>
         <li>and</li>
         <li>
           <ol style="list-style-type:none;">
             <li>for all %m \in \N,
               <ol style="list-style-type:none;">
                 <li>%P(%m)</li>
                 <li>implies</li>
                 <li>%P(%m + 1)</li>
               </ol>
             </li>
           </ol>
         </li>
       </ol>
     </li>
     <li>implies</li>
     <li>
       <ol style="list-style-type:none;">
         <li>for all %n \in \N, %P(%n)</li>
       </ol>
     </li>
   </ol>
 </li>
</ol>
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact (fundamental theorem of arithmetic):</b> Consider a commutative semigroup %A with generating set %S = { %p | %p \in \N, %p is prime } 
and an operator \otimes that is associative and commutative. Let \N be the commutative semigroup of positive integers 
{ %n | %n \in \N, %n \geq 2 } with the integer multiplication operator. The semigroup %A is <i>isomorphic</i> to \N:
\begin{eqnarray}
  (%A,\otimes) & \cong & (\N,+)
\end{eqnarray}
Equivalently, we can say that every natural number has a unique prime factorization (notice that the algebra %A is actually the set of
prime factorizations, with \otimes corresponding to multiplication of prime factorizations).
</div>

<div class="mathenv example_to_know">
<b>Example:</b> We have introduced the following definition of the totient function \phi.
\begin{eqnarray}
  \phi(%m) & = & |{%k | %k \in {1,...,%m}, \gcd(%k,%m) = 1}|
\end{eqnarray}
We have also introduced the following properties of the totient function \phi.
\begin{eqnarray}
  \phi(%p) & = & %p - 1 &  & if %p is prime \\
  \phi(%p^{%k}) & = & %p^{%k} - %p^{%k-1} &  & if %p is prime \\
  \phi(%n \cdot %m) & = & \phi(%n) \cdot \phi(%m) &  & if \gcd(%n,%m) = 1
\end{eqnarray}
Is the set of three equations above <i>equivalent</i> to our one-line definition of \phi?
That is, if we know the factorization of <i>any</i> input %n > 1 to \phi, can we compute
\phi exactly using the three equations above?

The answer is "yes". Consider the algebraic structure consisting of the set {2,3,4,...} and the operation \cdot (integer
multiplication). Then the set of generators of %A is the set of prime numbers. Thus, any element %x \in %A is a
product of some collection of not necessarily distinct prime numbers %p_1 \cdot ... \cdot %p_{%k}. If we write
down %n as this product, we can always break down our computation of \phi(%n) into smaller computations
until we reach the base case.
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> For any two positive integers %m \in \N, %n \in \N where \gcd(%m,%n) = 1, for any %a \in \N, there exist %s and %t  
such that
\begin{eqnarray}
  %s \cdot %m + %t \cdot %n & = & %a
\end{eqnarray}
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> For any two positive integers %m \in \N, %n \in \N, suppose that %g = \gcd(%m,%n). For any %a \in %g\Z, there exist
%s and %t  such that
\begin{eqnarray}
  %s \cdot %m + %t \cdot %n & = & %a
\end{eqnarray}
</div>

<a name="lecture22"></a>
<a name="6.6"></a>
<h3>Subgroups and the Direct Product of Groups</h3>

<div class="mathenv fact proposition_to_know">
<b>Definition:</b> Let %A be a group under the operator \oplus. We say that %B is a subgroup of %A if %B \subset %A,
%A is closed under \oplus, and %A is a group.
</div>





<div class="mathenv fact proposition_to_know">
<b>Fact:</b> For %n \in \N, %a \in {0,...,%n-1}, and \gcd(%a,%n) = 1, consider the generating set {%a} with the operation of addition modulo %n, denoted using +.
Then closure({%a}, +) = \Z/%n\Z.
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> For %n \in \N, %m \in \N, and \gcd(%m,%n) = 1, consider the generating set {%m} with the operation of addition modulo %n \cdot %m, denoted using +.
Then closure({%m}, +) = {0 \cdot %m, 1 \cdot %m, 2 \cdot %m, ..., (%n-1) \cdot %m}. 
Let \oplus denote addition modulo %n. It is then the case that (closure({%m}, +), +) \cong (\Z/%n\Z, \oplus).
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> For any two positive integers %m \in \N, %n \in \N, let + represent the addition operator modulo %m \cdot %n. If \gcd(%m,%n) = 1 then we have that:
\begin{eqnarray}
  closure({%m,%n}, +) & = & \Z/(%m \cdot %n)\Z
\end{eqnarray}

For an intuition for why this is true, consider the following, which is true by <a href="#bezout-identity">B&eacute;zout's identity</a>:
\begin{eqnarray}
  { %a \cdot %m + %b \cdot %n | %a \in \Z, %b \in \Z } & = & \Z.
\end{eqnarray}
Since any value in %z \in \Z has a corresponding formula %z = %a \cdot %m + %b \cdot %n, we could simply compute that formula modulo %m \cdot %n. We will get only results from
the set {0,...,(%m \cdot %n) - 1}, and since such a formula exists for all %z, then all values in {0,...,(%m \cdot %n) - 1} will be produced.

For a more formal proof, we can simply use <a href="#bezout-identity">B&eacute;zout's identity</a> directly. Since there exist %a, %b \in \Z such that
1 = %a \cdot %m + %b \cdot %n, we have:
\begin{eqnarray}
  1 & = & %a \cdot %m + %b \cdot %n \\
  1 \mod (%m \cdot %n) & = & (%a \cdot %m + %b \cdot %n) \mod (%m \cdot %n) \\
  1 \mod (%m \cdot %n) & = & ((%a \mod (%m \cdot %n)) \mod  \cdot %m + (%b \mod (%m \cdot %n)) \cdot %n) \mod (%m \cdot %n) \\
  (%a \mod (%m \cdot %n)) & \in & \Z/(%m \cdot %n)\Z\\
  (%b \mod (%m \cdot %n)) & \in & \Z/(%m \cdot %n)\Z
\end{eqnarray}
Thus, 1 \in closure({%m,%n}, +). Thus:
\begin{eqnarray}
  1 & \in & closure({%m,%n}, +) \\
  closure({1},+) & \subset & closure({%m,%n},+)\\
  \Z/(%m \cdot %n)\Z & \subset & closure({%m,%n},+)\\
   closure({%m,%n},+) & \subset & \Z/(%m \cdot %n)\Z\\
   closure({%m,%n},+) & = & \Z/(%m \cdot %n)\Z
\end{eqnarray}




</div>









<div class="mathenv fact proposition_to_know">
<b>Fact:</b> For %n \in \N, %a \in {0,...,%n-1}, and \gcd(%a,%n) = 1, consider the generating set {%a} with the operation of addition modulo %n, denoted using +.
Then closure({%a}, +) = \Z/%n\Z.
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> For %n \in \N, %a \in {0,...,%n-1}, and \gcd(%a,%n) = %g for some %g \geq 1, consider the generating set {%a} with the operation of addition modulo %n, denoted using +.
Then closure({%a}, +) = {0 \cdot %g, 1 \cdot %g, 2 \cdot %g, 3 \cdot %g, ..., (%n-1)\cdot%g}.

Notice that closure({%a}, +) is a subset of \Z/%n\Z. Notice that it is also closed under +, and that it is a group. Thus, it is a subgroup of \Z/%n\Z.
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> For %n \in \N, %a \in {0,...,%n-1}, suppose the operation of addition modulo %n is denoted by +, and the operation of addition modulo %n/\gcd(%n,%a) is
denoted by \oplus. Let %A = closure({%a}, +) and %B = closure({%a/\gcd(%a,%n)}, \oplus). Then it is the case that (%A,+) \cong (%B,\oplus).
</div>






<div class="mathenv fact">
<b>Definition:</b> Let %A be a group under the operator \oplus, and let %B be a group under the operator \otimes.
We define the <i>direct product of groups</i> %A and %B to be the set product %A \times %B under the operator
\lozenge : %A \times %B \rightarrow %A \times %B defined
by:
\begin{eqnarray}
  (%a,%b) \lozenge (%a', %b') & = & (%a \oplus %a', %b \otimes %b')
\end{eqnarray}
</div>


<div class="mathenv example_to_know">
<b>Example:</b> Suppose there is a large database of users in which the ages and heights of users are available as an integers.
You want to compute the minimum age of the users and the maximum height as efficiently as possible.

The database API can take as input a binary operator \oplus (implemented as a Python function) that is guaranteed to be
associative. It can then apply the operator to the entire table (i.e., %r_1 \oplus ... \oplus %r_%n for a database of
%n records) and return the result.

One approach to solve this problem is to first make an API call using the binary min (minimum of two integers) operator on the
age fields, and then to make a separate API call using the binary max operator on the age height fields. Is there a more efficient approach?
</div>























<a name="6.7"></a>
<h3>Algebraic Structures and Cosets</h3>

<div class="mathenv fact proposition_to_know">
<b>Definition:</b> Let %A be a semigroup under the operator \oplus. We define the <i>double coset</i> of %x \in %A, which we
denote using %A%x%A, as:
\begin{eqnarray}
  %A%x%A & = & { %a \oplus %x \oplus %b | %a \in %A, %b \in %A }
\end{eqnarray}
</div>

<div class="mathenv fact">
<b>Definition:</b> Let %A be a semigroup under the operator \oplus. We define the <i>left coset</i> of %x \in %A, which we
denote using %x%A, as:
\begin{eqnarray}
  %x%A & = & { %x \oplus %a | %a \in %A }
\end{eqnarray}
</div>

<div class="mathenv fact">
<b>Definition:</b> Let %A be a semigroup under the operator \oplus. We define the <i>right coset</i> of %x \in %A, which we
denote using %A%x, as:
\begin{eqnarray}
  %A%x & = & { %a \oplus %x | %a \in %A }
\end{eqnarray}
</div>

<div class="mathenv example_to_know">
<b>Example:</b> Consider the set %Z under the integer multiplication operator \cdot. Because \cdot is commutative over \Z,
we can say that for any %n \in \Z:
\begin{eqnarray}
  \Z%n\Z & = & { %a \cdot %x \cdot %b | %a \in %A, %b \in %A } \\
         & = & { %x \cdot (%a \cdot %b) | %a \in %A, %b \in %A } \\
         & = & { %x \cdot %c | %c \in %A }
\end{eqnarray}
Thus, the cosets \Z%n\Z, %n\Z, and \Z%n are equivalent.
</div>







<a name="6.8"></a>
<h3>Generalizations of CRT and Applications</h3>

We present some properties of closures. These properties will allow us to prove that certain subsets
of a group's elements can be used to generate the whole group. This will help us gain a deeper understanding of
the Chinese remainder theorem, and how it can be generalized.

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> Let %S be a set, and let \oplus be a binary operator.
Then we have that:
\begin{eqnarray}
  closure(closure(%S, \oplus), \oplus) & = & closure(%S, \oplus)
\end{eqnarray}
In other words, closure(%S, \oplus) already includes all the possible elements that could be built not only with elements in %S,
but also with those elements that are constructed using elements of %S. The closure operation can be called <i>idempotent</i>.
</div>

The above fact can be proven by induction for all elements %x \in closure(closure(%S, \oplus), \oplus).
For purposes of legibility, let %B = closure(%S, \oplus), so that we can say closure(%B, \oplus) = closure(closure(%S, \oplus), \oplus).
Given some generating set %S, consider the following formula:
\begin{eqnarray}
  %P(%x) & = & %x \in closure(%S, \oplus)
\end{eqnarray}
The base cases are those %x that are in %B. Thus, we can state the axiom of induction for the algebra closure(%B, \oplus):
<ol style="list-style-type:none;">
 <li>for all predicates %P,</li>
 <li>
   <ol style="list-style-type:none;">
     <li>
       <ol style="list-style-type:none;">
         <li>
           <ol style="list-style-type:none;">
             <li>for all %x \in %B, %P(%x)</li>
           </ol>
         </li>
         <li>and</li>
         <li>
           <ol style="list-style-type:none;">
             <li>for all %a \in closure(%B, \oplus), for all %b \in closure(%B, \oplus),
               <ol style="list-style-type:none;">
                 <li><b style="color:firebrick">%P(%a) and %P(%b)</b></li>
                 <li>implies</li>
                 <li>%P(%a \oplus %b)</li>
               </ol>
             </li>
           </ol>
         </li>
       </ol>
     </li>
     <li>implies</li>
     <li>
       <ol style="list-style-type:none;">
         <li>for all %x \in closure(%B, \oplus), %P(%x)</li>
       </ol>
     </li>
   </ol>
 </li>
</ol>
The proof is then as follows. For the bases cases, %B = closure(%S, \oplus), so we have that:
\begin{eqnarray}
  %x \in %B implies %x \in closure(%S, \oplus)
\end{eqnarray}
Now, suppose that for some %a \in closure(%B, \oplus) and %b \in closure(%B, \oplus), we have that
%a \in closure(%S, \oplus) and %b \in closure(%S, \oplus). Then by definition of the closure,
\begin{eqnarray}
  %a \oplus %b \in closure(%S, \oplus)
\end{eqnarray}
This concludes the proof.

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> Let %S be a set, and let \oplus be a binary operator. Suppose that %T \subset closure(%S,\oplus).
Then we have that:
\begin{eqnarray}
  closure(%T, \oplus) & \subset & closure(%S, \oplus)
\end{eqnarray}
In other words, if all the elements in %T are also elements in closure(%S,\oplus), then any element that can be constructed
using elements in %T is also in closure(%S,\oplus). As in the example above, this can be proven by induction.
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> Let %S be a generating set, and let \oplus be a binary operator. Consider some element %x \in closure(%S,\oplus), 
and some %T \subset closure(%S,\oplus). Suppose that %x \in closure(%T, \oplus). Then we have that:
true that:
\begin{eqnarray}
  %x & \in & closure(%T, \oplus) \\
  closure({%x}, \oplus) & \subset & closure(%T, \oplus)
\end{eqnarray}
In other words, if elements in %T together with \oplus can be used to construct %x, then all elements that can be constructed
with %x and \oplus are <i>also</i> in closure(%T, \oplus). As in the example above, this can be proven by induction.
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> Let %S be a generating set, and let \oplus be a binary operator.
Consider some generator %g \in %S such that closure({%g},\oplus) = closure(%S,\oplus),
and some %T \subset %S. Suppose that %g \in closure(%T, \oplus). Then we have that:
true that:
\begin{eqnarray}
  %g & \in & closure(%T, \oplus) \\
  closure({%g}, \oplus) & \subset & closure(%T, \oplus) \\
  closure(%S,\oplus) & \subset & closure(%T, \oplus) \\
  closure(%T, \oplus) & \subset & closure(%S,\oplus) \\
  closure(%T, \oplus) & = & closure(%S,\oplus) \\
\end{eqnarray}
Thus, if a single generator can generate all of closure(%S,\oplus), and it can be assembled using only elements in %T, then
the elements in %T can be used to assemble all the elements of closure(%S,\oplus). As in the example above, this can be proven by induction.
</div>

<table class="fig_table2">
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">%n \in \N, %m \in \N<br/>\gcd(%n,%m) = 1<br/>\oplus_%k represents integer addition modulo %k</td>
 </tr>
 <tr> 
  <td class="cell" style="background-color:lightcyan;"><b>all groups in this column are isomorphic<br/>to each other</b></td>
  <td class="cell" style="background-color:lightcyan;"><b>all groups in this column are isomorphic<br/>to each other</b></td>
 </tr>
 <tr> 
  <td class="cell">\Z/%n\Z</td>
  <td class="cell">\Z/%m\Z</td>
 </tr>
 <tr> 
  <td class="cell">closure({1}, \oplus_%n) &nbsp;&nbsp;=&nbsp;&nbsp; {0,...,%n-1}</td>
  <td class="cell">closure({1}, \oplus_%m) &nbsp;&nbsp;=&nbsp;&nbsp; {0,...,%m-1}</td>
 </tr>
 <tr> 
  <td class="cell" style="background-color:lightcyan;">
    <b>by <a href="#bezout-identity">B&eacute;zout's identity</a>, \exists %s \in \N, %t \in \N s.t.</b>
\begin{eqnarray}
  %s \cdot %n + %t \cdot %m & = & 1 \\
  %t \cdot %m & \equiv & 1 \mod %n \\
  1 & \in & closure({%m}, \oplus_%n) \\
  closure({1}, \oplus_%n) & \subset & closure({%m}, \oplus_%n) \\
  closure({%m}, \oplus_%n) & \subset & closure({1}, \oplus_%n) \\
  closure({%m}, \oplus_%n) & = & closure({1}, \oplus_%n) \\
  closure({%m}, \oplus_%n) & = & \Z/%n\Z
\end{eqnarray}
  </td>
  <td class="cell" style="background-color:lightcyan;">
    <b>by <a href="#bezout-identity">B&eacute;zout's identity</a>, \exists %s \in \N, %t \in \N s.t.</b>
\begin{eqnarray}
  %s \cdot %n + %t \cdot %m & = & 1 \\
  %s \cdot %n & \equiv & 1 \mod %m \\
  1 & \in & closure({%n}, \oplus_%m) \\
  closure({1}, \oplus_%m) & \subset & closure({%n}, \oplus_%m) \\
  closure({%n}, \oplus_%m) & \subset & closure({1}, \oplus_%m) \\
  closure({%n}, \oplus_%m) & = & closure({1}, \oplus_%m) \\
  closure({%n}, \oplus_%m) & = & \Z/%m\Z
\end{eqnarray}
  </td>
 </tr>
 <tr>
  <td class="cell" style="background-color:lightcyan;">
    <b>notice that %t is the inverse of %m in \Z/%n\Z,<br/> and for %a \in \Z/%n\Z:</b>
\begin{eqnarray}
  %t \cdot %m & \equiv & 1 (\mod %n) \\
  %a \cdot (%t \cdot %m) & \equiv & %a (\mod %n)
\end{eqnarray}
  </td>
  <td class="cell" style="background-color:lightcyan;">
    <b>notice that %s is the inverse of %n in \Z/%m\Z,<br/> and for %b \in \Z/%m\Z:</b>
\begin{eqnarray}
  %s \cdot %n & \equiv & 1 (\mod %m) \\
  %b \cdot (%s \cdot %n) & \equiv & %b (\mod %m)
\end{eqnarray}
  </td>
 </tr>
 <tr>
  <td class="cell" colspan="2" style="text-align:center; background-color:lightcyan;">
    <b>notice that for %a \in \Z/%n\Z, %b \in \Z/%m\Z:</b>
\begin{eqnarray}
  %a \cdot (%t \cdot %m) &nbsp;&nbsp;\oplus&nbsp;&nbsp; %b \cdot (%s \cdot %n) &nbsp;&nbsp;&nbsp; & \equiv & &nbsp;&nbsp;&nbsp; %a (\mod %n) \\
  %a \cdot (%t \cdot %m) &nbsp;&nbsp;\oplus&nbsp;&nbsp; %b \cdot (%s \cdot %n) &nbsp;&nbsp;&nbsp; & \equiv & &nbsp;&nbsp;&nbsp; %b (\mod %m) \\
  (%a \cdot %t) \cdot %m &nbsp;&nbsp;\oplus&nbsp;&nbsp; (%b \cdot %s) \cdot %n &nbsp;&nbsp;&nbsp; & \equiv & &nbsp;&nbsp;&nbsp; %x (\mod (%n \cdot %m))
\end{eqnarray}
  <b>notice that if %n and %m are fixed, so are %t and %s;
  <br/>then, %x changes only based on %a \in \Z/%n\Z and %b \in \Z/%m\Z; there are %n \cdot %m possible pairs (%a,%b);<br/>
  are there %n \cdot %m distinct solutions, one for each pair?</b>
  </td>
 </tr>
 <tr> 
  <td class="cell">closure({%m}, \oplus_%n) &nbsp;&nbsp;=&nbsp;&nbsp; {0,...,%n-1}</td>
  <td class="cell">closure({%n}, \oplus_%m) &nbsp;&nbsp;=&nbsp;&nbsp; {0,...,%m-1}</td>
 </tr>
 <tr> 
  <td class="cell">
    closure({%m}, \oplus_{%n \cdot %m}) <br/>&nbsp;&nbsp;=&nbsp;&nbsp; {0 \cdot %m, &nbsp;&nbsp;1 \cdot %m, &nbsp;&nbsp;2 \cdot %m, ... ,&nbsp;&nbsp;(%n-1) \cdot %m}
  </td>
  <td class="cell">
    closure({%n}, \oplus_{%n \cdot %m}) <br/>&nbsp;&nbsp;=&nbsp;&nbsp; {0 \cdot %n, &nbsp;&nbsp;1 \cdot %n, &nbsp;&nbsp;2 \cdot %n, ... ,&nbsp;&nbsp;(%m-1) \cdot %n}
  </td>
 </tr>
 <tr>
  <td class="cell" colspan="2" style="text-align:center; background-color:lightcyan;">
    <b>take the product of the above two groups;<br/>all the following groups are isomorphic</b>
  </td>
 </tr>
 <tr> 
  <td class="cell" colspan="2" style="text-align:center;">
     \Z/%n\Z &nbsp;&nbsp;\times&nbsp;&nbsp; \Z/%m\Z
  </td>
 </tr> 
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">
    closure({%m}, \oplus_%n) &nbsp;&nbsp;\times&nbsp;&nbsp; closure({%n}, \oplus_%m)
  </td>
 </tr> 
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">
    closure({%m}, \oplus_{%m \cdot %n}) &nbsp;&nbsp;\times&nbsp;&nbsp; closure({%n}, \oplus_{%n \cdot %m})
  </td>
 </tr> 
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">
    {0 \cdot %m, &nbsp;&nbsp;1 \cdot %m, &nbsp;&nbsp;2 \cdot %m, ... ,&nbsp;&nbsp;(%n-1) \cdot %m} &nbsp;&nbsp;\times&nbsp;&nbsp; {0 \cdot %n, &nbsp;&nbsp;1 \cdot %n, &nbsp;&nbsp;2 \cdot %n, ... ,&nbsp;&nbsp;(%m-1) \cdot %n}
  </td>
 </tr>
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">
    {%i \cdot %m | %i \in {0,...,%n-1}} &nbsp;&nbsp;\times&nbsp;&nbsp; {%j \cdot %n | %j \in {0,...,%m-1}}
  </td>
 </tr>
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">
    {(%i \cdot %m, &nbsp; %j \cdot %n) &nbsp;|&nbsp; %i \in {0,...,%n-1}, %j \in {0,...,%m-1}}
  </td>
 </tr>
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">
    {%i \cdot %m \oplus &nbsp; %j \cdot %n &nbsp;|&nbsp; %i \in {0,...,%n-1}, %j \in {0,...,%m-1}}
  </td>
 </tr>
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">
    closure({%m,%n}, \oplus_{%n \cdot %m})
  </td>
 </tr>
 <tr>
  <td class="cell" colspan="2" style="background-color:lightcyan;">
    <b>by <a href="#bezout-identity">B&eacute;zout's identity</a>, \exists %s,%t \in \N s.t.</b>
\begin{eqnarray}
  %s \cdot %n + %t \cdot %m & = & 1 \\
  %s \cdot %n + %t \cdot %m & \equiv & 1 \mod (%n \cdot %m) \\
  1 & \in & closure({%n,%m}, \oplus_{%n \cdot %m}) \\
  closure({1}, \oplus_{%n \cdot %m}) & \subset & closure({%n,%m}, \oplus_{%n \cdot %m}) \\
  closure({%n,%m}, \oplus_{%n \cdot %m}) & \subset & closure({1}, \oplus_{%n \cdot %m}) \\
  closure({%n,%m}, \oplus_{%n \cdot %m}) & = & closure({1}, \oplus_{%n \cdot %m}) \\
  closure({%n,%m}, \oplus_{%n \cdot %m}) & = & \Z/(%n \cdot %m)\Z
\end{eqnarray}
  </td>
 </tr>
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">
    \Z/(%n \cdot %m)\Z
  </td>
 </tr>
</table>

For purposes of illustration, we instantiate the above table using %n = 3 and %m = 5.

<table class="fig_table2">
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">3 \in \N, 5 \in \N<br/>\gcd(3,5) = 1<br/>\oplus_%k represents integer addition modulo %k</td>
 </tr>
 <tr> 
  <td class="cell" style="background-color:lightcyan;"><b>all groups in this column are isomorphic<br/>to each other</b></td>
  <td class="cell" style="background-color:lightcyan;"><b>all groups in this column are isomorphic<br/>to each other</b></td>
 </tr>
 <tr> 
  <td class="cell">\Z/3\Z</td>
  <td class="cell">\Z/5\Z</td>
 </tr>
 <tr> 
  <td class="cell">closure({1}, \oplus_3) &nbsp;&nbsp;=&nbsp;&nbsp; {0,1,2}</td>
  <td class="cell">closure({1}, \oplus_5) &nbsp;&nbsp;=&nbsp;&nbsp; {0,1,2,3,4}</td>
 </tr>
 <tr> 
  <td class="cell" style="background-color:lightcyan;">
    <b>by <a href="#bezout-identity">B&eacute;zout's identity</a>,
\begin{eqnarray}
  (-1) \cdot 5 + 2 \cdot 3 & = & 1 \\
  (-1) \cdot 5 & \equiv & 1 \mod 3 \\
  2 \cdot 5 & \equiv & 1 \mod 3 \\
  1 & \in & closure({5}, \oplus_3) \\
  closure({1}, \oplus_3) & \subset & closure({5}, \oplus_3) \\
  closure({5}, \oplus_3) & \subset & closure({1}, \oplus_3) \\
  closure({5}, \oplus_3) & = & closure({1}, \oplus_3) \\
  closure({5}, \oplus_3) & = & \Z/3\Z
\end{eqnarray}
  </td>
  <td class="cell" style="background-color:lightcyan;">
    <b>by <a href="#bezout-identity">B&eacute;zout's identity</a>,
\begin{eqnarray}
  2 \cdot 3 + (-1) \cdot 5 & = & 1 \\
  2 \cdot 3 & \equiv & 1 \mod 5 \\
  1 & \in & closure({3}, \oplus_5) \\
  closure({1}, \oplus_5) & \subset & closure({3}, \oplus_5) \\
  closure({3}, \oplus_5) & \subset & closure({1}, \oplus_5) \\
  closure({3}, \oplus_5) & = & closure({1}, \oplus_5) \\
  closure({3}, \oplus_5) & = & \Z/5\Z
\end{eqnarray}
  </td>
 </tr>
 <tr> 
  <td class="cell">closure({5}, \oplus_3) &nbsp;&nbsp;=&nbsp;&nbsp; {0,1,2}</td>
  <td class="cell">closure({3}, \oplus_5) &nbsp;&nbsp;=&nbsp;&nbsp; {0,1,2,3,4}</td>
 </tr>
 <tr> 
  <td class="cell">
    closure({5}, \oplus_{15}) &nbsp;&nbsp;=&nbsp;&nbsp; {0, 5, 10}
  </td>
  <td class="cell">
    closure({3}, \oplus_{15}) &nbsp;&nbsp;=&nbsp;&nbsp; {0, 3, 6, 9, 12}
  </td>
 </tr>
 <tr>
  <td class="cell" colspan="2" style="text-align:center; background-color:lightcyan;">
    <b>take the product of the above two groups;<br/>all the following groups are isomorphic</b>
  </td>
 </tr>
 <tr> 
  <td class="cell" colspan="2" style="text-align:center;">
     \Z/3\Z &nbsp;&nbsp;\times&nbsp;&nbsp; \Z/5\Z
  </td>
 </tr> 
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">
    closure({5}, \oplus_3) &nbsp;&nbsp;\times&nbsp;&nbsp; closure({3}, \oplus_5)
  </td>
 </tr> 
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">
    closure({5}, \oplus_{15}) &nbsp;&nbsp;\times&nbsp;&nbsp; closure({3}, \oplus_{15})
  </td>
 </tr> 
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">
    {0, 5, 10} &nbsp;&nbsp;\times&nbsp;&nbsp; {0, 3, 6, 9, 12}
  </td>
 </tr>
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">
    {(0,0),&nbsp; (0,3),&nbsp; (0,6),&nbsp; (0,9),&nbsp; (0,12),&nbsp; 
     (5,0),&nbsp; (5,3),&nbsp; (5,6),&nbsp; (5,9),&nbsp; (5,12),&nbsp; 
     (10,0),&nbsp; (10,3),&nbsp; (10,6),&nbsp; (10,9),&nbsp; (10,12) }
  </td>
 </tr>
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">
    {0 \oplus 0,&nbsp; 0 \oplus 3,&nbsp; 0 \oplus 6,&nbsp; 0 \oplus 9,&nbsp; 0 \oplus 12,&nbsp; 
     5 \oplus 0,&nbsp; 5 \oplus 3,&nbsp; 5 \oplus 6,&nbsp; 5 \oplus 9,&nbsp; 5 \oplus 12,&nbsp; 
     10 \oplus 0,&nbsp; 10 \oplus 3,&nbsp; 10 \oplus 6,&nbsp; 10 \oplus 9,&nbsp; 10 \oplus 12 }
  </td>
 </tr>
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">
    {0,&nbsp; 3,&nbsp; 6,&nbsp; 9,&nbsp; 12,&nbsp; 
     5,&nbsp; 8,&nbsp; 11,&nbsp; 14,&nbsp; 2,&nbsp; 
     10,&nbsp; 13,&nbsp; 1,&nbsp; 4,&nbsp; 7 }
  </td>
 </tr>
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">
    \Z/15\Z
  </td>
 </tr>
</table>

<a name="lecture23"></a>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> Suppose that %n \in \N, %g \in {0,...,%n-1}, %g|%n, and \oplus_%k represents integer addition modulo %k. Then we have that:
\begin{eqnarray}
  closure({1},\oplus_{%n/%g}) & \cong & closure({%g},\oplus_%n)
\end{eqnarray}
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> Suppose that %n,%m \in \N are such that \gcd(%n,%m) = 1. Then for any %x \in \Z/(%n \cdot %m)\Z there exists only one
unique pair (%a,%b) \in \Z/%n\Z \times \Z/%m\Z such that:
\begin{eqnarray}
  %b \cdot %n + %a \cdot %m \equiv %x (\mod \Z/(%n \cdot %m)\Z)
\end{eqnarray}
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> Suppose that %n,%m \in \N are such that \gcd(%n,%m) = %g. Then we know that there exist %s and %t such that:
\begin{eqnarray}
  %s \cdot %n + %t \cdot %m & = & %g \\
  %s \cdot %n + %t \cdot %m & \equiv & %g (\mod \Z/(%n \cdot %m)\Z) \\
  closure({%m,%n}, \oplus_{%n \cdot %m}) & = & closure({%g}, \oplus_{%n \cdot %m}) \\
                                         & = & {%i \cdot %g | %i \in {0 ,..., ((%n \cdot %m) / %g)-1}}
\end{eqnarray}
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact:</b> Suppose that %a,%n \in \N are such that \gcd(%a,%n) = 1. Then we know that there exists a unique solution %x \in \Z/%n\Z
to the equation:
\begin{eqnarray}
  %a \cdot %x & \equiv & %b (\mod %n)
\end{eqnarray}
We can compute this solution because %a^{-1} \in \Z/%n\Z exists:
\begin{eqnarray}
  %a \cdot %x & \equiv & %b (\mod %n) \\
  %a^{-1} \cdot (%a \cdot %x) & \equiv & (%a^{-1} \cdot %b) (\mod %n) \\
  %x & \equiv & (%a^{-1} \cdot %b) (\mod %n)
\end{eqnarray}
</div>

<a name="simplify-equation-mod"></a>
<div class="mathenv fact proposition_to_know">
<b>Fact (linear congruence theorem):</b> Suppose that %a,%n \in \N are such that \gcd(%a,%n) = %g. Then, if %g | %b, there exists a unique solution %x \in \Z/(%n/%g)\Z
to the equation:
\begin{eqnarray}
  %a \cdot %x & \equiv & %b (\mod %n)
\end{eqnarray}
We can compute this solution by first dividing %b and %a by %g, and then computing (%a/%g)^{-1} \in \Z/(%n/%g)\Z because \gcd(%a/%g,%n/%g) = 1:
\begin{eqnarray}
  %a \cdot %x & \equiv & %b (\mod %n) \\
  %a \cdot %x - %n \cdot %k & = & %b \\
  (%a \cdot %x - %n \cdot %k)/%g & = & %b/%g \\
  (%a/%g) \cdot %x - (%n/%g) \cdot %k & = & %b/%g \\
  (%a/%g) \cdot %x & \equiv & %b/%g (\mod (%n/%g)) \\
  (%a/%g)^{-1} \cdot ((%a/%g) \cdot %x) & \equiv & (%a^{-1} \cdot (%b/%g)) (\mod (%n/%g)) \\
  %x & \equiv & ((%a/%g)^{-1} \cdot (%b/%g)) (\mod (%n/%g))
\end{eqnarray}
Note that we are using the fact that closure({1},\oplus_{%n/%g}) \cong closure({%g},\oplus_%n).
</div>

<div class="mathenv fact proposition_to_know">
<b>Fact (generalized Chinese remainder theorem):</b>
Suppose that %a,%n,%b,%m \in \N are such that \gcd(%n,%m) = %g, %g | %b, %g | %a, and we have the following system of equations:
\begin{eqnarray}
  %x & \equiv & %a (\mod %n) \\
  %x & \equiv & %b (\mod %m)
\end{eqnarray}
We can rewrite the above system using the fact that
closure({1},\oplus_{%n/%g}) \cong closure({%g},\oplus_%n), 
closure({1},\oplus_{%m/%g}) \cong closure({%g},\oplus_%m),
and \gcd(%m/%g, %n/%g) = 1. Then there exists a unique
solution %x' \in \Z/((%n \cdot %m)/(%g^2))\Z to the system of equations:
\begin{eqnarray}
  %x' & \equiv & (%a/%g) (\mod (%n/%g)) \\
  %x' & \equiv & (%b/%g) (\mod (%m/%g))
\end{eqnarray}
The above system of equations can now be solved using the <a href="#chinese-remainder-theorem">Chinese remainder theorem</a>
formula for the case in which the moduli are coprime. 
<b style="color:firebrick;">The unique solution %x \in \Z/(%m \cdot %n/%g)\Z can then be reconstructed using %x = %g \cdot %x'.</b>
\begin{eqnarray}
  <b style="color:firebrick;">%x</b> & \equiv & <b style="color:firebrick;">%g \cdot %x'</b>
\end{eqnarray}
</div>

<div class="mathenv fact">
<b>Fact (fully generalized Chinese remainder theorem):</b> <b style="color:firebrick">This fact is not part of the required course material, but is included for those who
may be interested.</b>

Suppose that %a,%n,%b,%m \in \N are such that \gcd(%n,%m) = %g, and %d = %b \mod %g = %a \mod %g, and we have the following system of equations:
\begin{eqnarray}
  %x & \equiv & %a (\mod %n) \\
  %x & \equiv & %b (\mod %m)
\end{eqnarray}
Suppose we subtract %d from both equations to obtain a new system of equations:
\begin{eqnarray}
  %x' & \equiv & (%a-%d) (\mod %n) \\
  %x' & \equiv & (%b-%d) (\mod %m)
\end{eqnarray}
The above system can now be solved using the previous fact, since %g | %a-%d and %g | %b-%d. We can then recover
a solution %x to the original system by adding %d to it:
\begin{eqnarray}
  %x & \equiv & %d + %x'
\end{eqnarray}
</div>

<div class="mathenv example_to_know">
<b>Example:</b> Suppose we make the following simplifications: for every %t years,
<ul>
  <li>when the Earth rovolves around the sun, it travels a circumference of 1 unit, at a rate of 1 \cdot %t (once per year);</li>
  <li>when the asteroid Ceres rovolves around the sun, it travels a circumference of 5 units, at two times the speed of the earth
      (i.e., 2 \cdot %t);</li>
  <li>when the planet Jupiter revolves around the sun, it travels a circumference of 11 units, at three times
      the speed (i.e., 3 \cdot %t) .</li>
</ul>
Suppose that on June 21st, 2000, the Earth, Ceres, and Jupiter all align (i.e., one can draw a straight line through all three).
Next, suppose that it is June 21st of some year between 2000 and 2055.
At this time, there is no alignment. However,
Jupiter aligned with earth on June 21st two years ago, and Ceres
aligned with Earth on June 21st three year ago. What year is it?
</div>

<div class="mathenv example_to_know">
<b>Example:</b> Find at least one solution %x \in \Z/15\Z to the following equation:
\begin{eqnarray}
  5 %x^2 + 3 %x - 2 & \equiv & 0 (\mod 15)
\end{eqnarray}
</div>

We now generalize the above tables for CRT to include the case in which \gcd(%n,%m) > 1.

<table class="fig_table2">
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">%n \in \N, %m \in \N<br/>\gcd(%n,%m) = %g<br/>\oplus_%k represents integer addition modulo %k</td>
 </tr>
 <tr> 
  <td class="cell" style="background-color:lightcyan;"><b>all groups in this column are isomorphic<br/>to each other</b></td>
  <td class="cell" style="background-color:lightcyan;"><b>all groups in this column are isomorphic<br/>to each other</b></td>
 </tr>
 <tr> 
  <td class="cell">\Z/(%n/%g)\Z</td>
  <td class="cell">\Z/(%m/%g)\Z</td>
 </tr>
 <tr> 
  <td class="cell">closure({%g}, \oplus_%n) &nbsp;&nbsp;=&nbsp;&nbsp; {0 \cdot %g, &nbsp;..., &nbsp; ((%n/%g)-1) \cdot %g}</td>
  <td class="cell">closure({%g}, \oplus_%m) &nbsp;&nbsp;=&nbsp;&nbsp; {0 \cdot %g, &nbsp;..., &nbsp; ((%m/%g)-1) \cdot %g}</td>
 </tr>
 <tr> 
  <td class="cell" style="background-color:lightcyan;">
    <b>by <a href="#bezout-identity">B&eacute;zout's identity</a>, \exists %s \in \N, %t \in \N s.t.</b>
\begin{eqnarray}
  %s \cdot %n + %t \cdot %m & = & %g \\
  %t \cdot %m & \equiv & %g \mod %n \\
  %g & \in & closure({%m}, \oplus_%n) \\
  closure({%g}, \oplus_%n) & \subset & closure({%m}, \oplus_%n) \\
  closure({%m}, \oplus_%n) & \subset & closure({%g}, \oplus_%n) \\
  closure({%m}, \oplus_%n) & \cong & closure({%g}, \oplus_%n) \\
                           & \cong & closure({1}, \oplus_{%n/%g}) \\
                           & \cong & \Z/(%n/%g)\Z
\end{eqnarray}
  </td>
  <td class="cell" style="background-color:lightcyan;">
    <b>by <a href="#bezout-identity">B&eacute;zout's identity</a>, \exists %s \in \N, %t \in \N s.t.</b>
\begin{eqnarray}
  %s \cdot %n + %t \cdot %m & = & %g \\
  %s \cdot %n & \equiv & %g \mod %m \\
  %g & \in & closure({%n}, \oplus_%m) \\
  closure({%g}, \oplus_%m) & \subset & closure({%n}, \oplus_%m) \\
  closure({%n}, \oplus_%m) & \subset & closure({%g}, \oplus_%m) \\
  closure({%n}, \oplus_%m) & \cong & closure({%g}, \oplus_%m) \\
                           & \cong & closure({1}, \oplus_{%m/%g}) \\
                           & \cong & \Z/(%m/%g)\Z
\end{eqnarray}
  </td>
 </tr>
 <tr>
  <td class="cell" style="background-color:lightcyan;">
    <b>notice that %t and %m generate %g in \Z/%n\Z,<br/> and for %a \in \Z/(%n/%g)\Z:</b>
\begin{eqnarray}
  %t \cdot %m & \equiv & %g (\mod %n) \\
  %a \cdot (%t \cdot %m) & \equiv & (%a \cdot %g) (\mod %n)
\end{eqnarray}
  </td>
  <td class="cell" style="background-color:lightcyan;">
    <b>notice that %s and %n generaete %g in \Z/%m\Z,<br/> and for %b \in \Z/(%m/%g)\Z:</b>
\begin{eqnarray}
  %s \cdot %n & \equiv & %g (\mod %m) \\
  %b \cdot (%s \cdot %n) & \equiv & (%b \cdot %g) (\mod %m)
\end{eqnarray}
  </td>
 </tr>
 <tr>
  <td class="cell" colspan="2" style="text-align:center; background-color:lightcyan;">
    <b>notice that for %a \in \Z/(%n/%g)\Z, %b \in \Z/(%m/%g)\Z:</b>
\begin{eqnarray}
  %a \cdot (%t \cdot %m) &nbsp;&nbsp;\oplus&nbsp;&nbsp; %b \cdot (%s \cdot %n) &nbsp;&nbsp;&nbsp; & \equiv & &nbsp;&nbsp;&nbsp; (%a \cdot %g) (\mod %n) \\
  %a \cdot (%t \cdot %m) &nbsp;&nbsp;\oplus&nbsp;&nbsp; %b \cdot (%s \cdot %n) &nbsp;&nbsp;&nbsp; & \equiv & &nbsp;&nbsp;&nbsp; (%b \cdot %g) (\mod %m) \\
  (%a \cdot %t) \cdot %m &nbsp;&nbsp;\oplus&nbsp;&nbsp; (%b \cdot %s) \cdot %n &nbsp;&nbsp;&nbsp; & \equiv & &nbsp;&nbsp;&nbsp; (%x' \cdot %g) (\mod (%n \cdot %m))\\
  (%a \cdot %t) \cdot %m &nbsp;&nbsp;\oplus&nbsp;&nbsp; (%b \cdot %s) \cdot %n &nbsp;&nbsp;&nbsp; & \equiv & &nbsp;&nbsp;&nbsp; %x (\mod (%n \cdot %m))
\end{eqnarray}
  <b>notice that if %n and %m are fixed, so are %t and %s;
  <br/>then, %x = %x' \cdot %g changes only based on %a \in \Z/(%n/%g)\Z and %b \in \Z/(%m/%g)\Z;
  <br/>there are (%n/%g) \cdot (%m/%g) possible pairs (%a,%b);<br/>
  are there (%n/%g) \cdot (%m/%g) distinct solutions, one for each pair?</b>
  </td>
 </tr>
 <tr> 
  <td class="cell">closure({%m}, \oplus_%n) &nbsp;&nbsp;=&nbsp;&nbsp; {0 \cdot %g, &nbsp;..., &nbsp; ((%n/%g)-1) \cdot %g}</td>
  <td class="cell">closure({%n}, \oplus_%m) &nbsp;&nbsp;=&nbsp;&nbsp; {0 \cdot %g, &nbsp;..., &nbsp; ((%m/%g)-1) \cdot %g}</td>
 </tr>
 <tr>
  <td class="cell" colspan="2" style="text-align:center; background-color:lightcyan;">
    <b>take the product of the above two groups;<br/>all the following groups are isomorphic</b>
  </td>
 </tr>
 <tr> 
  <td class="cell" colspan="2" style="text-align:center;">
     \Z/(%n/%g)\Z &nbsp;&nbsp;\times&nbsp;&nbsp; \Z/(%m/%g)\Z
  </td>
 </tr> 
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">
    closure({%m/%g}, \oplus_{%n/%g}) &nbsp;&nbsp;\times&nbsp;&nbsp; closure({%n/%g}, \oplus_{%m/%g})
  </td>
 </tr> 
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">
    closure({%m/%g}, \oplus_{%n \cdot %m/%g^2}) &nbsp;&nbsp;\times&nbsp;&nbsp; closure({%n/%g}, \oplus_{%n \cdot %m/%g^2})
  </td>
 </tr>
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">
    {%i \cdot %m/%g | %i \in {0,...,%n/%g-1}} &nbsp;&nbsp;\times&nbsp;&nbsp; {%j \cdot %n/%g | %j \in {0,...,%m/%g-1}}
  </td>
 </tr>
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">
    {(%i \cdot %m/%g, &nbsp; %j \cdot %n/%g) &nbsp;|&nbsp; %i \in {0,...,%n/%g-1}, %j \in {0,...,%m/%g-1}}
  </td>
 </tr>
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">
    {%i \cdot %m/%g \oplus &nbsp; %j \cdot %n/%g &nbsp;|&nbsp; %i \in {0,...,%n/%g-1}, %j \in {0,...,%m/%g-1}}
  </td>
 </tr>
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">
    closure({%m/%g,%n/%g}, \oplus_{%n \cdot %m/%g^2})
  </td>
 </tr>
 <tr>
  <td class="cell" colspan="2" style="background-color:lightcyan;">
    <b>by <a href="#bezout-identity">B&eacute;zout's identity</a>, \exists %s,%t \in \N s.t.</b>
\begin{eqnarray}
  %s \cdot %n + %t \cdot %m & = & %g \\
  %s \cdot %n/%g + %t \cdot %m/%g & = & 1 \\
  %s \cdot %n/%g + %t \cdot %m/%g & \equiv & 1 \mod ({%n \cdot %m/%g^2) \\
  %g & \in & closure({%n,%m}, \oplus_{%n \cdot %m}) \\
  1 & \in & closure({%n/%g,%m/%g}, \oplus_{%n \cdot %m/%g^2}) \\
  closure({1}, \oplus_{%n \cdot %m/%g^2}) & \subset & closure({%n/%g,%m/%g}, \oplus_{%n \cdot %m/%g^2}) \\
  closure({%n/%g,%m/%g}, \oplus_{%n \cdot %m/%g^2}) & \subset & closure({1}, \oplus_{%n \cdot %m/%g^2}) \\
  closure({%n/%g,%m/%g}, \oplus_{%n \cdot %m/%g^2}) & = & closure({1}, \oplus_{%n \cdot %m/%g^2}) \\
  closure({%n/%g,%m/%g}, \oplus_{%n \cdot %m/%g^2}) & = & \Z/(%n \cdot %m/%g^2)\Z
\end{eqnarray}
  </td>
 </tr>
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">
    \Z/(%n \cdot %m/%g^2)\Z
  </td>
 </tr>
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">
    closure({%g},\oplus_{%n \cdot %m/%g})
  </td>
 </tr>
</table>

Given the above, one might observe that, in fact, there are <i>more</i> multiple of %g in \Z/(n \cdot %m)\Z than there
are in \Z/(%n \cdot %m/%g^2)\Z. In fact, there are %g times as many multiples of %g in \Z/(n \cdot %m)\Z.
Thus, each unique pair in \Z/(%n/%g)\Z \times \Z/(%m/%g)\Z determines not one element in \Z/((%n \cdot %m)/%g)\Z,
but %g different elements. So 
if it is not \Z/(%n \cdot %m/%g^2)\Z, then which product group is isomorphic to the set \Z/((%n \cdot %m)/%g)\Z,
the set of multiples of %g modulo %m \cdot %n?

<div class="mathenv fact">
<b>Fact:</b> For %n,%m \in \N and %g = \gcd(%n,%m), it is the case that:
\begin{eqnarray}
  \Z/((%n \cdot %m)/%g)\Z & \cong & \Z/(%n/%g)\Z \times \Z/(%m/%g)\Z \times \Z/%g\Z
\end{eqnarray}
</div>

For purposes of illustration, we instantiate the above table for %g > 1 using %n = 4, %m = 6, and %g = 2.

<table class="fig_table2">
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">4 \in \N, 6 \in \N<br/>\gcd(4,6) = 2<br/>\oplus_%k represents integer addition modulo %k</td>
 </tr>
 <tr> 
  <td class="cell" style="background-color:lightcyan;"><b>all groups in this column are isomorphic<br/>to each other</b></td>
  <td class="cell" style="background-color:lightcyan;"><b>all groups in this column are isomorphic<br/>to each other</b></td>
 </tr>
 <tr> 
  <td class="cell">\Z/4\Z</td>
  <td class="cell">\Z/6\Z</td>
 </tr>
 <tr> 
  <td class="cell">closure({2}, \oplus_4) &nbsp;&nbsp;=&nbsp;&nbsp; {0,2}</td>
  <td class="cell">closure({2}, \oplus_6) &nbsp;&nbsp;=&nbsp;&nbsp; {0,2,4}</td>
 </tr>
 <tr> 
  <td class="cell" style="background-color:lightcyan;">
    <b>by <a href="#bezout-identity">B&eacute;zout's identity</a>,
\begin{eqnarray}
  (1) \cdot 6 + (-1) \cdot 4 & = & 2 \\
  (1) \cdot 6 & \equiv & 2 \mod 4 \\
  2 & \in & closure({6}, \oplus_4) \\
  closure({2}, \oplus_4) & \subset & closure({6}, \oplus_4) \\
  closure({6}, \oplus_4) & \subset & closure({2}, \oplus_4) \\
  closure({6}, \oplus_4) & = & closure({2}, \oplus_4) \\
  closure({2}, \oplus_4) & \cong & {0,2} \\
                         & \cong & \Z/(4/2)\Z \\
                         & \cong & {0,1} \\
                         & \cong & \Z/2\Z
\end{eqnarray}
  </td>
  <td class="cell" style="background-color:lightcyan;">
    <b>by <a href="#bezout-identity">B&eacute;zout's identity</a>,
\begin{eqnarray}
  (-1) \cdot 4 + (1) \cdot 6 & = & 2 \\
  (-1) \cdot 4 & \equiv & 2 \mod 6 \\
  (5) \cdot 4 & \equiv & 2 \mod 6 \\
  2 & \in & closure({4}, \oplus_6) \\
  closure({2}, \oplus_6) & \subset & closure({4}, \oplus_6) \\
  closure({4}, \oplus_6) & \subset & closure({2}, \oplus_6) \\
  closure({4}, \oplus_6) & = & closure({2}, \oplus_6) \\
  closure({2}, \oplus_6) & \cong & {0,2,4} \\
                         & \cong & \Z/(6/2)\Z \\
                         & \cong & {0,1,2} \\
                         & \cong & \Z/3\Z
\end{eqnarray}
  </td>
 </tr>
 <tr> 
  <td class="cell">closure({6}, \oplus_4) &nbsp;&nbsp;=&nbsp;&nbsp; {0,2}</td>
  <td class="cell">closure({4}, \oplus_6) &nbsp;&nbsp;=&nbsp;&nbsp; {0,2,4}</td>
 </tr>
 <tr> 
  <td class="cell">closure({6}, \oplus_4) &nbsp;&nbsp;\cong&nbsp;&nbsp; {0,1}</td>
  <td class="cell">closure({4}, \oplus_6) &nbsp;&nbsp;\cong&nbsp;&nbsp; {0,1,2}</td>
 </tr>
 <tr> 
  <td class="cell">closure({6}, \oplus_4) &nbsp;&nbsp;\cong&nbsp;&nbsp; \Z/2\Z</td>
  <td class="cell">closure({4}, \oplus_6) &nbsp;&nbsp;\cong&nbsp;&nbsp; \Z/3\Z</td>
 </tr>
 <tr>
  <td class="cell" colspan="2" style="text-align:center; background-color:lightcyan;">
    <b>take the product of the above two groups;<br/>all the following groups are isomorphic</b>
  </td>
 </tr>
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">
    closure({6}, \oplus_4) &nbsp;&nbsp;\times&nbsp;&nbsp; closure({4}, \oplus_6)
  </td>
 </tr> 
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">
    {0, 2} &nbsp;&nbsp;\times&nbsp;&nbsp; {0, 2, 4}
  </td>
 </tr>
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">
    {0, 1} &nbsp;&nbsp;\times&nbsp;&nbsp; {0, 1, 2}
  </td>
 </tr>
 <tr> 
  <td class="cell" colspan="2" style="text-align:center;">
     \Z/2\Z &nbsp;&nbsp;\times&nbsp;&nbsp; \Z/3\Z
  </td>
 </tr>
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">
    \Z/((4 \cdot 6)/2^2)\Z
  </td>
 </tr>
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">
    \Z/6\Z
  </td>
 </tr>
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">
    {0,1,2,3,4,5}
  </td>
 </tr>
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">
    {0,2,4,6,8,10}
  </td>
 </tr>
 <tr>
  <td class="cell" colspan="2" style="text-align:center;">
    closure({2}, \oplus_{(4 \cdot 6)/2})
  </td>
 </tr>
</table>



<div class="mathenv example_to_know">
<b>Example:</b> 
Suppose you need to build a wall 60 units long that consists of two layers of bricks (one layer on top of the other).
You are allowed to order bricks of two different lengths %a \in \N and %b \in \N in any quantity. Determine one
possible %a and %b combination that will allow you to build a wall 60 units long such that no seam between two
bricks in the bottom layer coincides with a seam between two bricks in the top layer.
</div>

<div class="mathenv example_to_know">
<b>Example (arithmetic with bounded errors):</b> 
Suppose you need to perform a sequence of %k addition operations in \Z/256\Z, but the addition operator \oplus modulo 256 that you
must use is error-prone. If + represents correct addition over \Z/256\Z, then it is only guaranteed that:
\begin{eqnarray}
  (((%a + %b) \mod 256) - ((%a \oplus %b))) \mod 256 & < & 4
\end{eqnarray}
Use group isomorphisms to construct an addition algorithm that uses \oplus, but is not error-prone.
</div>

<div class="mathenv example_to_know">
<b>Example (arithmetic with unbounded error and bounded unreliability):</b> 
Suppose you need to perform a sequence of %k addition operations in \Z/15\Z, but all the addition operators \oplus modulo %n available to you
are error-prone. To add two numbers %a, %b modulo %n accurately, you must perform the computation %a \oplus %b at least \lceil \log_2 %n \rceil times
(because up to \lceil \log_2 %n \rceil/2 - 1 of those attempts will result in an arbitrarily large error).

This means that to perform %k addition operations modulo 15, it will be necessary to perform every operation \lceil \log_2 15 \rceil = 4 times, for
a total of %k \cdot 4 operations modulo 15. If each addition operation modulo %n takes O((\log_2 %n)^2) steps, this would mean that
%k operations would take:
\begin{eqnarray}
  4 \cdot 4^2 \cdot %k steps
\end{eqnarray}
Assuming that performing CRT to find a solution in \Z/15\Z takes 10,000 steps, determine how you can use CRT to speed up the computation
of these %k addition operations.
</div>

<div class="mathenv example_to_know">
<b>Example:</b> 
Consider the following algebraic structure: %S is the set of all equations of the form %c \cdot %x \equiv %a \mod %n for %c,%a,%n \in \N,
and \oplus is just a concatenation operator that collects equations into systems of equations. That is, given two systems of
equations %s_1, %s_2 \in closure(%S, \oplus) where %s_1 has %n equations and %s_2 has %m equations, %s_1 \oplus %s_2 is a system of %n + %m equations.
Prove by induction that for every system of equations %s \in closure(%S, \oplus), it is possible to either reduce the
system to a single equation of the form %x \equiv %a \mod %n for some %a and %n, or there is no solution to that system %s.
</div>




<!--assignment6-->
<br/><hr/>
<a name="6.9"></a>
<a name="assignment6"></a>
<b>Assignment #6: Generalizing CRT</b>
<!--span class="btn_assignment">(<a href="materials.php?hw=6">show only this assignment</a>)</span-->

  <p>For this assignment, you will submit a single Python source file <code>a6.py</code>.

  <b style="color:firebrick;">Your file may not import any modules or 
  employ any external library functions associated with
  integers and sets (unless the problem statement explicitly permits this). 
  You will be graded on the correctness, concision, and mathematical legibility of your code.
  The different problems and problem parts rely on each other; carefully consider whether you
  can use functions you define in one part within subsequent parts.
  You may reuse functions that you defined on previous assignments.</b>

<ol>
  <li>Implement a function <code>solve()</code> that takes three integer arguments <code>x</code>,
      <code>y</code>, and <code>z</code>. The function should return a tuple containing two integers,
      <code>(a,b)</code>, such that the following always holds:
      <pre class="snippet">(a,b) = solve(x,y,z)
 
(x * a + y * b) % (x*y) == z % (x*y) # True.
a in range(0,y)                      # True.
b in range(0,x)                      # True.</pre>
      If no such pair <code>(a,b)</code> exists, your method should return <code>None</code>.
  </li>
  <li>
    Include the following class declaration in your file. An <code>Eqn()</code> object
    represents an equation of the form %c \cdot %x \equiv %a (\mod %n), where %x is
    a variable.
    <pre class="snippet">class Eqn():
    c = 1
    a = 0
    n = 1
    solvable = True
 
    def __init__(self,c,a,n):
        self.c = c
        self.a = a
        self.n = n
 
    def __repr__(self):
        return str(self)
 
    def __str__(self):
        if not self.solvable:
            return "unsolvable"
        else:
            return str(self.c) + "x = " + str(self.a) + " mod " + str(self.n)
 
    def unsolvable(self):
        self.solvable = False
        self.c = None
        self.a = None
        self.n = None
 
    def simplify(self):
        # Implement for #2, part (a).
        pass 
 
    def __add__(e1, e2):
        
        # Modify this method for #2, part (b).
        # This method should behave like CRT2(),
        # but it should be able to handle all possible
        # cases.
         
        # This function should return another Eqn() 
        # object that represents the solution (or
        # lack thereof) to the two equations e1 and e2.
 
        return None</pre>

    <ol style="list-style-type:lower-alpha; margin-top:6px;">
      <li>
        Implement a member method <code>simplify()</code> that converts an <code>Eqn()</code> object
        into an equivalent one in which %c = 1, if possible <b style="color:firebrick;">(as determined by <a href="#simplify-equation-mod">this fact</a>)</b>. If this is not possible, the method should set the object's
        <code>self.solvable</code> field to <code>False</code> (use the member method <code>unsolvable()</code>).
        <b style="color:firebrick;">Some test cases are provided below.</b>
        <pre class="snippet">&gt;&gt;&gt; x = Eqn(6,4,8)
&gt;&gt;&gt; x
6x = 4 mod 8
&gt;&gt;&gt; x.simplify()
&gt;&gt;&gt; x
1x = 2 mod 4
 
&gt;&gt;&gt; Eqn(1,2,7)
1x = 2 mod 7
 
&gt;&gt;&gt; Eqn(3,4,5)
3x = 4 mod 5
 
&gt;&gt;&gt; x = Eqn(5,5,100)
&gt;&gt;&gt; x.simplify()
&gt;&gt;&gt; x
1x = 1 mod 20
 
&gt;&gt;&gt; x = Eqn(7,1,7)
&gt;&gt;&gt; x.simplify()
&gt;&gt;&gt; x
unsolvable
 
&gt;&gt;&gt; x = Eqn(7,0,7)
&gt;&gt;&gt; x.simplify()
&gt;&gt;&gt; x
1x = 0 mod 1
 
&gt;&gt;&gt; x = Eqn(15,5,25)
&gt;&gt;&gt; x.simplify()
&gt;&gt;&gt; x
1x = 2 mod 5
 
&gt;&gt;&gt; x = Eqn(3,5,6)
&gt;&gt;&gt; x.simplify()
&gt;&gt;&gt; x
unsolvable
        </pre>
      </li>
      <li>
        Implement a member method <code>__add__(e1, e2)</code>. This method should take two
        <code>Eqn()</code> objects as arguments. It should return a new <code>Eqn()</code> object
        that represents a solution to the two equations, if one exists (otherwise, the <b style="color:firebrick;">returned object</b> should
        have its <code>self.solvable</code> field set to <code>False</code>). That is, the input represents the following system of
        equations:
\begin{eqnarray}
  %c_1 \cdot %x & \equiv & %a_1 (\mod %n_1)\\
  %c_2 \cdot %x & \equiv & %a_2 (\mod %n_2)\\
\end{eqnarray}
        The method should return the unique solution if it exists in the form of an equation object where
        %c = 1, and where %a and %n are chosen appropriately:
\begin{eqnarray}
  1 \cdot %x & \equiv & %a (\mod %n)
\end{eqnarray}
        If no solution exists, the returned <code>Eqn()</code> object should have its <code>unsolvable</code> field set to <code>True</code>.
        Your method should be similar to <code>CRT2()</code>, but it must handle all possible inputs correctly (i.e., the <code>n</code>
        values of the two equations are not necessarily coprime, and <code>c</code> may be any integer). <b style="color:firebrick;">
        Solutions that use an exhaustive search will receive no credit.</b>
        <b style="color:firebrick;">Some test cases are provided below.</b>
        <pre class="snippet">&gt;&gt;&gt; Eqn(1,3,15) + Eqn(1,6,21)
1x = 48 mod 105
 
&gt;&gt;&gt; Eqn(1,3,15) + Eqn(1,6,21) + Eqn(2,12,18)
1x = 258 mod 315
 
&gt;&gt;&gt; Eqn(1,2,15) + Eqn(1,4,21)
unsolvable
 
&gt;&gt;&gt; Eqn(1,7,8) + Eqn(1,0,1)
1x = 7 mod 8
        </pre>
      </li>  
    </ol>
  </li>

  <li style="margin-bottom:10px;"> 
    Consider the algebraic structure consisting of all possible equations of the form <code>Eqn(c,a,n)</code> where <code>c</code>,
    <code>a</code>, and <code>n</code> are integers. The operator for this algebraic structure is 
    the <code>+</code> operator (defined by <code>__add__()</code>).
    Determine all the algebraic properties of this algebraic structure, and determine which algebraic structure it is.
    <b style="color:firebrick;">If an identity and/or inverses exist, you must describe which elements they are or how to find them.</b>
  </li>

  <li style="margin-bottom:10px;"> 
    Define a Python function <code>GCRTN()</code> (<b style="color:firebrick;">not a member method of <code>Eqn()</code></b>)
    that takes one input, which is a list of one or more <code>Eqn()</code> objects. This list represents a system of equations of
    the following form:
\begin{eqnarray}
  %c_1 \cdot %x & \equiv & %a_1 (\mod %n_1)\\
     & \vdots & \\
  %c_%k \cdot %x & \equiv & %a_%k (\mod %n_%k)
\end{eqnarray}
        The method should return the unique solution in the form of a single <code>Eqn()</code> object where
        %c = 1, and where %a and %n are chosen appropriately:
\begin{eqnarray}
  1 \cdot %x & \equiv & %a (\mod %n)
\end{eqnarray}
        If there is no solution, the return <code>Eqn()</code> object should indicate this.
        <b style="color:firebrick;">You may not violate the encapsulation of the <code>Eqn()</code> objects. You may only
        use member methods to create, modify, or combine <code>Eqn()</code> objects.</b>
  </li>
</ol>
<hr/><br/>
<!--/assignment6-->



<a name="lecture25"></a>
<a name="8"></a>
<!--<hr style="margin-bottom:80px;"/>-->
<h2>Review #2</h2>

This section contains a comprehensive collection of review problems going over all the course
material. These problems are an accurate representation of the kinds of problems you may see on an exam.

<div class="mathenv">
<b>Problem:</b> Suppose that %n \in \N. Compute the following:
\begin{eqnarray}
  5<sup>3<sup>4 \cdot %n + 1</sup></sup> \mod 11
\end{eqnarray}

<solution>
We can compute the exponent 3<sup>4 \cdot %n + 1</sup> modulo \phi(11) by Euler's theorem, because \gcd(5,11) = 1.
Likewise, we can compute the exponent within the exponent, 4 \cdot %n + 1, modulo \phi(\phi(11)) because \gcd(3,\phi(11)) = 1.
Thus, we have:
\begin{eqnarray}
  \phi(11) & = & 11 - 1 \\
           & = & 10 \\
  \phi(10) & = & \phi(5) \cdot \phi(2) \\
           & = & (5-1) \cdot (2-1) \\
           & = & 4 \\
  5<sup>3<sup>4 \cdot %n + 1</sup></sup> \mod 11 
     & = & 5<sup>3<sup>4 \cdot %n + 1 \mod \phi(\phi(11))</sup> \mod \phi(11)</sup> \mod 11 \\
     & = & 5<sup>3<sup>4 \cdot %n + 1 \mod 4</sup> \mod 10</sup> \mod 11 \\
     & = & 5<sup>3<sup>1</sup> \mod 10</sup> \mod 11 \\
     & = & 5<sup>3</sup> \mod 11 \\
     & = & (25 \cdot 5) \mod 11 \\
     & = & (3 \cdot 5) \mod 11 \\
     & = & 15 \mod 11 \\
     & = & 4 \mod 11
\end{eqnarray}
</solution>
</div>

<div class="mathenv">
<b>Problem:</b> Find all %x \in \Z/29\Z that satisfy the following:
\begin{eqnarray}
  %y^2 & \equiv & 16 (\mod 29) \\
  %x^2 & \equiv & %y (\mod 29)
\end{eqnarray}

<solution>
We first solve for all possible %y. Since 29 > 16, we have that \pm 4 are the square roots of 16 in \Z/29\Z. Thus,
we have two solutions for %y:
\begin{eqnarray}
  %y & \in & {4, 29-4} \\
  %y & \in & {4, 25}
\end{eqnarray}
We want to find all %x that satisfy the system, so we need to solve for %x for each possible %y. Thus, we have:
\begin{eqnarray}
  %y   & \equiv & 4 (\mod 29) \\
  %x^2 & \equiv & 4 (\mod 29) \\
  %x   & \equiv & \pm 2 (\mod 29) \\
  %x   & \in & {2, 29-2} \\
  %x   & \in & {2, 27}
\end{eqnarray}
We also have:
\begin{eqnarray}
  %y   & \equiv & 25 (\mod 29) \\
  %x^2 & \equiv & 25 (\mod 29) \\
  %x   & \equiv & \pm 5 (\mod 29) \\
  %x   & \in & {5, 29-5}\\
  %x   & \in & {5, 24}
\end{eqnarray}
Thus, the possible solutions for %x are:
\begin{eqnarray}
  %x   & \in & {2, 5, 24, 27}
\end{eqnarray}
Notice also that the problem could have been stated as:
\begin{eqnarray}
  %x^4 & \equiv & 16 (\mod 29)
\end{eqnarray}
</solution>
</div>

<div class="mathenv">
<b>Problem:</b> Determine which properties the following algebraic structures satisfy:
<ol style="list-style-type:lower-alpha;">
  <li>generating set {\emptyset, {1}, {2}, {3}} with the union operation \cup
    <solution>
      The closure is the set of subsets of {1,2,3}:
\begin{eqnarray}
  {\emptyset, {1}, {2}, {3}, {1,2}, {2,3}, {1,3}, {1,2,3}}
\end{eqnarray}
      The union operation is associative and commutative. There is an identity \emptyset.
      There are no inverses.
    </solution>
  </li>
  <li>for %a,%n \in \N, %a > 1, %n > 1, and \gcd(%a,%n) = 1, generating set {%a} with integer addition modulo %n
    <solution>
      The closure is the entire set {0,...,%n-1} because:
\begin{eqnarray}
  {%a, %a+%a, %a+%a+%a, ..., %a+...+%a} & = & {(%i \cdot %a) \mod %n | %i \in {1,...,%n}}
\end{eqnarray}
      Integer addition modulo %n is associative and commutative, has identity 0, and for every %x \in \Z/%n\Z,
      the inverse is %n-%x \in \Z/%n\Z.
    </solution>
  </li>
</ol>
</div>

<div class="mathenv">
<b>Problem:</b> Consider the following algebraic structure %A: the generating set is {%a, %b, %c}, the
operator \oplus is associative and commutative, has an identity %c, and there are inverses where %a^{-1} = %b
and %c^{-1} = %c. Find all double cosets of %A, and describe what elements of %A are inside them.

<solution>
We first determine what are the elements of the set %A. Since %a \oplus %b = %c and \oplus is associative and commutative, in
any expression that contains both some number of %a generators and %b generators, either all of the %a generators will cancel (if there are
more %b generators), or all of the %b generators will cancel (if there are more %a generators). If the number of %a and %b generators is the
same, then the result will be %c.
\begin{eqnarray}
  %a \oplus %a \oplus %b & = & %a \oplus %c \\
                         & = & %a \\
  %b \oplus %b \oplus %a \oplus %b & = &  %a \oplus %b \oplus %b \oplus %b\\
                                             & = &  (%a \oplus %b) \oplus %b \oplus %b\\
                                             & = &  %c \oplus %b \oplus %b\\
                                             & = &  %b \oplus %b
\end{eqnarray}
Thus, the distinct elements in %A are all sequences of only %a, all sequences of only %b, and %c:
\begin{eqnarray}
  %A & = & {%c, %a, %b, %a \oplus %a, %b \oplus %b, %a \oplus %a \oplus %a, %b \oplus %b \oplus %b, ... }
\end{eqnarray}
Now, let us consider the coset for each possible element in %x \in %A:
\begin{eqnarray}
  %A%x%A & = & {%u \oplus %x \oplus %v | %u \in %A, %v \in %A }
\end{eqnarray}
If %x = %c, then %A%x%A = %A. If %x = %a, then %b \oplus %a \oplus %v \in %A%x%A, and since %v ranges over all elements in %A, %A%a%A.
This is true for any sequence %a, %a \oplus %a, %a \oplus %a \oplus %a, and so on. The same argument applies to %b, %b \oplus %b, %b \oplus %b \oplus %b,
and so on. Thus:
\begin{eqnarray}
  %A%c%A & = & %A \\
  %A%a%A & = & %A \\
  %A%b%A & = & %A \\
  %A(%a \oplus %a)A & = & %A \\
  %A(%b \oplus %b)A & = & %A \\
         & \vdots & 
\end{eqnarray}
Thus, there is only one distinct coset of %A, and it is %A.
</solution>
</div>

<div class="mathenv">
<b>Problem:</b> Prove the following formula is true for all %n \in \N using induction over \N:
\begin{eqnarray}
  %P(%n) & = & %n < 25 or 5^{%n} > %n^{10}
\end{eqnarray}
<b style="color:firebrick">Solving this problem requires at least some familiarity with the coefficients of a
binomial expansion of the form (%k+1)^{10}. You are not responsible for this portion of the solution.
However, you should understand how the axiom of induction for \N is applied to this problem.</b>

<solution>
To prove that for all %n \in \N, %P(n) is true, we need to apply the axiom of induction for \N. Thus, we must show that
%P(0) and that for all %k \in \N, %P(%k) implies %P(%k+1).

We know that %P(0) is true because 0 < 25; in fact, we know that %P(1),...,%P(24) are true for that reason, and treat them as base cases.
Thus, we have the %n = 25 base case left to check:
\begin{eqnarray}
  5^{25} & > & 25^{10} \\
  5^{25} & > & (5^2)^{10} \\
  5^{25} & > & 5^{20} \\
\end{eqnarray}
Next, we assume our induction hypothesis: suppose %P(%k) is true. We can also assume that %k > 25, since we checked all cases where
%k \leq 25. Then we have that:
\begin{eqnarray}
  5^{%k}         & > & %k^{10}  \\
  4 \cdot 5^{%k} & > & 4 \cdot %k^{10}    \\
                 & > & 4 \cdot (25 \cdot %k^9)\\
                 & > & 100 \cdot %k^9   
\end{eqnarray}
We now add 5^{%k} to the left-hand side of the above, and we add %k^{10} to the right-hand side.
\begin{eqnarray}
  5^{%k}                    & > & %k^{10} \\
  5^{%k} + (4 \cdot 5^{%k}) & > & %k^{10} + (100 \cdot %k^9) \\
  5^{%k+1} & > & %k^{10} + 100 \cdot %k^9
\end{eqnarray}
Notice that because %k > 25:
\begin{eqnarray}
  10 \cdot %k^9 & > & 10 \cdot 25 \cdot %k^8 \\
  10 \cdot %k^9 & > & 10 \cdot 25^2 \cdot %k^7 \\
  10 \cdot %k^9 & > & 10 \cdot 25^3 \cdot %k^6 \\
  10 \cdot %k^9 & > & 10 \cdot 25^4 \cdot %k^5 \\
  10 \cdot %k^9 & > & 10 \cdot 25^5 \cdot %k^4 \\
  10 \cdot %k^9 & > & 10 \cdot 25^6 \cdot %k^3 \\
  10 \cdot %k^9 & > & 10 \cdot 25^7 \cdot %k^2 \\
  10 \cdot %k^9 & > & 10 \cdot 25^8 \cdot %k^1 \\
  10 \cdot %k^9 & > & 1
\end{eqnarray}
The above shows that %k^{10} + 10 \cdot %k^9 + 90 \cdot %k^9 greatly exceeds the expansion of (%k+1)^{10}.
We also know that the first term of the expansion of (%k+1)^{10}, %k^{10}, has coefficient 1. Thus, we derive
our result:
\begin{eqnarray}
  5^{%k+1} & > & %k^{10} + 10 \cdot %k^9 + 90 \cdot %k^9 \\
           & > & (%k + 1)^{10}
\end{eqnarray}
</solution>
</div>

<div class="mathenv">
<b>Problem:</b> Prove the following formula is true for all %n \in \N using induction over \N:
\begin{eqnarray}
  %P(%n) & = & %n < 5 or 2^{%n} > %n^2
\end{eqnarray}

<solution>
To prove that for all %n \in \N, %P(n) is true, we need to apply the axiom of induction for \N. Thus, we must show that
%P(0) and that for all %k \in \N, %P(%k) implies %P(%k+1).

We know that %P(0) is true because 0 < 5; in fact, we know that %P(1),...,%P(4) are true for that reason, and treat them as base cases.
Thus, we have the %n = 5 base case left to check:
\begin{eqnarray}
  2^5 & > & 5^2 \\
  32 & > & 25
\end{eqnarray}
Next, we assume our induction hypothesis: suppose %P(%k) is true. We can also assume that %k > 5, since we checked all cases where
%k \leq 5. Then, since %k > 5, we have that %k^2 > 2 \cdot %k + 1, so:
\begin{eqnarray}
  2^{%k}         & > & %k^2  \\
  2 \cdot (2^{%k}) & > & 2 \cdot %k^2 \\
                   & > & %k^2 + %k^2 \\
                   & > & %k^2 + 2 \cdot %k + 1 \\
                   & > & (%k + 1)^2 \\
          2^{%k+1} & > & (%k + 1)^2
\end{eqnarray}
</solution>
</div>

<div class="mathenv">
<b>Problem:</b> Suppose we make the following simplifications:
<ul>
  <li>the Earth rovolves around the sun once per year;</li>
  <li>the asteroid Ceres rovolves around the sun every 5 years;</li>
  <li>the planet Jupiter revolves around the sun every 11 years.</li>
</ul>
Suppose that on June 21st, 2000, the Earth, Ceres, and Jupiter all align (i.e., one can draw a straight line through all three).
<ol style="list-style-type:lower-alpha; margin-top:6px;">
  <li>Which two of these objects will align again on June 21st, and in which year?
  <solution>
  The next time Earth and Ceres align will be in five years, in 2005, as %x = 5 is the smallest non-zero solution in \N to the following
  system (the first equation represents alignment with Earth; the second equation represents alignment with
  Ceres):
\begin{eqnarray}
  %x & = & 0 \mod 1 \\
  %x & = & 0 \mod 5
\end{eqnarray}
  </solution>
  </li>
  <li>How many years will pass before all three align again?
  The smallest non-zero solution in \N to the following system is %x = 55, so they will all align again in 2055:
  <solution>
\begin{eqnarray}
  %x & = & 0 \mod 1 \\
  %x & = & 0 \mod 5 \\
  %x & = & 0 \mod 11
\end{eqnarray}
  </solution>
  </li>
  <li>Suppose that it is June 21st of some year between 2000 and 2055. At this time, there is no alignment. However,
      Jupiter aligned with earth on June 21st four years ago, and Ceres
      aligned with Earth on June 21st one year ago. What year is it?
      <solution>
      The following system of equations captures the situation. Since the solution must be in \Z/55\Z, we can find
      a unique solution using the Chinese remainder theorem. By inspection of the elements of
      4 + 11\Z = {4, 15, 26, ...}, the solution is %x = 26.
\begin{eqnarray}
  %x & = & 0 \mod 1 \\
  %x & = & 1 \mod 5 \\
  %x & = & 4 \mod 11
\end{eqnarray}
      </solution>    
  </li>
</ol>
</div>

<div class="mathenv">
<b>Problem:</b>
<ol style="list-style-type:lower-alpha; margin-top:6px;">
  <li>
    Suppose there exist two devices, where one produces 2 units of power and another consumes 7 units of power:
    <ul>
      <li>device A: +2 units</li>
      <li>device B: -7 units</li>
    </ul>
    Suppose we want to produce exactly 5 units of power using a combination of some number of A devices and
    B devices. How many of each device would be required?
  
    <solution>
    This problem can be modelled using the following equation, where %a represents the number of A devices and
    %b represents the number of B devices:
\begin{eqnarray}
  %a \cdot 2 + %b \cdot (-7) & = & 5
\end{eqnarray}
    Since 2 and 7 are coprime, we know that by <a href="#bezout-identity">B&eacute;zout's identity</a>,
    there exist %s and %t in \N such that:
\begin{eqnarray}
  %s \cdot 2  +  %t \cdot (-7) & = & 1\\
  4 \cdot 2 + 1 \cdot (-7) & = & 1\\
  %s & = & 4 \\
  %t & = & 1
\end{eqnarray}
    We can then multiply both sides of the above equation and use algebra to obtain %a and %b:
\begin{eqnarray}
  4 \cdot 2 + 1 \cdot (-7) & = & 1 \\
  5 \cdot (4 \cdot 2 + 1 \cdot (-7)) & = & 5 \\
  (5 \cdot 4) \cdot 2 + (5 \cdot 1) \cdot (-7) & = & 5 \\
  20 \cdot 2 + 5 \cdot (-7) & = & 5 \\
  %a & = & 20\\
  %b & = & 5
\end{eqnarray}
    </solution>
  </li>
  
  <li>
    Suppose there exist two devices, where one produces 2 units of power and another produces 7 units of power:
    <ul>
      <li>device A: +2 units</li>
      <li>device B: +7 units</li>
    </ul>
    Suppose we want to produce exactly 5 \mod 10 units of power using a combination of some number of A devices and
    B devices. How many of each device would be required?
  
    <solution>
    This problem can be modelled using the following equation, where %a represents the number of A devices and
    %b represents the number of B devices:
\begin{eqnarray}
  %a \cdot 2 + %b \cdot 7 & \equiv & 5 \mod 10
\end{eqnarray}
    Since 2 and 7 are coprime, we know that by <a href="#bezout-identity">B&eacute;zout's identity</a>,
    there exist %s and %t in \N such that:
\begin{eqnarray}
  %s \cdot 2  +  %t \cdot 7 & = & 1\\
  4 \cdot 2 + (-1) \cdot 7 & = & 1\\
  4 \cdot 2 + (-1) \cdot 7 & \equiv & 1 \mod 10\\
  -1 & \equiv & (10 - 1) \mod 10\\
     & \equiv & 9 \mod 10\\
  4 \cdot 2 + 9 \cdot 7 & \equiv & 1 \mod 10\\
  20 \cdot 2 + 45 \cdot 7 & \equiv & 5 \mod 10\\
  %a & = & 20 \\
  %b & = & 45
\end{eqnarray}
    </solution> 
  </li>
</ol>
</div>

<div class="mathenv">
<b>Problem:</b>
<ol style="list-style-type:lower-alpha; margin-top:6px;">
  <li>
    Consider the following two circular shift permutations:
    <ul>
      <li>[8,9,0,1,2,3,4,5,6,7]</li>
      <li>[5,6,7,8,9,0,1,2,3,4]</li>
    </ul>
    How many of each would you need to compose to obtain the permutation [9,0,1,2,3,4,5,6,7,8]?
    <solution>
    This permutations specified are in %C_{10}, and we know that %C_{10} \cong \Z/10\Z. Notice
    that [8,9,0,1,2,3,4,5,6,7] \in %C_{10} corresponds to 2 \in \Z/10\Z,
    that [5,6,7,8,9,0,1,2,3,4] \in %C_{10} corresponds to 5 \in \Z/10\Z,
    and that [9,0,1,2,3,4,5,6,7,8] \in %C_{10} corresponds to 1 \in \Z/10\Z. By
    <a href="#bezout-identity">B&eacute;zout's identity</a> we have that:
\begin{eqnarray}
  3 \cdot 2 + (-1) \cdot 5 & = & 1 \\
  3 \cdot 2 + 9 \cdot 5 & = & 1 (\mod 10)
\end{eqnarray}
    Thus, we would need to compose three instances of the first permutation and 9 instances of the second permutation to
    obtain [9,0,1,2,3,4,5,6,7,8].
    </solution> 
  </li>
  <li>
    Rewrite the permutation [3,4,0,1,2] as a composition of adjacent swap permutations.
    <solution>
    We can simply run the bubble sort algorithm on the above permutation and record the permutation that
    represents each swap. This leads to the following sequence:
\begin{eqnarray}
  %p_1 & = & [0,<b>2</b>,<b>1</b>,3,4] \\
  %p_2 & = & [0,1,<b>3</b>,<b>2</b>,4] \\
  %p_3 & = & [0,1,2,<b>4</b>,<b>3</b>] \\
  %p_4 & = & [<b>1</b>,<b>0</b>,2,3,4] \\
  %p_4 & = & [0,<b>2</b>,<b>1</b>,3,4] \\
  %p_5 & = & [0,1,<b>3</b>,<b>2</b>,4]
\end{eqnarray}
    Thus, by applying the above sequence of permutations to [0,1,2,3,4] in reverse order, we can obtain [3,4,0,1,2],
    so the above represents the factorization of [3,4,0,1,2] into adjacent swap permutations.
    </solution>
  </li>
</ol>
</div>

<div class="mathenv">
<b>Problem:</b>

Suppose we want to perform %k exponentiation operations (e.g., if %k = 4, we want to compute (((%a^{%b})^{%c})^{%d})^{%e}) modulo 21.
Assume the following:
<ul>
  <li>a single exponentiation operation modulo 21 takes 21^3 = 9261 steps;</li>
  <li>a single exponentiation operation modulo 3 takes 3^3 = 27 steps;</li>
  <li>a single exponentiation operation modulo 7 takes 7^3 = 343 steps;</li>
  <li>an exponentiation operation modulo 3 and an exponentiation operation modulo 7 together take 343 + 27 = 370 steps;</li>
  <li>solving a two-equation system for two values, %a modulo 3 and %b modulo 7, takes 8000 steps using CRT;</li>
  <li>we can either compute the exponentiation sequence directly modulo 21, or we can split it into two sequences of computations (one modulo 3,
      the other modulo 7) and then recombine using CRT at the end.</li>
</ul>
<ol style="list-style-type:lower-alpha; margin-top:6px;">
  <li>
    Derive a formula, in terms of %k, for each of the following:
    <ol style="list-style-type:lower-roman; margin-top:6px; margin-bottom:6px;">
      <li>the number of steps needed to perform %k exponentiations modulo 21;
        <solution>%f(%k) = 9261 \cdot %k</solution> 
      </li>
      <li>the number of steps needed to perform %k exponentiations modulo 3 and %k exponentiations modulo 7, then to recombine using CRT.
        <solution>%f(%k) = 370 \cdot %k + 8000</solution>
       </li>
    </ol>
  </li>
  <li>
    Prove by induction over \N that the following predicate is true for all %n \in \N:
\begin{eqnarray}
  %P(%n) & \Leftrightarrow & %n = 0 <b>or</b> performing %n exponentiations modulo 21 is less efficient than using CRT
\end{eqnarray}
    <solution>
    We first redefine %P(%n) using our formulas:
\begin{eqnarray}
  %P(%n) & \Leftrightarrow & %n = 0 <b>or</b> 9261 \cdot %k > 370 \cdot %k + 8000
\end{eqnarray}
    For the base cases, we know that %P(0) is true because of the left-hand side of the or operator.
    We know that %P(1) is true because 9261 > 370 + 8000.
    
    Suppose that the inductive hypothesis for %k is true. Then we have that %P(%k), which means that:
\begin{eqnarray}
  9261 & > & 370 \\
  9261 \cdot %k & > & 370 \cdot %k + 8000 \\ 
  9261 + (9261 \cdot %k) & > & 370 + (370 \cdot %k + 8000) \\
  9261 \cdot (%k + 1) & > & 370 \cdot (%k + 1) \\
\end{eqnarray}
Notice that the last line is exactly %P(%k+1). Thus, we have shown that %P(0), %P(1), and %P(%k) implies %P(%k+1) are all true.
We can then conclude that for all %n \in \N, %P(%n) is true by the axiom of induction.
    </solution>
  </li>
</ol>
</div>

<div class="mathenv">
<b>Problem:</b> Find solutions to the following problems.
<ol style="list-style-type:lower-alpha;">
  <li>Argue that the following polynomial has no integer solutions (<b>Hint:</b> you only need to
  evaluate the polynomial for two possible values of %x):
\begin{eqnarray}
  %x^4 + %x^2 + 3 & = & 0
\end{eqnarray}
  <solution>
    If the above equation has an integer solution %x, then it must have an integer solution
    modulo %2, since we can take the modulus of both sides:
\begin{eqnarray}
  %x^4 + %x^2 + 3 & = & 0 \\
  (%x^4 + %x^2 + 3) \mod 2 & = & 0 \mod 2\\
  %x^4 + %x^2 + 3 & \equiv & 0 (\mod 2)
\end{eqnarray}
    Thus, we have using logic that:
\begin{eqnarray}
  (exists solution in \Z) <b>implies</b> (exists solution modulo 2) \\
  (no solution modulo 2) <b>implies</b> (no solution in \Z)
\end{eqnarray}
    Note that this only works in one direction. A solution modulo 2 does not necessarily imply
    that there is an integer solution.
    
    We see that for %x = 0 and %x = 1, the left-hand side is odd. The right-hand side is 0, so it is always
    even. Thus, no integer solution exists.
  </solution>
  </li>
  <li>Find at least one solution %x \in \Z/10\Z to the following system of equations (you must use
  <a href="#bezout-identity">B&eacute;zout's identity</a>):
\begin{eqnarray}
  6 \cdot %y + 5 \cdot %x - 1 & \equiv & 0 (\mod 10) \\
                         %x^2 & \equiv & %y (\mod 10)
\end{eqnarray}
  <solution>
  Since 5 and 6 are coprime, we can find a solution to the first equations. One such solution is:
\begin{eqnarray}
  %y & \equiv & 1 (\mod 10) \\
  %x & \equiv & -1 (\mod 10) \\
     & \equiv & 9 (\mod 10)
\end{eqnarray}
  We also have that 9^2 \equiv 81 \equiv 1 (\mod 10).
  Thus, since 1^2 \equiv 1 (\mod 10), both equations are satisfied by this solution.
  </solution>
  </li>
</ol>
</div>

<div class="mathenv">
<b>Problem:</b>
<ol style="list-style-type:lower-alpha;">
  <li>Suppose you want to send some %s \in \Z/%n\Z to Alice and Bob, but you want to ensure that the only way
      Alice and Bob can retrieve %s is if they work together. What two distinct pairs (%s_1, %p_1) and (%s_2, %p_2) would you send to Alice and Bob, respectively,
      so that they would need to work together to recover %s?
    <solution>
      You would need to send (%s \mod %p, %p) to Alice and (%s \mod %q, %q) to Bob where %s < %p \cdot %q
      and %p and %q are distinct and coprime.
    </solution>
  </li>
  <li>Suppose Bob is generating a public RSA key; he chooses a very large prime %p, and then he chooses %q = 2. Why is this not secure?
    <solution>
      Bob must share his public key (%n, %e). Since %n = %p \cdot 2, %n is even. This can immediately be seen by looking
      at the last bit of %n (which will be 0, since %n \mod 2 = 0). It is then easy to recover the secret value %p.
    </solution>
  </li>
  <li>Suppose Alice and Bob use Shamir secret sharing to share a password %s to a lock that is not protected from brute force attacks (i.e.,
      anyone can keep trying different passwords until they unlock it). Alice holds %s \mod %p and Bob holds %s \mod %q, where %s < %p \cdot %q.
      However, suppose that Bob happens to be using %q = 2, and Alice knows this. What can Alice do to quickly break the lock?
    <solution>
      If Alice holds %a and Bob holds %b, the system of equations that would be set up to recover %s is as follows:
\begin{eqnarray}
  %x & \equiv & %a (\mod %p) \\
  %x & \equiv & %b (\mod 2)
\end{eqnarray}
      Notice that there are only two possibilities for Bob's value %b \in \Z/2\Z. Thus, Alice could set up two systems,
      one for %b = 0 and another for %b = 1, solve both, and try both secrets %s on the lock.
    </solution>
  </li>
</ol>
</div>

<div class="mathenv">
<b>Problem:</b>
Suppose that Alice, Bob, Carl, and Dan are sharing a secret %s using Shamir secret sharing, where each participant is assigned a distinct modulus %n
that is coprime to everyone else's modulus. Each participant is holding a part of the secret %s \mod %n, and the
secret can be recovered <b>by any two participants</b>. However, Eve has sabotaged the value stored by <b>one</b> one
the participants. Below are the values currently stored by everyone; <b>one of them is corrupted</b>.
<ul>
  <li>Alice: %n<sub>Alice</sub> = 3 and (%s \mod 3) = 2</li>
  <li>Bob: %n<sub>Bob</sub> = 4 and (%s \mod 4) = 3</li>
  <li>Carl: %n<sub>Carl</sub> = 5 and (%s \mod 5) = 2</li>
  <li>Dan: %n<sub>Dan</sub> = 7 and (%s \mod 7) = 4</li>
</ul>

<ol style="list-style-type:lower-alpha;">
  <li>
    Which participant's stored value %s \mod %n has Eve sabotaged?
    <solution>
      Any two participants can recover the secret %s by setting up a system with two equations and
      solving the system using CRT. We list all of the possible combinations and solve for %s to find
      which participant's value has been corrupted.
      <ul>
        <li> Alice and Bob:
\begin{eqnarray}
  %s & \equiv & 2 (\mod 3) \\
  %s & \equiv & 3 (\mod 4) \\
  <b style="color:firebrick;">%s</b> & \equiv & <b style="color:firebrick;">11</b> (\mod 12)
\end{eqnarray}
        </li>
        <li> Alice and Carl:
\begin{eqnarray}
  %s & \equiv & 2 (\mod 3) \\
  %s & \equiv & 2 (\mod 5) \\
  <b style="color:firebrick;">%s</b> & \equiv & <b style="color:firebrick;">2</b> (\mod 15)
\end{eqnarray}
        </li>
        <li> Alice and Dan:
\begin{eqnarray}
  %s & \equiv & 2 (\mod 3) \\
  %s & \equiv & 4 (\mod 7) \\
  <b style="color:firebrick;">%s</b> & \equiv & <b style="color:firebrick;">11</b> (\mod 21)
\end{eqnarray}
        </li>
        <li> Bob and Carl:
\begin{eqnarray}
  %s & \equiv & 3 (\mod 4) \\
  %s & \equiv & 2 (\mod 5) \\
  <b style="color:firebrick;">%s</b> & \equiv & <b style="color:firebrick;">7</b> (\mod 20)
\end{eqnarray}
        </li>
        <li> Bob and Dan:
\begin{eqnarray}
  %s & \equiv & 3 (\mod 4) \\
  %s & \equiv & 4 (\mod 7) \\
  <b style="color:firebrick;">%s</b> & \equiv & <b style="color:firebrick;">11</b> (\mod 28)
\end{eqnarray}
        </li>
        <li> Carl and Dan:
\begin{eqnarray}
  %s & \equiv & 2 (\mod 5) \\
  %s & \equiv & 4 (\mod 7) \\
  <b style="color:firebrick;">%s</b> & \equiv & <b style="color:firebrick;">32</b> (\mod 35)
\end{eqnarray}
        </li>
      </ul>
    Since three of the participants can consistently recover the same secret %s = 11, and all
    pairs of participants in which Carl is present do not yield %s = 11 and are inconsistent with
    one another, it must be Carl's data that has been sabotaged.
    </solution>
  </li>
  <li>
    What is the correct secret value %s?
    <solution>
       Since three of the six possible pairings result in %s = 11, and the other
       three are inconsistent and all involve Carl, it must be that %s = 11 was the original
       uncorrupted secret.
    </solution>
  </li>
  <li>
    What's the number of different shared secret values these four participants can store (assuming they use the same moduli, and
    require that any two members should be able to recover the secret).
    <solution>
       Since any two participants must be able to recover %s, it must be that %s < %n \cdot %m for every
       possible pair %n and %m. The smallest two values are 3 and 4, so 3 \cdot 4 - 1 = 11, where
       11 \in \Z/(3 \cdot 4)\Z, is the largest possible %s that can be receovered.
    </solution>
  </li>
  <li>
    Suppose you want to store an %n-bit number %s. You want to store it in a way that makes it possible to recover %s
    even if one of the bits is corrupted. How can you accomplish this using at most approximately 2 \cdot %n bits?
    <solution>
      Choose four distinct coprime numbers %m_1, %m_2, %m_3, and %m_4 such that %s is less than the product of
      every pair of these, but such that the product of any pair is not much larger than %s (e.g., %m_1 and %m_2
      can be stored in the same number of bits as %s). Then store (%s \mod %m_1, %s \mod %m_2, %s \mod %m_3, %s \mod %m_4)
      using about 2 \cdot %n bits.
      
      If any individual bit is corrupted, this corrupts at most one of the four values stored. As with Alice, Bob,
      and Dan, the original value can still be recovered.
    </solution>
  </li>
</ol>
</div>



The following is a breakdown of what you should be able to do at the end of the course (and of what you may be tested on in the final exam).
Notice that many of the tasks below can be composed. This also means that many problems can be solved in more than one way.

<ul>
  <li>problems that can be solved
    <ul>
      <li>generate a "random" number using permutations</li>
      <li>check if a number is prime
        <ul>
          <li>using an exhaustive search</li>
          <li>using the Fermat primality test</li>
        </ul>
      </li>
      <li>generate a random number in a certain range
      </li>
      <li>generate a random prime in a certain range
      </li>
      <li>use random primes
        <ul>
          <li>to encrypt information and transmit it safely using RSA</li>
          <li>to share information requiring cooperation using Shamir secret sharing</li>
          <li>to store information on unreliable storage devices (using Shamir secret sharing)</li>
          <li>to perform many arithmetic operations %x_1 \oplus ... \oplus %x_%n for some operator \oplus in sequence more efficiently
              (using CRT)
            <ul>
              <li>if the range of the final output is known</li>
              <li>if working in parallel along multiple distinct %p_%i 
                  in \Z/%p_%i\Z, and then performing CRT once is less expensive than working in \Z/%n\Z the whole time</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>solving equations and performing computations
        <ul>
          <li>solve a system of equations where each equation is modulo some %n_%i
            <ul>
              <li>derive a system of equations from a word problem via group isomorphisms
                <ul>
                  <li>rotating objects</li>
                  <li>objects of different sizes</li>
                  <li>containers of different sizes</li>
                  <li>permutations in the cyclic groups %C_%n</li>
                </ul>
              </li>
              <li>solve a system with additive and multiplicative inverses</li>
              <li>solve generalized cases (\gcd(%n,%m) > 1 and/or %c > 1 in %c \cdot %x \equiv %a (\mod %n))</li>
              <li>solve a system of three or four equations</li>
            </ul>
          </li>
          <li>compute exponents modulo %n efficiently
            <ul>
              <li>using Euler's theorem and \phi (when possible)</li>
              <li>using the efficient repeated-squaring method</li>
            </ul>
          </li>
          <li>compute multiplicative inverses \Z/%n\Z
            <ul>
              <li>using \phi(%n)</li>
              <li>using the extended Euclidean algorithms</li>
            </ul>
          </li>
          <li>counting and computing square roots of quadratic residues in \Z/%n\Z
            <ul>
              <li>using the explicit formula for prime moduli %p where %p \mod 4 = 3</li>
              <li>determine the upper bound on, or the exact number of, square roots of some %x \in \Z/%n\Z if the factors of %n are known</li>
              <li>if the prime factors of %n are known, using CRT to find all roots in \Z/%n\Z</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>recognize when you cannot solve problems efficiently
        <ul>
          <li>computing \phi(%n) for an arbitrary %n</li>
          <li>factoring %n for an arbitrary %n</li>
          <li>computing discrete logarithms</li>
          <li>decrypting RSA messages without any knowledge of private keys</li>
        </ul>
      </li>
      <li>permutations
        <ul>
          <li>identify when a relation is a permutation</li>
          <li>decompose a permutation into adjacent swaps or swaps</li>
          <li>determine the number of permutations of %n elements</li>
        </ul>
      </li>
      <li>algebraic properties
        <ul>
          <li>what are the algebraic properties of common operators and algebraic structures</li>
          <li>what are the algebraic properties of common data structures
            <ul>
              <li>binary trees are a magma if order of children matters, or a commutative magma if order of
                  children does not matter
                <ul>
                  <li>the generators {%g_1, %g_2, ...} are leaves</li>
                  <li>given two trees, (e.g., %g_1 and (%g_2 \oplus %g_3)), larger trees are
                      constructed using the binary operator (e.g., %g_1 \oplus (%g_2 \oplus %g_3))
                  </li>
                </ul>
              </li>
              <li>
                lists are a monoid (list concatenation is the associative operation, and the empty list
                  is the identity)
              </li>
              <li>
                strings are a monoid (string concatenation is the associative operation, and the empty string
                  is the identity)
              </li>
              <li>
                the integers are a group
              </li>
            </ul>
          </li>
          <li>what are the generators of an algebraic structure</li>
        </ul>
      </li>
      <li>induction
        <ul>
          <li>given a generating set, operator, and algebraic properties of closure(%S,\oplus), state the axiom of induction</li>
          <li>use induction to prove that %P(%x) for all %x \in closure(%S,\oplus)</li>
          <li>use induction to prove that %P(%n) for all %n \in closure({0,1},+) where closure({0,1},+) = \N</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<!--assignmentX-->
<br/><hr/>
<a name="9"></a>
<a name="assignmentX"></a>
<b>Bonus Assignment</b>
<!--span class="btn_assignment">(<a href="materials.php?hw=X">show only this assignment</a>)</span-->

  <p>For this assignment, you will submit a single Python source file <code>aX.py</code>.

  <b style="color:firebrick;">Your file may not import any modules or 
  employ any external library functions associated with
  integers and sets (unless the problem statement explicitly permits this). 
  You will be graded on the correctness, concision, and mathematical legibility of your code.
  The different problems and problem parts rely on each other; carefully consider whether you
  can use functions you define in one part within subsequent parts.
  You may reuse functions that you defined on previous assignments.</b>

    Suppose that you are given a black box <code>quantum()</code> that can compute the following Python function on any
      three inputs <code>f</code>, <code>g</code>, and <code>n</code> in the same amount of time
      that it takes to run <code>f(n)</code> and <code>g(n)</code>:
      <pre class="snippet">def quantum(f, g, n):
    for i in range(0,n):
        if f(i) != g(i):
            return False
    return True</pre>
      In other words, if <code>f(n)</code> and <code>g(n)</code> both run in polynomial time, then
      <code>quantum(f,g,n)</code> also runs in polynomial time (the above inefficient implementation is
      just for purposes of illustration and testing).

  <ol style="list-style-type:upper-alpha; margin-top:6px;">
    <li>Implement an efficient, polynomial-time algorithm <code>factor()</code> that takes a single positive integer
        input <code>n</code> and returns a non-trivial factor <code>x</code> of <code>n</code> (i.e., <code>1 < x < n</code>)
        if it exists. Your implementation must invoke <code>quantum()</code> (it may invoke it multiple times, but no
        more than polynomially many times). That is, <code>factor()</code> must be a polynomial-time reduction from the
        factoring problem to <code>quantum()</code>.
        
        <b>Hint: to better understand how <code>quantum()</code> might be able to help, try writing a function that
           can efficiently check if its input is a Carmichael number by using <code>quantum()</code>.</b>
    </li>
    <li>Modify your solution to <b>part (a)</b> so that it returns <i>all</i> the factors of the input <code>n</code>.
        Explain in detail why your algorithm still runs in polynomial time.
    </li>
    <li>Modify your solution from <b>part (a)</b> or <b>part (b)</b> so that it works with the following (slightly more
        realistic) version of <code>quantum()</code> (pseudocode provided; implement an inefficient test version of
        <code>quantum()</code> for more points):
      <pre class="snippet">def quantum(f, g, n):
    if [f(i) for i in range(0,n)] is a permutation of [g(i) for i in range(0,n)]:
        return True
    return False</pre>
    </li>
    <li>Implement an efficient solver for the discrete logarithm problem using <code>quantum()</code>.
    </li>
  </ol>
<hr/><br/>
<!--/assignmentX-->

<!--eof-->
