<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>

<head>
<meta charset="utf-8">
<title>BU CAS CS 320 Fall 2013</title>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-90403446-1"></script>
<script>
  window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-90403446-1');
</script>
<link rel="stylesheet" href="material/material.css">
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
<script type="text/javascript" src="material/material.js"></script>
</head>
<body>
<div class="material" id="material"><b>NOTE:</b> This page contains all the examples presented during the lectures, as well as all the homework assignments. <b><a href="index.php">Click here</a></b> to go back to the main page with the course information and schedule.<br/><div class="toc"><ul> <li>1. <a href="#1">Introduction, Background, and Motivation</a>
  <ul>  <li>1.1. <a href="#1.1">Overview</a></li>  <li>1.2. <a href="#1.2">Background and prerequisites</a></li>
  </ul>
 </li> <li>2. <a href="#2">Defining Programming Languages</a>
  <ul>  <li>2.1. <a href="#2.1">Sets of character strings</a></li>  <li>2.2. <a href="#2.2">Sets of token sequences</a></li>  <li>2.3. <a href="#2.3">Language syntax and Backus-Naur Form (BNF) notation</a></li>
  </ul>
 </li> <li>3. <a href="#3">Parsing</a>
  <ul>  <li>3.1. <a href="#3.1">Concrete and abstract syntaxes</a></li>  <li>3.2. <a href="#3.2">Lexing (a.k.a., tokenizing) and parsing</a></li>  <li>3.3. <a href="#3.3"><b>Assignment #1: Grammars and Parsing Algorithms</b></a></li>  <li>3.4. <a href="#3.4">More parsing examples and building parsers for other classes of grammar</a></li>
  </ul>
 </li> <li>4. <a href="#4">Semantics, Evaluation, and Interpretation</a>
  <ul>  <li>4.1. <a href="#4.1">Formally defining an abstract syntax</a></li>  <li>4.2. <a href="#4.2">Denotational semantics and operational semantics</a></li>  <li>4.3. <a href="#4.3">Evaluation of expressions</a></li>  <li>4.4. <a href="#4.4">Execution of sequences of statements</a></li>  <li>4.5. <a href="#4.5"><b>Assignment #2: More Parsing Algorithms and Interpreters</b></a></li>  <li>4.6. <a href="#4.6">Interpreters</a></li>
  </ul>
 </li> <li>5. <a href="#5">Compilation</a>
  <ul>  <li>5.1. <a href="#5.1">History, background, and context</a></li>  <li>5.2. <a href="#5.2">Transformations between abstract syntaxes</a></li>  <li>5.3. <a href="#5.3">Machine languages and bytecodes</a></li>  <li>5.4. <a href="#5.4">Compiling expressions to a machine language or bytecode</a></li>  <li>5.5. <a href="#5.5">Compiling statement sequences and procedures to a machine language or bytecode</a></li>  <li>5.6. <a href="#5.6"><b>Assignment #3: Compilation and Review of Interpretation</b></a></li>  <li>5.7. <a href="#5.7">Common optimizations</a></li>  <li>5.8. <a href="#5.8">Correctness of compilation algorithms</a></li>
  </ul>
 </li> <li><a href="#M.1"><b>Midterm: Programming Languages, Interpreters, and Compilers</b></a>
  <ul>
  </ul>
 </li> <li>6. <a href="#6">Static Analysis and Abstract Interpretation</a>
  <ul>  <li>6.1. <a href="#6.1">Monomorphic type systems and type checking</a></li>  <li>6.2. <a href="#6.2">Abstract interpretation</a></li>
  </ul>
 </li> <li>7. <a href="#7">Declarative (and Functional) Programming Language Paradigms</a>
  <ul>  <li>7.1. <a href="#7.1">Programming language paradigms</a></li>  <li>7.2. <a href="#7.2">Substitution and unification</a></li>  <li>7.3. <a href="#7.3">Declarative programming languages</a></li>  <li>7.4. <a href="#7.4">Algebraic data types</a></li>  <li>7.5. <a href="#7.5"><b>Assignment #4: Declarative Programming Languages</b></a></li>  <li>7.6. <a href="#7.6">Type system of the typed declarative language Haskell</a></li>  <li>7.7. <a href="#7.7">Defining and working with infinite data type instances using lazy evaluation</a></li>  <li>7.8. <a href="#7.8">Functions and higher-order functions in a typed functional language</a></li>  <li>7.9. <a href="#7.9">Data encapsulation using algebraic data types</a></li>  <li>7.10. <a href="#7.10">Adding user-defined operators and operations using Haskell type classes</a></li>  <li>7.11. <a href="#7.11">Additional useful Haskell language features and examples</a></li>  <li>7.12. <a href="#7.12">Modeling and exploring state spaces in a typed declarative/functional language</a></li>  <li>7.13. <a href="#7.13"><b>Assignment #5: Applications of Declarative and Functional Programming</b></a></li>  <li>7.14. <a href="#7.14">Ad Hoc and Parametric Polymorphism</a></li>  <li>7.15. <a href="#7.15">Folds, Unfolds, and Algebraic Properties of Functional Programs</a></li>  <li>7.16. <a href="#7.16"><b>Assignment #6: Exploiting Polymorphism, Catamorphisms, and Algebraic Properties</b></a></li>
  </ul>
 </li> <li><a href="#R.1"><i>Review #1: Programming Language Concepts</i></a>
  <ul>
  </ul>
 </li> <li><a href="#F.1"><b>Final: Programming Language Concepts</b></a>
  <ul>
  </ul>
 </li> <li>Appendix A. <a href="#A">Python</a>
  <ul>  <li>A.1. <a href="#A.1">Obtaining Python</a></li>  <li>A.2. <a href="#A.2">Common data structures (i.e., Python expressions)</a></li>  <li>A.3. <a href="#A.3">Other Python expressions</a></li>  <li>A.4. <a href="#A.4">Other useful built-in functions</a></li>  <li>A.5. <a href="#A.5">Common Python definition and control constructs (i.e., Python statements)</a></li>
  </ul>
 </li> <li>Appendix B. <a href="#B">Haskell</a>
  <ul>  <li>B.1. <a href="#B.1">Obtaining Haskell</a></li>  <li>B.2. <a href="#B.2">Haskell modules and declarations</a></li>  <li>B.3. <a href="#B.3">Common data structures (i.e., Haskell expressions)</a></li>
  </ul>
 </li></ul></div>
<a name="1"></a>
<div class="section"><hr style="margin-bottom:120px;"/><h2 class="linked"><span class="link-title">[<a href="#1">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">1.</span> Introduction, Background, and Motivation</h2>
  <a name="1.1"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#1.1">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">1.1.</span> Overview</h3>
<span class="text">A large variety of modern technology, from mobile devices and personal computers to datacenters and entire infrastructures, are programmable. These entities are controlled, operated, maintained, and monitored using a variety of interfaces and languages, which might take the form of graphical user interfaces, libraries, APIs, embedded languages, domain-specific languages, and general-purpose programming languages.</span>
<span class="text">Many of these interfaces and languages are defined and designed according to principles and conventions that have been developed over the last several decades.</span>
<span class="text">There are three major themes around which this course is organized. Each of the concepts, examples, and problems discussed in this course will relate to one or more of these themes:</span><ol><li><b>Defining and working with programming languages: </b>We will define and become familiar with the basic concepts that underlie the definition and design of common programming languages, and we will learn to identify and implement the common components found in static analysis tools, interpreters, and compilers.</li><li><b>Programming paradigms: </b>You should now be familiar with the imperative and object-oriented programming paradigms. In this course, we will provide a high-level picture of the landscape of different programming paradigms, and will focus in particular on the declarative and functional programming paradigms. We will learn to identify problems that can be solved more efficiently, more concisely, and with greater generality using programming languages that support the functional and declarative paradigms. This includes gaining experience taking advantage of features such as comprehensions, algebraic data types, static type checking, and higher-order functions, and techniques such as recursion.</li><li><b>Languages as solutions: </b>The purpose of a programming language is to provide a data representation and storage format, a communication protocol, or a control interface that can be used across time and space, between different humans and/or devices. Thus, as with any language, any programming language can be viewed as a solution to a representation, communication, or control problem. We will learn to identify when a programming language may be an appropriate solution for a problem, what trade-offs should be considered when deciding whether to design a point solution or a language, and what are some of the appropriate mathematical concepts and software tools for doing so.</li></ol></div>
  <a name="1.2"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#1.2">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">1.2.</span> Background and prerequisites</h3><div class="paragraph"><b>Basic logic.</b> 
It is expected that the reader is familiar with the basic concepts of mathematical logic, including formulas, predicates, relational operators, and terms.
      </div><div class="paragraph"><b>Basic set theory.</b> 
It is expected that the reader is familiar with the notion of a set (both finite and infinite), set size, and the set comprehension notation, e.g.,
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">  {1,2,3,4} is a set
</td></tr></table></td></tr></table>
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">  { <i>x</i> | <i>x</i> <span style="font-size:12px;">&#8712;</span> &#8484;, <i>x</i> > 0 } <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> {1, 2, 3, ...}
</td></tr></table></td></tr></table>
and the membership and subset relations between elements and sets, e.g.,
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">  1 <td></tr></table></td><td style="text-align:center;"> <span style="font-size:12px;">&#8712;</span> </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { 1, 2, 3 } </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
  {2, 3} <td></tr></table></td><td style="text-align:center;"> &sub; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { 1, 2, 3 }
</td></tr></table></td></tr></table>
      </div><div class="paragraph"><b>Programming using imperative and object-oriented language.</b> 
It is expected that the reader is familiar with at least one imperative, object-oriented language, such as Java, C++, or Python.
      </div></div>
</div>
<a name="2"></a>
<div class="section"><hr style="margin-bottom:120px;"/><h2 class="linked"><span class="link-title">[<a href="#2">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">2.</span> Defining Programming Languages</h2>
<span class="text">In order to define and reason about programming languages, and in order to write automated tools and algorithms that can operate on programs written using programming languagues, we must be able to define formally (i.e., mathematically) what is a programming language and what is a program.</span>
  <a name="2.1"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#2.1">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">2.1.</span> Sets of character strings</h3>
<span class="text">In computer science, one common way to mathematically model a formal language is to introduce a finite set of symbols (an <i>alphabet</i>). A <i>language</i> is then any subset of the set of all strings consisting of symbols from that alphabet.</span>
<a name="95e72ad05e66427281549720c9ed975f"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#95e72ad05e66427281549720c9ed975f">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="definition_required"><b>Definition:</b> 
An <i>alphabet</i> is a finite set <i>A</i>. We will call elements <i>a</i> <span style="font-size:12px;">&#8712;</span> <i>A</i> of the set <i>characters</i>. The typical alphabet we will use in this course is the set of 128 <a href="http://en.wikipedia.org/wiki/Ascii">ASCII</a> characters. However, any finite set can be an alphabet.
      </div></div></div>
<a name="3822c49489b942f59671177f1ada70ca"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#3822c49489b942f59671177f1ada70ca">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="definition_required"><b>Definition:</b> 
Given an alphabet <i>A</i>, a <i>character string</i> or <i>string</i> is any ordered finite sequence of characters from that alphabet. We will denote the empty string (containing no characters) using the symbol &epsilon;, and we will denote the length of a string <i>s</i> using the notation |<i>s</i>|.
      </div></div></div>
<a name="daa30c4fc2be458baf5bff14cd632cd9"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#daa30c4fc2be458baf5bff14cd632cd9">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
The set <i>A</i> = {<b>A</b>,<b>B</b>,<b>C</b>} is an alphabet. <b>A</b><b>A</b><b>A</b>, <b>A</b><b>B</b>, <b>B</b>, <b>C</b><b>B</b><b>A</b>, and &epsilon; are all examples of strings built using the alphabet <i>A</i>.
      </div></div></div>
<a name="d1e9fd2dc4724ef58c57cd881340e32d"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#d1e9fd2dc4724ef58c57cd881340e32d">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="definition_required"><b>Definition:</b> 
Given an alphabet <i>A</i>, let <i>U</i> be the set of all finite strings that can be built using characters from <i>A</i> (including the empty string, which we will call &epsilon;). In other words, we can say:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">  <i>U</i> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { <i>s</i> | <i>s</i> is a finite string of characters from alphabet <i>A</i> }
</td></tr></table></td></tr></table>
Any subset <i>L</i> &sub; <i>U</i> is a <i>language</i>. That is, any set of character strings (whether the set is finite or infinite) is a language.
      </div></div></div>
<a name="a32c619802234e94a307d71f676e3186"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#a32c619802234e94a307d71f676e3186">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
The set <i>A</i> = {<b>X</b>, <b>Y</b>, <b>Z</b>} is an alphabet. The set of strings { &epsilon;, <b>X</b>, <b>Y</b>, <b>Z</b> } is one example of a language. The infinite set of strings { &epsilon;, <b>X</b>, <b>X</b><b>X</b>, <b>X</b><b>X</b><b>X</b>, <b>X</b><b>X</b><b>X</b><b>X</b>, ... } is also a language. The infinite set of strings { <b>Y</b><b>Z</b>, <b>Y</b><b>Z</b><b>Y</b><b>Z</b>, <b>Y</b><b>Z</b><b>Y</b><b>Z</b><b>Y</b><b>Z</b>, ... } is also a language.
      </div></div></div>
<a name="fc5990b5b76040539c931b1ca279e222"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#fc5990b5b76040539c931b1ca279e222">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
The set <i>A</i> = {<b>0</b>, <b>1</b>, <b>2</b>, <b>3</b>, <b>4</b>, <b>5</b>, <b>6</b>, <b>7</b>, <b>8</b>, <b>9</b>} is an alphabet. The following set of strings can be a language for representing positive integers between 1 and 9999 (inclusive):
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">  <i>L</i> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { <i>s</i> | <i>s</i> is a string of characters from <i>A</i>, <i>s</i> does not begin with <b>0</b>, 1 &le; |<i>s</i>| &le; 4 }
</td></tr></table></td></tr></table>
      </div></div></div></div>
  <a name="2.2"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#2.2">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">2.2.</span> Sets of token sequences</h3>
<span class="text">Unlike human languagues, programming languages usually have a relatively small collection of symbol strings (e.g., commands or instructions) that are used to construct programs. Thus, we can adjust the definition of what constitutes a language to account for this.</span>
<a name="fe3a9fbf541445de977ab5df0e57621f"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#fe3a9fbf541445de977ab5df0e57621f">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="definition_required"><b>Definition:</b> 
Given an alphabet <i>A</i>, a <i>token</i> is a finite, non-empty (usually short) string of characters from that alphabet.
      </div></div></div>
<a name="8f78a2be462e425da6c87339850e7f8b"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#8f78a2be462e425da6c87339850e7f8b">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="definition_required"><b>Definition:</b> 
Given a set of tokens <i>T</i>, let <i>U</i> be the set of all finite sequences that can be built using tokens from <i>T</i> (including the empty sequence, which we will call &epsilon;). In other words, we can say:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">  <i>U</i> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { <i>s</i> | <i>s</i> is a finite sequence of tokens from <i>T</i> }
</td></tr></table></td></tr></table>
Any subset <i>L</i> &sub; <i>U</i> is a <i>language</i>. That is, any set of token sequences (whether the set is finite or infinite) is a language.
      </div></div></div>
<a name="06d4c9d409dc44ad8c1dccbef3412163"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#06d4c9d409dc44ad8c1dccbef3412163">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
Consider the following set of tokens:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>T</i> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { <b>true</b>, <b>false</b>, <b>or</b>, <b>and</b>, <b>not</b>, <b>(</b>, <b>)</b>, <b>,</b> }
</td></tr></table></td></tr></table>
The set of token sequences that represent valid boolean formulas is a language:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>L</i> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { <b>or ( false , and ( true , false ) )</b>, &nbsp;&nbsp;&nbsp;&nbsp; <b>and ( true , false )</b>, &nbsp;&nbsp;&nbsp;&nbsp; <b>not</b> <b>(</b> <b>false</b> <b>)</b>, &nbsp;&nbsp;&nbsp;&nbsp; <b>true</b>, &nbsp;&nbsp;&nbsp;&nbsp; <b>false</b>, &nbsp;&nbsp;&nbsp;&nbsp; ... }
</td></tr></table></td></tr></table>
      </div></div></div>
<span class="text">If a language is just a subset of the set of all possible token sequences, how do we mathematically specify interesting subsets?</span></div>
  <a name="2.3"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#2.3">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">2.3.</span> Language syntax and Backus-Naur Form (BNF) notation</h3>
<span class="text">If a language is just a set of finite token strings, then defining a language amounts to defining this set. How can we define this set? By introducing a collection of rules or constraints governing how characters and/or tokens can be assembled to form strings or sequences in the language.</span>
<a name="7e82906541a4467faea16807f380dd44"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#7e82906541a4467faea16807f380dd44">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="definition_required"><b>Definition:</b> 
Given a token set <i>T</i> and a language <i>L</i> consisting of finite sequences of tokens from <i>T</i>, the <i>syntax</i> of <i>L</i> is the set of rules defining <i>exactly</i> which token sequences are in <i>L</i>.
These rules are sometimes also called <i>syntactic rules</i>, a <i>formal grammar</i>, or simply a <i>grammar</i>.
      </div></div></div>
<span class="text">There are many possible ways by which we could represent syntactic rules, and these rules can be classified, or stratified, according to their expressive power. A more extensive coverage of this topic is beyond the scope of this course, and is normally presented in courses on the theory of computation and automata. In this course, we will focus on two particular kinds of grammar: regular grammars and context-free grammars. The most common representation for such grammars is Backus-Naur Form, abbreviated henceforward as <i>BNF</i>.</span>
<a name="2075c983aff44402b4e5467cdd450d53"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#2075c983aff44402b4e5467cdd450d53">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="definition_required"><b>Definition:</b> 
A grammar definition consists of one or more <i>productions</i>. Each production has the following form:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>non-terminal</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>terminal_or_non-terminal</i> &nbsp;&nbsp;&nbsp;&nbsp; ... &nbsp;&nbsp;&nbsp;&nbsp; <i>terminal_or_non-terminal</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                    <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>terminal_or_non-terminal</i> &nbsp;&nbsp;&nbsp;&nbsp; ... &nbsp;&nbsp;&nbsp;&nbsp; <i>terminal_or_non-terminal</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                    <td></tr></table></td><td style="text-align:center;"> &#8942; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                    <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>terminal_or_non-terminal</i> &nbsp;&nbsp;&nbsp;&nbsp; ... &nbsp;&nbsp;&nbsp;&nbsp; <i>terminal_or_non-terminal</i>
</td></tr></table></td></tr></table>
The left-hand side (to the left of the ::= symbol) in each production is called a <i>non-terminal</i>. The right-hand side of each production is an unordered collection of <i>choices</i> separated by the | symbol. Each choice is a <i>sequence</i> of non-terminals (which must appear once on the left-hand side of a production) or <i>terminals</i> (a terminal is a token).
      </div></div></div>
<span class="text">These production rules in a grammar's BNF representation can be viewed both as a way to construct an element (i.e., a token sequence that is a program) in the language, or as a way to break down a token sequence piece by piece until nothing is left.</span>
<a name="16147b7c6f904109b9900322be8ad838"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#16147b7c6f904109b9900322be8ad838">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
Let <i>T</i> be a token set:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>T</i> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { <b>true</b> }
</td></tr></table></td></tr></table>
The following is a very simple programming language that contains only a single possible token sequence consisting of the single token <b>true</b>:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b>
</td></tr></table></td></tr></table>
In this case, the language is finite and small, so we can actually write it down as a set:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>L</i> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { <b>true</b> }
</td></tr></table></td></tr></table>
      </div></div></div>
<a name="b8f92b53cb7449998112583773b3d97c"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#b8f92b53cb7449998112583773b3d97c">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
We can extend the language by adding another token:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>T</i> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { <b>true</b>, <b>false</b> }
</td></tr></table></td></tr></table>
The following BNF grammar definition now contains two choices (each choice is a sequence consisting of a single terminal):
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>false</b>
</td></tr></table></td></tr></table>
This programming language now contains two token sequences:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>L</i> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { <b>true</b>, <b>false</b> }
</td></tr></table></td></tr></table>
      </div></div></div>
<a name="9380e58ddbde4fe88ddb2daff5bd4617"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#9380e58ddbde4fe88ddb2daff5bd4617">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
We can extend the language definition further:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>T</i> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { <b>true</b>, <b>false</b>, <b>or</b>, <b>and</b>, <b>not</b>, <b>(</b>, <b>)</b>, <b>,</b> }
</td></tr></table></td></tr></table>
The following BNF grammar definition now contains five choices (each choice is a sequence consisting of non-terminals and terminals):
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>false</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>and (</b> <i>program</i> <b>,</b> <i>program</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>or (</b> <i>program</i> <b>,</b> <i>program</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>not (</b> <i>program</i> <b>)</b>
</td></tr></table></td></tr></table>
This programming language now contains infinitely many finite token sequences:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>L</i> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { <b>or ( false , and ( true , false ) )</b>, &nbsp;&nbsp;&nbsp;&nbsp; <b>and ( true , false )</b>, &nbsp;&nbsp;&nbsp;&nbsp; <b>not</b> <b>(</b> <b>false</b> <b>)</b>, &nbsp;&nbsp;&nbsp;&nbsp; <b>true</b>, &nbsp;&nbsp;&nbsp;&nbsp; <b>false</b>, &nbsp;&nbsp;&nbsp;&nbsp; ... }
</td></tr></table></td></tr></table>
      </div></div></div>
<a name="8c1203dd65bb49868abc64ad5353725f"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#8c1203dd65bb49868abc64ad5353725f">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
Let us consider another example: a language of positive integers.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>T</i> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { <b>0</b>, <b>1</b>, <b>2</b>, <b>3</b>, <b>4</b>, <b>5</b>, <b>6</b>, <b>7</b>, <b>8</b>, <b>9</b> }
</td></tr></table></td></tr></table>
We can define the following grammar:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>number</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>0</b> | <b>1</b> | <b>2</b> | <b>3</b> | <b>4</b> | <b>5</b> | <b>6</b> | <b>7</b> | <b>8</b> | <b>9</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
  <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>1</b> <i>number</i> | <b>2</b> <i>number</i> | <b>3</b> <i>number</i> | <b>4</b> <i>number</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
  <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>5</b> <i>number</i> | <b>6</b> <i>number</i> | <b>7</b> <i>number</i> | <b>8</b> <i>number</i> | <b>9</b> <i>number</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
</td></tr></table></td></tr></table>
However, the above does not allow us to have a <b>0</b> in any number with more than one digit. One way to fix this (there are many other ways) is to introduce more productions into the grammar:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>nozero</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>1</b> | <b>2</b> | <b>3</b> | <b>4</b> | <b>5</b> | <b>6</b> | <b>7</b> | <b>8</b> | <b>9</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>digit</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>0</b> | <i>nozero</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>digits</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>digit</i> | <i>digit</i> <i>digits</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>number</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>digit</i> | <i>nozero</i> <i>digits</i>
</td></tr></table></td></tr></table>
      </div></div></div>
<span class="text">Note that the grammar may contain multiple productions. Any non-terminal defined in a production can appear on the right-hand side of any of the productions.</span>
<a name="19dc317f45ec4ae18018ca5b17fce114"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#19dc317f45ec4ae18018ca5b17fce114">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
We can extend the language by adding a production for statements, and allowing a program to be a sequence of one or more statements.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>T</i> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { <b>true</b>, <b>false</b>, <b>or</b>, <b>and</b>, <b>not</b>, <b>(</b>, <b>)</b>, <b>,</b>, <b>print</b>, <b>skip</b>, <b>;</b> }
</td></tr></table></td></tr></table>
The following is the new grammar definition for this language.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>statement</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>statement</i> <i>program</i>  </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>statement</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>print</b> <i>formula</i> <b>;</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>skip</b> <b>;</b>  </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>formula</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> | <b>false</b> | <b>not (</b> <i>formula</i> <b>)</b> | <b>and (</b> <i>formula</i> <b>,</b> <i>formula</i> <b>)</b> | <b>or (</b> <i>formula</i> <b>,</b> <i>formula</i> <b>)</b>
</td></tr></table></td></tr></table>
      </div></div></div></div>
</div>
<a name="3"></a>
<div class="section"><hr style="margin-bottom:120px;"/><h2 class="linked"><span class="link-title">[<a href="#3">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">3.</span> Parsing</h2>
<span class="text">Given a programming language definition, we want to have the ability to operate on programs written in that language using a computer. To do so, we need to convert the character string representations of programs in that programming language into instances of a data structure; each data structure instance would then be a representation of the program as data.</span>
  <a name="3.1"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#3.1">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">3.1.</span> Concrete and abstract syntaxes</h3>
<a name="e601deb568ed46a1a1d741907a6dcfa9"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#e601deb568ed46a1a1d741907a6dcfa9">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="definition_required"><b>Definition:</b> 
Given an alphabet, token set, and grammar definition (e.g., represented using BNF notation), we define the <i>concrete syntax</i> to be the set of all character strings that conform to the grammar definition. We call a particular character string that conforms to the grammar definition a <i>concrete syntax instance</i>.
      </div></div></div>
<a name="db9e874ec6b6475a93bc3ef4db0f2066"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#db9e874ec6b6475a93bc3ef4db0f2066">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="definition_required"><b>Definition:</b> 
For a particular programming language definition, we define the <i>abstract syntax</i> to be the set of all data structure instances that correspond to a character string that conforms to the grammar definition for that language. An instance of the abstract syntax is sometimes called a <i>parse tree</i>.
      </div></div></div>
<a name="4ba33545333f48e88baddfa4507a1db0"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#4ba33545333f48e88baddfa4507a1db0">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">Consider again the language that conforms to the following grammar:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> | <b>false</b> | <b>not (</b> <i>program</i> <b>)</b> | <b>and (</b> <i>program</i> <b>,</b> <i>program</i> <b>)</b> | <b>or (</b> <i>program</i> <b>,</b> <i>program</i> <b>)</b> 
</td></tr></table></td></tr></table>
The following is the character string of one possible program in the language. This character string is an instance of the concrete syntax of the language.</span>
        
<div class="code"><div class="source"><br/>and&nbsp;(or&nbsp;(and&nbsp;(true,&nbsp;false),&nbsp;not(false)),&nbsp;or&nbsp;(true,&nbsp;false))<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">The above character string might be converted into a structured representation of the program within some host language (i.e., the programming language being used to operate on these programs: checking for errors, interpreting, or compiling the program). Below, we present one possible Python representation of the instance of the abstract syntax (i.e., the parse tree) corresponding to the concrete syntax instance above. This representation uses nested Python dictionaries to represent the parse tree, with strings being used to represent node labels and leaves.</span>
        
<div class="code"><div class="source"><br/>{&nbsp;<span class="literal">"And"</span>:&nbsp;[<br/>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<span class="literal">"Or"</span>:&nbsp;[<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<span class="literal">"And"</span>:&nbsp;[<span class="literal">"True"</span>,<span class="literal">"False"</span>]},&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<span class="literal">"Not"</span>:&nbsp;[<span class="literal">"False"</span>]}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br/>&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<span class="literal">"Or"</span>:&nbsp;[<span class="literal">"True"</span>,<span class="literal">"False"</span>]}<br/>&nbsp;&nbsp;]<br/>}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
      </div></div></div></div>
  <a name="3.2"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#3.2">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">3.2.</span> Lexing (a.k.a., tokenizing) and parsing</h3>
<a name="3f625b68bc8a426c80fe1c774e04c362"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#3f625b68bc8a426c80fe1c774e04c362">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="definition_required"><b>Definition:</b> 
A <i>lexer</i> or <i>tokenizer</i> is an algorithm that converts an instance of the concrete syntax of a language (i.e., a character string that conforms to the grammar definition for the language) into a sequence of tokens.
      </div></div></div>
<a name="2c7cc0e69813454eafc7128e5ac57055"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#2c7cc0e69813454eafc7128e5ac57055">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">Consider again the language that conforms to the following grammar:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> | <b>false</b> | <b>not (</b> <i>program</i> <b>)</b> | <b>and (</b> <i>program</i> <b>,</b> <i>program</i> <b>)</b> | <b>or (</b> <i>program</i> <b>,</b> <i>program</i> <b>)</b> 
</td></tr></table></td></tr></table>
The following Python implementation of a tokenizing algorithm for this language uses regular expressions to split a character string into a sequence of individual tokens from the token set.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">import</span>&nbsp;re<br/><span class="keyword">def</span>&nbsp;tokenize(s):<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Use&nbsp;a&nbsp;regular&nbsp;expression&nbsp;to&nbsp;split&nbsp;the&nbsp;string&nbsp;into</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;tokens&nbsp;or&nbsp;sequences&nbsp;of&nbsp;zero&nbsp;or&nbsp;more&nbsp;spaces.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;tokens&nbsp;=&nbsp;[t&nbsp;<span class="keyword">for</span>&nbsp;t&nbsp;<span class="keyword">in</span>&nbsp;re.split(r<span class="literal">"(\s+|true|false|and|or|not|,|\(|\))"</span>,&nbsp;s)]<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Throw&nbsp;out&nbsp;the&nbsp;spaces&nbsp;and&nbsp;return&nbsp;the&nbsp;result.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;[t&nbsp;<span class="keyword">for</span>&nbsp;t&nbsp;<span class="keyword">in</span>&nbsp;tokens&nbsp;<span class="keyword">if</span>&nbsp;<span class="keyword">not</span>&nbsp;t.isspace()&nbsp;<span class="keyword">and</span>&nbsp;<span class="keyword">not</span>&nbsp;t&nbsp;==&nbsp;<span class="literal">""</span>]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">Below is an example input and output.</span>
        
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;tokenize(<span class="literal">"and&nbsp;(or&nbsp;(and&nbsp;(true,&nbsp;false),&nbsp;not(false)),&nbsp;or&nbsp;(true,&nbsp;false))"</span>)<br/><br/>[<span class="literal">'and'</span>,&nbsp;<span class="literal">'('</span>,&nbsp;<span class="literal">'or'</span>,&nbsp;<span class="literal">'('</span>,&nbsp;<span class="literal">'and'</span>,&nbsp;<span class="literal">'('</span>,&nbsp;<span class="literal">'true'</span>,&nbsp;<span class="literal">','</span>,&nbsp;<span class="literal">'false'</span>,&nbsp;<span class="literal">')'</span>,&nbsp;<span class="literal">','</span>,&nbsp;<span class="literal">'not'</span>,&nbsp;<br/>&nbsp;<span class="literal">'('</span>,&nbsp;<span class="literal">'false'</span>,&nbsp;<span class="literal">')'</span>,&nbsp;<span class="literal">')'</span>,&nbsp;<span class="literal">','</span>,&nbsp;<span class="literal">'or'</span>,&nbsp;<span class="literal">'('</span>,&nbsp;<span class="literal">'true'</span>,&nbsp;<span class="literal">','</span>,&nbsp;<span class="literal">'false'</span>,&nbsp;<span class="literal">')'</span>,&nbsp;<span class="literal">')'</span>]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
      </div></div></div>
<a name="3c944fff48f246aba9409f76e48ccef4"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#3c944fff48f246aba9409f76e48ccef4">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="definition_required"><b>Definition:</b> 
A <i>parser</i> is an algorithm that converts a token sequence into an instance of the abstract syntax (i.e., a parse tree).
      </div></div></div>
<span class="text">The tokenizer and parser are then composed to transform a character string into a parse tree.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">character string<br/>(concrete syntax)</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">lexer/<br/>tokenizer</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">token<br/>sequence</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">parser</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">parse tree<br/>(abstract syntax)</td>
  </tr>
</table>
</div>
Often, the tokenizer and parser are together called a <i>parser</i>. In situations where this can cause confusion, we will refer to the actual process that converts token sequences into parse trees as the <i>parsing algorithm</i>.
<div class="diagram">
<table class="container">
  <tr>
  <td class="box" style="background-color:powderblue;">character string<br/>(concrete syntax)</td>
  <td><span style="font-size:20px;">&#8658;</span></td>
  <td class="box" style="background-color:#EFEFEF;">
  <table class="container">
    <tr>
    <td class="box" style="background-color:lightyellow;">lexer/<br/>tokenizer</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">token<br/>sequence</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">parsing<br/>algorithm</td>
    </tr>
  </table>
  <br/>parser
  </td>
  <td><span style="font-size:20px;">&#8658;</span></td>
  <td class="box" style="background-color:powderblue;">parse tree<br/>(abstract syntax)</td>
  </tr>
</table>
</div>
The BNF representation of a grammar can be converted into a parsing algorithm that turns a token sequence into an abstract syntax data structure instance (i.e., a parse tree). How easily this can be done depends on the properties of the grammar.</span>
<a name="47254608df414ace8d04c630a2b15689"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#47254608df414ace8d04c630a2b15689">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="fact_required"><b>Fact:</b> 
Given a BNF representation of a grammar, if for every production in the grammar, each choice begins with a unique terminal (i.e., a terminal that is <i>not</i> the first terminal in any other choice within that production), then we say the grammar is in <i>LL(1)</i> form, and we can implement a <i>predictive recursive descent</i> parsing algorithm to parse any token sequence that conforms to this grammar (note that these are only <i>sufficient</i> conditions for the grammar to be in LL(1) form; less restrictive conditions also exist).
      </div></div></div>
<span class="text">A predictive recursive descent parser can effectively run in linear time; it decomposes the token sequence from left to right while assembling a parse tree.</span>
<a name="2cd418f2876c42d59a57e34bd6288f22"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#2cd418f2876c42d59a57e34bd6288f22">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">Consider again the language that conforms to the following grammar:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> | <b>false</b> | <b>not (</b> <i>program</i> <b>)</b> | <b>and (</b> <i>program</i> <b>,</b> <i>program</i> <b>)</b> | <b>or (</b> <i>program</i> <b>,</b> <i>program</i> <b>)</b> 
</td></tr></table></td></tr></table>
The following Python implementation of a predictive recursive descent parsing algorithm for this language builds a parse tree using the nested dictionary representation seen in <a href="#4ba33545333f48e88baddfa4507a1db0">a previous example</a>. This recursive algorithm takes a single argument: a sequence of tokens. It returns two results: a parse tree, and the remainder of the token sequence. <b>Note that the order in which the choices in the production are being handled is not determined by the order of the choices in the production.</b> The choices in a production are unordered; any parser implementation that captures all the possible choices conforms to the grammar definition.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">def</span>&nbsp;parse(tokens):<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[0]&nbsp;==&nbsp;<span class="literal">'true'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;(<span class="literal">'True'</span>,&nbsp;tokens[1:])<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[0]&nbsp;==&nbsp;<span class="literal">'false'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;(<span class="literal">'False'</span>,&nbsp;tokens[1:])<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[0]&nbsp;==&nbsp;<span class="literal">'not'</span>&nbsp;<span class="keyword">and</span>&nbsp;tokens[1]&nbsp;==&nbsp;<span class="literal">'('</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(e1,&nbsp;tokens)&nbsp;=&nbsp;parse(tokens[2:])<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[0]&nbsp;==&nbsp;<span class="literal">')'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;({<span class="literal">'Not'</span>:[e1]},&nbsp;tokens[1:])<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[0]&nbsp;==&nbsp;<span class="literal">'or'</span>&nbsp;<span class="keyword">and</span>&nbsp;tokens[1]&nbsp;==&nbsp;<span class="literal">'('</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(e1,&nbsp;tokens)&nbsp;=&nbsp;parse(tokens[2:])<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[0]&nbsp;==&nbsp;<span class="literal">','</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(e2,&nbsp;tokens)&nbsp;=&nbsp;parse(tokens[1:])<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[0]&nbsp;==&nbsp;<span class="literal">')'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;({<span class="literal">'Or'</span>:[e1,e2]},&nbsp;tokens[1:])<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[0]&nbsp;==&nbsp;<span class="literal">'and'</span>&nbsp;<span class="keyword">and</span>&nbsp;tokens[1]&nbsp;==&nbsp;<span class="literal">'('</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(e1,&nbsp;tokens)&nbsp;=&nbsp;parse(tokens[2:])<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[0]&nbsp;==&nbsp;<span class="literal">','</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(e2,&nbsp;tokens)&nbsp;=&nbsp;parse(tokens[1:])<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[0]&nbsp;==&nbsp;<span class="literal">')'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;({<span class="literal">'And'</span>:[e1,e2]},&nbsp;tokens[1:])<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">Below is an example input and output. Notice that no tokens are left in the token sequence once the result is returned.</span>
        
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;<span class="keyword">import</span>&nbsp;json<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;(tree,&nbsp;tokens)&nbsp;=\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parse(tokenize(<span class="literal">"and&nbsp;(or&nbsp;(and&nbsp;(true,&nbsp;false),&nbsp;not(false)),&nbsp;or&nbsp;(true,&nbsp;false))"</span>))<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;<span class="builtin">print</span>(json.dumps(tree,&nbsp;sort_keys=True,&nbsp;indent=2))<br/>{<br/>&nbsp;&nbsp;<span class="literal">"And"</span>:&nbsp;[<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">"Or"</span>:&nbsp;[<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">"And"</span>:&nbsp;[<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">"True"</span>,&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">"False"</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">"Not"</span>:&nbsp;[<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">"False"</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br/>&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">"Or"</span>:&nbsp;[<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">"True"</span>,&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">"False"</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;]<br/>}<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;<span class="builtin">print</span>(tokens)<br/>[]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
      </div></div></div>
<a name="95cb72f5b4d24ddba2c8081c7b42618a"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#95cb72f5b4d24ddba2c8081c7b42618a">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="fact_required"><b>Fact:</b> 
If we relax the conditions on the grammar definition that make it LL(1) by dropping the requirement that the first terminal in each sequence within a production must be unique, we can no longer use predictive recursive descent parsing algorithm to parse a language corresponding to this grammar because the first terminal in each sequence within a production no longer uniquely determines which choice within a production should be used to continue parsing a token sequence. However, as long as every sequence within every production starts with a terminal, we can implement a <i>backtracking recursive descent</i> parsing algorithm to parse token sequence in the language.
      </div></div></div>
<a name="5917f6f5de7c46079190f4b6c4961ca3"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#5917f6f5de7c46079190f4b6c4961ca3">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">In the previus example, the grammar only allowed prefix logical operators. Suppose we wanted to parse token sequences for a grammar with infix operators.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> | <b>false</b> | <b>not (</b> <i>program</i> <b>)</b> | <b>(</b> <i>program</i> <b>and</b> <i>program</i> <b>)</b> | <b>(</b> <i>program</i> <b>or</b> <i>program</i> <b>)</b> 
</td></tr></table></td></tr></table>
It is no longer possible to implement a predictive recursive descent parser. We must instead employ backtracking, and we must also keep track of whether we have consumed all the tokens.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">def</span>&nbsp;parse(tmp,&nbsp;top):<br/>&nbsp;&nbsp;&nbsp;&nbsp;tokens&nbsp;=&nbsp;tmp[0:]<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[0]&nbsp;==&nbsp;<span class="literal">'true'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokens&nbsp;=&nbsp;tokens[1:]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="keyword">not</span>&nbsp;top&nbsp;<span class="keyword">or</span>&nbsp;<span class="builtin">len</span>(tokens)&nbsp;==&nbsp;0:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;(<span class="literal">'True'</span>,&nbsp;tokens)<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;tokens&nbsp;=&nbsp;tmp[0:]<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[0]&nbsp;==&nbsp;<span class="literal">'false'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokens&nbsp;=&nbsp;tokens[1:]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="keyword">not</span>&nbsp;top&nbsp;<span class="keyword">or</span>&nbsp;<span class="builtin">len</span>(tokens)&nbsp;==&nbsp;0:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;(<span class="literal">'False'</span>,&nbsp;tokens)<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;tokens&nbsp;=&nbsp;tmp[0:]<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[0]&nbsp;==&nbsp;<span class="literal">'not'</span>&nbsp;<span class="keyword">and</span>&nbsp;tokens[1]&nbsp;==&nbsp;<span class="literal">'('</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokens&nbsp;=&nbsp;tokens[2:]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;parse(tokens,&nbsp;<span class="builtin">False</span>)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="keyword">not</span>&nbsp;r&nbsp;<span class="keyword">is</span>&nbsp;<span class="builtin">None</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(e1,&nbsp;tokens)&nbsp;=&nbsp;r<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[0]&nbsp;==&nbsp;<span class="literal">')'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokens&nbsp;=&nbsp;tokens[1:]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;<span class="keyword">not</span>&nbsp;top&nbsp;<span class="keyword">or</span>&nbsp;<span class="builtin">len</span>(tokens)&nbsp;==&nbsp;0:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;({<span class="literal">'Not'</span>:[e1]},&nbsp;tokens)<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;tokens&nbsp;=&nbsp;tmp[0:]<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[0]&nbsp;==&nbsp;<span class="literal">'('</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokens&nbsp;=&nbsp;tokens[1:]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;parse(tokens,&nbsp;<span class="builtin">False</span>)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="keyword">not</span>&nbsp;r&nbsp;<span class="keyword">is</span>&nbsp;<span class="builtin">None</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(e1,&nbsp;tokens)&nbsp;=&nbsp;r<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[0]&nbsp;==&nbsp;<span class="literal">'or'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokens&nbsp;=&nbsp;tokens[1:]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;parse(tokens,&nbsp;<span class="builtin">False</span>)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="keyword">not</span>&nbsp;r&nbsp;<span class="keyword">is</span>&nbsp;<span class="builtin">None</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(e2,&nbsp;tokens)&nbsp;=&nbsp;r<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[0]&nbsp;==&nbsp;<span class="literal">')'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokens&nbsp;=&nbsp;tokens[1:]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="keyword">not</span>&nbsp;top&nbsp;<span class="keyword">or</span>&nbsp;<span class="builtin">len</span>(tokens)&nbsp;==&nbsp;0:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;({<span class="literal">'Or'</span>:[e1,e2]},&nbsp;tokens)<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;tokens&nbsp;=&nbsp;tmp[0:]<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[0]&nbsp;==&nbsp;<span class="literal">'('</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokens&nbsp;=&nbsp;tokens[1:]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;parse(tokens,&nbsp;<span class="builtin">False</span>)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="keyword">not</span>&nbsp;r&nbsp;<span class="keyword">is</span>&nbsp;<span class="builtin">None</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(e1,&nbsp;tokens)&nbsp;=&nbsp;r<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[0]&nbsp;==&nbsp;<span class="literal">'and'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokens&nbsp;=&nbsp;tokens[1:]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;parse(tokens,&nbsp;<span class="builtin">False</span>)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="keyword">not</span>&nbsp;r&nbsp;<span class="keyword">is</span>&nbsp;<span class="builtin">None</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(e2,&nbsp;tokens)&nbsp;=&nbsp;r<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[0]&nbsp;==&nbsp;<span class="literal">')'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokens&nbsp;=&nbsp;tokens[1:]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="keyword">not</span>&nbsp;top&nbsp;<span class="keyword">or</span>&nbsp;<span class="builtin">len</span>(tokens)&nbsp;==&nbsp;0:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;({<span class="literal">'And'</span>:[e1,e2]},&nbsp;tokens)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">The above code is far too repetitive. However, we can take the parts that repeat and turn them into a loop body that loops over all the possible choices in the production.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">def</span>&nbsp;parse(tmp,&nbsp;top):<br/>&nbsp;&nbsp;&nbsp;&nbsp;seqs&nbsp;=&nbsp;[\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="literal">'True'</span>,&nbsp;[<span class="literal">'true'</span>]),&nbsp;\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="literal">'False'</span>,&nbsp;[<span class="literal">'false'</span>]),&nbsp;\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="literal">'Not'</span>,&nbsp;[<span class="literal">'not'</span>,&nbsp;<span class="literal">'('</span>,&nbsp;parse,&nbsp;<span class="literal">')'</span>]),&nbsp;\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="literal">'And'</span>,&nbsp;[<span class="literal">'('</span>,&nbsp;parse,&nbsp;<span class="literal">'and'</span>,&nbsp;parse,&nbsp;<span class="literal">')'</span>]),&nbsp;\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="literal">'Or'</span>,&nbsp;[<span class="literal">'('</span>,&nbsp;parse,&nbsp;<span class="literal">'or'</span>,&nbsp;parse,&nbsp;<span class="literal">')'</span>])&nbsp;\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;(label,&nbsp;seq)&nbsp;<span class="keyword">in</span>&nbsp;seqs:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokens&nbsp;=&nbsp;tmp[0:]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ss&nbsp;=&nbsp;[]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;es&nbsp;=&nbsp;[]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;x&nbsp;<span class="keyword">in</span>&nbsp;seq:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="builtin">type</span>(x)&nbsp;==&nbsp;<span class="builtin">type</span>(<span class="literal">""</span>):<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[0]&nbsp;==&nbsp;x:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokens&nbsp;=&nbsp;tokens[1:]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ss&nbsp;=&nbsp;ss&nbsp;+&nbsp;[x]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">break</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;x(tokens,&nbsp;<span class="builtin">False</span>)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="keyword">not</span>&nbsp;r&nbsp;<span class="keyword">is</span>&nbsp;<span class="builtin">None</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(e,&nbsp;tokens)&nbsp;=&nbsp;r<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;es&nbsp;=&nbsp;es&nbsp;+&nbsp;[e]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="builtin">len</span>(ss)&nbsp;+&nbsp;<span class="builtin">len</span>(es)&nbsp;==&nbsp;<span class="builtin">len</span>(seq):<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="keyword">not</span>&nbsp;top&nbsp;<span class="keyword">or</span>&nbsp;<span class="builtin">len</span>(tokens)&nbsp;==&nbsp;0:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;({label:es}&nbsp;<span class="keyword">if</span>&nbsp;<span class="builtin">len</span>(es)&nbsp;>&nbsp;0&nbsp;<span class="keyword">else</span>&nbsp;label,&nbsp;tokens)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
      </div></div></div></div><br/><hr/><a name="3.3"></a><a name="assignment1"></a><a name="hw1"></a><div class="assignment"><h3 class="linked"><span class="link-title">[<a href="#3.3">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">3.3.</span> <span class="assignment_title">Assignment #1: Grammars and Parsing Algorithms</span></h3><div class="instructions">
In this assignment you will be implementing grammar analysis and parsing algorithms using Python. You must submit a single Python source file named <code>a1.py</code>. Please follow the <a href="http://www.cs.bu.edu/teaching/hw/gsubmit/">gsubmit</a> directions.
<br/><br/>
Your solutions to each of the problem parts below will be graded on their correctness, concision, and mathematical legibility. The different problems and problem parts rely on the lecture notes and on each other; carefully consider whether you can use functions from the lecture notes, or functions you define in one part within subsequent parts.
<br/><br/>
<b style="color:green;">A testing script with several test cases is available for download: <a href="a1-tests.py"><code>a1-tests.py</code></a>. You should be able to place it in the same directory as <code>a1.py</code> and run it. Feel free to modify or extend it as you see fit.</b>
      </div><ol class="problems"><li class="problem"><ol class="parts"><li class="part">
<span class="text">Implement a function <code>tokenize()</code> that takes two arguments: a regular expression string and a character string to tokenize. It should then use the regular expression to convert the second string into a token sequence (represented in Python as a list of strings) and return it.</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;tokenize(r<span class="literal">"(\s+|red|blue)"</span>,&nbsp;<span class="literal">"red&nbsp;red&nbsp;blue&nbsp;red"</span>)<br/>[<span class="literal">'red'</span>,&nbsp;<span class="literal">'red'</span>,&nbsp;<span class="literal">'blue'</span>,&nbsp;<span class="literal">'red'</span>]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li><li class="part">
<span class="text">Implement a predictive recursive descent parsing algorithm <code>directions()</code> that takes a token sequence (represented in Python as a list of strings) and parses that token sequence into a parse tree according to the following grammar definition:</span>
<span class="text"><table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>directions</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>up</b> <b>;</b> <i>directions</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                  <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>down</b> <b>;</b> <i>directions</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                  <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>left</b> <b>;</b> <i>directions</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                  <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>right</b> <b>;</b> <i>directions</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                  <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>stop</b> <b>;</b>
</td></tr></table></td></tr></table></span>
<span class="text">Each node in the parse tree should be labelled <code>"Up"</code>, <code>"Down"</code>, <code>"Left"</code>, <code>"Right"</code>, or <code>"Stop"</code>. An example input and output are provided below.
<b style="color:green;">Note that the output below omits the token list because it was generated using the <code>json</code> module. It is fine if your implementation of <code>directions</code> returns an empty token list along with the parse tree.</b></span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;directions(tokenize(r<span class="literal">"(\s+|up|down|left|right|stop|;)"</span>,&nbsp;<span class="literal">"up;&nbsp;up;&nbsp;up;&nbsp;right;&nbsp;down;&nbsp;up;&nbsp;stop;"</span>))<br/>{&nbsp;<span class="literal">"Up"</span>:&nbsp;[<br/>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<span class="literal">"Up"</span>:&nbsp;[<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<span class="literal">"Up"</span>:&nbsp;[<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<span class="literal">"Right"</span>:&nbsp;[<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<span class="literal">"Down"</span>:&nbsp;[<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<span class="literal">"Up"</span>:&nbsp;[<span class="literal">"Stop"</span>]}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;]<br/>}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li></ol></li><li class="problem">
<span class="text">Suppose we represent BNF grammar definitions using the following Python data structure: a grammar is a list of productions (the first production in the list corresponds to the root production, i.e., the production corresponding to an entire program), each production is a dictionary mapping a non-terminal to a list of choices, and each choice is a list of strings (each string is either a non-terminal or a terminal: if it appears on the left-hand side of a production, it's a non-terminal; otherwise, it's a terminal). For example:</span>
<div class="code"><div class="source"><br/>grammar&nbsp;=&nbsp;[\<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<span class="literal">"formula"</span>:&nbsp;[\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="literal">"true"</span>],\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="literal">"false"</span>],\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="literal">"not"</span>,&nbsp;<span class="literal">"("</span>,&nbsp;<span class="literal">"formula"</span>,&nbsp;<span class="literal">")"</span>],\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="literal">"and"</span>,&nbsp;<span class="literal">"("</span>,&nbsp;<span class="literal">"formula"</span>,&nbsp;<span class="literal">","</span>,&nbsp;<span class="literal">"formula"</span>,&nbsp;<span class="literal">")"</span>],\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="literal">"or"</span>,&nbsp;<span class="literal">"("</span>,&nbsp;<span class="literal">"formula"</span>,&nbsp;<span class="literal">","</span>,&nbsp;<span class="literal">"formula"</span>,&nbsp;<span class="literal">")"</span>]\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]\<br/>&nbsp;&nbsp;&nbsp;&nbsp;}\<br/>&nbsp;&nbsp;]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">Implement a Python function <code>analyse()</code> that takes a grammar definition in the above format as its one argument. The function should return a single string (letter case must match):
<ul>
  <li><code>"Predictive"</code> if the grammar can be parsed with a <a href="#47254608df414ace8d04c630a2b15689">predictive recursive descent parsing algorithm</a>;
  <li><code>"Backtracking"</code> if the grammar can be parsed with a <a href="#95cb72f5b4d24ddba2c8081c7b42618a">backtracking recursive descent parsing algorithm</a>;
  <li><code>"Neither"</code> if the grammar fall into neither of the above categories.
</ul>
<b>Hint:</b> if you employ Python list and set comprehensions, your solution should be about five lines long; to get a list of keys in a dictionary <code>d</code>, you can use <code>[key for key in d]</code>; <b style="color:green;">to get the list of keys in a list of dictionaries, you can use <code>[key for d in ds for key in d]</code>;</b> and to check whether a string <code>x</code> is in a list or set <code>X</code>, you can use <code>x in X</code>.</span></li><li class="problem">
<span class="text">In this problem you will implement a complete parser for a programming language with the following grammar definition:</span>
<span class="text"><table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>print</b> <i>formula</i> <b>;</b> <i>program</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>print</b> <i>term</i> <b>;</b> <i>program</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>assign</b> <i>variable</i> <b>:=</b> <i>term</i> <b>;</b> <i>program</i></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>end</b> <b>;</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>formula</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>false</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;"> 
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>not (</b> <i>formula</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>and (</b> <i>formula</i> <b>,</b> <i>formula</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>or (</b> <i>formula</i> <b>,</b> <i>formula</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>equal (</b> <i>term</i> <b>,</b> <i>term</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>less (</b> <i>term</i> <b>,</b> <i>term</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>term</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>plus (</b> <i>term</i> <b>,</b> <i>term</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
            <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>mult (</b> <i>term</i> <b>,</b> <i>term</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
            <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>log (</b> <i>term</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
            <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>variable</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
            <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>number</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>variable</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <code>[a-z][A-Za-z]*</code> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>number</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <code>[1-9][0-9]*</code>
</td></tr></table></td></tr></table></span>
<span class="text">In addition to a function corresponding to the tokenization algorithm, the parser implementation will consist of five interdependent Python functions: <code>program()</code>, <code>formula()</code>, <code>term()</code>, <code>variable()</code>, and <code>number()</code>. Each function corresponds to one of the productions. Below is an implementation of <code>number()</code>:</span>
<div class="code"><div class="source"><br/><span class="keyword">import</span>&nbsp;re<br/><span class="keyword">def</span>&nbsp;number(tokens):<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;re.compile(r<span class="literal">"[1-9][0-9]*"</span>).match(tokens[0]):<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;({<span class="literal">"Number"</span>:&nbsp;[<span class="builtin">int</span>(tokens[0])]},&nbsp;tokens[1:])<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">You should examine (either manually or automatically) each of the other productions to determine whether a <a href="#47254608df414ace8d04c630a2b15689">predictive recursive descent</a> parser or a <a href="#95cb72f5b4d24ddba2c8081c7b42618a">backtracking recursive descent</a> parser is required. You should also make calls within each function to one or more of the other functions as needed.</span>
<span class="text"><p>Your algorithm must parse all programs in this programming language correctly. However, it need not return useful error messages if the input provided does not conform to the grammar definition.</p></span><ol class="parts"><li class="part">
<span class="text">Implement a function <code>variable()</code> that takes a single token string as an argument and, if the token sequence conforms to the grammar definition, returns a tuple containing two values: an instance of the abstract syntax (i.e., parse tree) with the root node label <code>"Variable"</code>, and the remaining, unparsed suffix of the input token sequence.</span></li><li class="part">
<span class="text">Implement a function <code>term()</code> that takes a single token string as an argument and, if the token sequence conforms to the grammar definition, returns a tuple containing two values: an instance of the abstract syntax (i.e., parse tree) with an appropriate root node label (<code>"Plus"</code>, <code>"Mult"</code>, <code>"Log"</code>, <code>"Variable"</code>, or <code>"Number"</code>), and the remaining, unparsed suffix of the input token sequence.</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;term([<span class="literal">'log'</span>,&nbsp;<span class="literal">'('</span>,&nbsp;<span class="literal">'mult'</span>,&nbsp;<span class="literal">'('</span>,&nbsp;<span class="literal">'2'</span>,&nbsp;<span class="literal">','</span>,&nbsp;<span class="literal">'3'</span>,&nbsp;<span class="literal">')'</span>,&nbsp;<span class="literal">')'</span>])<br/>{&nbsp;<span class="literal">"Log"</span>:&nbsp;[<br/>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<span class="literal">"Mult"</span>:&nbsp;[<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<span class="literal">"Number"</span>:&nbsp;[2]},&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<span class="literal">"Number"</span>:&nbsp;[3]}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;]<br/>}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li><li class="part">
<span class="text">Implement a function <code>formula()</code> that takes a single token string as an argument and, if the token sequence conforms to the grammar definition, returns a tuple containing two values: an instance of the abstract syntax (i.e., parse tree) with an appropriate root node label (<code>"True"</code>, <code>"False"</code>, <code>"Not"</code>, <code>"And"</code>, <code>"Or"</code>, <code>"Equal"</code>, or <code>"Less"</code>), and the remaining, unparsed suffix of the input token sequence.</span></li><li class="part">
<span class="text">Implement a function <code>program()</code> that takes a single token string as an argument and, if the token sequence conforms to the grammar definition, returns a tuple containing two values: an instance of the abstract syntax (i.e., parse tree) with an appropriate root node label (<code>"Print"</code>, <code>"Assign"</code>, or <code>"End"</code>), and the remaining, unparsed suffix of the input token sequence.</span></li><li class="part">
<span class="text">Implement a function <code>complete()</code> that takes a single string as an argument. If the input string conforms to the grammar of the programming language, the function should return a parse tree corresponding to that input string.</span></li></ol></li><li class="problem">
<span class="text"><b>Extra credit:</b> Extend or modify your parser from the previous problem to support the following grammar:</span>
<span class="text"><table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>print</b> <i>formula</i> <b>;</b> <i>program</i> | <b>print</b> <i>term</i> <b>;</b> <i>program</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>assign</b> <i>variable</i> <b>:=</b> <i>term</i> <b>;</b> <i>program</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>end</b> <b>;</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>variable</i> <b>:=</b> <i>term</i> <b>;</b> <i>program</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>formula</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> | <b>false</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;"> 
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>not (</b> <i>formula</i> <b>)</b> | <b>and (</b> <i>formula</i> <b>,</b> <i>formula</i> <b>)</b> | <b>or (</b> <i>formula</i> <b>,</b> <i>formula</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>equal (</b> <i>term</i> <b>,</b> <i>term</i> <b>)</b> | <b>less (</b> <i>term</i> <b>,</b> <i>term</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>(</b> <i>formula</i> <b>and</b> <i>formula</i> <b>)</b> | <b>(</b> <i>formula</i> <b>or</b> <i>formula</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>(</b> <i>term</i> <b>==</b> <i>term</i> <b>)</b> | <b>(</b> <i>term</i> <b>&lt;</b> <i>term</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>term</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>plus (</b> <i>term</i> <b>,</b> <i>term</i> <b>)</b> | <b>mult (</b> <i>term</i> <b>,</b> <i>term</i> <b>)</b> | <b>log (</b> <i>term</i> <b>)</b>  | <i>variable</i> | <i>number</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
            <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>(</b> <i>term</i> <b>+</b> <i>term</i> <b>)</b> | <b>(</b> <i>term</i> <b>*</b> <i>term</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>variable</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <code>[a-z][A-Za-z]*</code> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>number</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <code>[1-9][0-9]*</code>
</td></tr></table></td></tr></table></span>
<span class="text">The language that conforms to the above grammar is a strict superset of the language in the previous problem, so your solution should behave the same way as before on the subset of the language in the previous problem. You may use the same parse tree labels for both the prefix and infix notation for each construct and operator (<code>assign</code> ... <code>:=</code> corresponds to <code>:=</code>, <code>==</code> corresponds to <code>equal</code>, <code>&lt;</code> corresponds to <code>less</code>, <code>+</code> corresponds to <code>plus</code>, and <code>*</code> corresponds to <code>mult</code>).</span></li></ol>
</div><hr/><br/>
  <a name="3.4"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#3.4">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">3.4.</span> More parsing examples and building parsers for other classes of grammar</h3>
<a name="7c9969979aa04b03a4fbecdaca21880e"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#7c9969979aa04b03a4fbecdaca21880e">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="exercise_required"><b>Exercise:</b> 
        
<span class="text">Consider the following grammar definition:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>command</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>start</b>  </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>suspend</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>wake</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>terminate</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>reboot</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>if</b> <i>condition</i> <b>then</b> <i>command</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>if</b> <i>condition</i> <b>then</b> <i>command</i> <b>else</b> <i>command</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>repeat</b> <i>command</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>while</b> <i>condition</i> <b>then</b> <i>command</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>condition</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>power low</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>temperature high</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>temperature very low</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>user input</b>
</td></tr></table></td></tr></table>
Suppose we want to implement a parser for the above grammar. A partial implementation of a parser for the above grammar (what has been presented in lecture so far) is provided below.</span>
	    
<div class="code"><div class="source"><br/><span class="keyword">def</span>&nbsp;command(tokens,&nbsp;top&nbsp;=&nbsp;<span class="builtin">True</span>):<br/>&nbsp;&nbsp;&nbsp;&nbsp;seqs&nbsp;=&nbsp;{\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="literal">"Start"</span>,&nbsp;<span class="literal">"start"</span>),\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="literal">"Suspend"</span>,&nbsp;<span class="literal">"suspend"</span>),\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="literal">"Wake"</span>,&nbsp;<span class="literal">"wake"</span>),\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="literal">"Terminate"</span>,&nbsp;<span class="literal">"terminate"</span>),\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="literal">"Reboot"</span>,&nbsp;<span class="literal">"reboot"</span>)\<br/>	&nbsp;&nbsp;&nbsp;}<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;(key,&nbsp;value)&nbsp;<span class="keyword">in</span>&nbsp;seqs:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[0]&nbsp;==&nbsp;value:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokens&nbsp;=&nbsp;tokens[1:]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="keyword">not</span>&nbsp;top&nbsp;<span class="keyword">or</span>&nbsp;<span class="builtin">len</span>(tokens)&nbsp;==&nbsp;0:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;(key,&nbsp;tokens)<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[0]&nbsp;==&nbsp;<span class="literal">'repeat'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;command(tokens[1:],&nbsp;<span class="builtin">False</span>)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="keyword">not</span>&nbsp;r&nbsp;<span class="keyword">is</span>&nbsp;<span class="builtin">None</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(e,&nbsp;tokens)&nbsp;=&nbsp;r<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="keyword">not</span>&nbsp;top&nbsp;<span class="keyword">or</span>&nbsp;<span class="builtin">len</span>(tokens)&nbsp;==&nbsp;0:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;({<span class="literal">"Repeat"</span>:&nbsp;[e]},&nbsp;tokens)<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[0]&nbsp;==&nbsp;<span class="literal">'while'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;condition(tokens[1:],&nbsp;<span class="builtin">False</span>)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="keyword">not</span>&nbsp;r&nbsp;<span class="keyword">is</span>&nbsp;<span class="builtin">None</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(e1,&nbsp;tokens)&nbsp;=&nbsp;r<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[0]&nbsp;==&nbsp;<span class="literal">'then'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;command(tokens[1:],&nbsp;<span class="builtin">False</span>)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="keyword">not</span>&nbsp;r&nbsp;<span class="keyword">is</span>&nbsp;<span class="builtin">None</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(e2,&nbsp;tokens)&nbsp;=&nbsp;r			<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="keyword">not</span>&nbsp;top&nbsp;<span class="keyword">or</span>&nbsp;<span class="builtin">len</span>(tokens)&nbsp;==&nbsp;0:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;({<span class="literal">"While"</span>:&nbsp;[e1,e2]},&nbsp;tokens)<br/><br/><span class="keyword">def</span>&nbsp;condition(tokens,&nbsp;top&nbsp;=&nbsp;True):<br/>&nbsp;&nbsp;&nbsp;&nbsp;seqs&nbsp;=&nbsp;[\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="literal">"PowerLow"</span>,&nbsp;[<span class="literal">"power"</span>,&nbsp;<span class="literal">"low"</span>]),\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="literal">"TempHigh"</span>,&nbsp;[<span class="literal">"temperature"</span>,&nbsp;<span class="literal">"high"</span>]),\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="literal">"UserInput"</span>,&nbsp;[<span class="literal">"user"</span>,&nbsp;<span class="literal">"input"</span>])\<br/>	&nbsp;&nbsp;&nbsp;]<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;(key,&nbsp;seq)&nbsp;<span class="keyword">in</span>&nbsp;seqs:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[0]&nbsp;==&nbsp;seq[0]:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[1]&nbsp;==&nbsp;seq[1]:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokens&nbsp;=&nbsp;tokens[2:]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="keyword">not</span>&nbsp;top&nbsp;<span class="keyword">or</span>&nbsp;<span class="builtin">len</span>(tokens)&nbsp;==&nbsp;0:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;(key,&nbsp;tokens)<br/>	&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
          
<span class="text">It is possible to replace the <code>condition()</code> function with a generic parser for base cases that contain an arbitrary number of terminals in each sequence.
Any call to <code>condition(...)</code> can then be replaced with a call to <code>parseBaseCases(seqsCondition, ...)</code>.</span>
	    
<div class="code"><div class="source"><br/>seqsCondition&nbsp;=&nbsp;[\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="literal">"PowerLow"</span>,&nbsp;[<span class="literal">"power"</span>,&nbsp;<span class="literal">"low"</span>]),\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="literal">"TempHigh"</span>,&nbsp;[<span class="literal">"temperature"</span>,&nbsp;<span class="literal">"high"</span>]),\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="literal">"TempVeryLow"</span>,&nbsp;[<span class="literal">"temperature"</span>,&nbsp;<span class="literal">"very"</span>,&nbsp;<span class="literal">"low"</span>]),\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="literal">"UserInput"</span>,&nbsp;[<span class="literal">"user"</span>,&nbsp;<span class="literal">"input"</span>])\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br/><br/><span class="keyword">def</span>&nbsp;parseBaseCases(seqs,&nbsp;tokens,&nbsp;top&nbsp;=&nbsp;<span class="builtin">True</span>):<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;(key,&nbsp;seq)&nbsp;<span class="keyword">in</span>&nbsp;seqs:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Check&nbsp;if&nbsp;token&nbsp;sequence&nbsp;matches&nbsp;sequence.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;0<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;terminal&nbsp;<span class="keyword">in</span>&nbsp;seq:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;terminal&nbsp;==&nbsp;tokens[i]:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">pass</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">break</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;i&nbsp;+&nbsp;1<br/>				<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Check&nbsp;if&nbsp;the&nbsp;previous&nbsp;loop&nbsp;succeeded.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;i&nbsp;==&nbsp;<span class="builtin">len</span>(seq):<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokens&nbsp;=&nbsp;tokens[<span class="builtin">len</span>(seq):]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;<span class="keyword">not</span>&nbsp;top&nbsp;<span class="keyword">or</span>&nbsp;<span class="builtin">len</span>(tokens)&nbsp;==&nbsp;0:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;(key,&nbsp;tokens)<br/>	&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
      </div></div></div>
<a name="b1e8bae08f134922b2bdc85fd206cbe4"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#b1e8bae08f134922b2bdc85fd206cbe4">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">Consider the following grammar definition:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>formula</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>false</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>not</b> <i>formula</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>(</b> <i>formula</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>formula</i> <b>and</b> <i>formula</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>formula</i> <b>or</b> <i>formula</i> 
</td></tr></table></td></tr></table>
Implementing a naive recursive descent parser, predictive or backtracking, would not work for this grammar. Consider what would happen if we ran the following code on any input:</span>
        
<div class="code"><div class="source"><br/><span class="keyword">def</span>&nbsp;parse(tokens):<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[0]&nbsp;==&nbsp;<span class="literal">'true'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;(<span class="literal">'True'</span>,&nbsp;tokens[1:])<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[0]&nbsp;==&nbsp;<span class="literal">'false'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;(<span class="literal">'False'</span>,&nbsp;tokens[1:])<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;...</span><br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Recursive&nbsp;call,&nbsp;but&nbsp;no&nbsp;tokens&nbsp;consumed.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;(e1,&nbsp;tokens)&nbsp;=&nbsp;parse(tokens)&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[0]&nbsp;==&nbsp;<span class="literal">'and'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(e2,&nbsp;tokens)&nbsp;=&nbsp;parse(tokens[1:])<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;({<span class="literal">'And'</span>:[e1,e2]},&nbsp;tokens[1:])<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;...</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">The above code never terminates, and after a large number of recursive calls are made, the Python interpreter returns an error indicating it is out of stack space.
To get around this problem, one option is to <i>left-factor</i> the grammar so that a recursive call never occurs first for any of the choices.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>formula</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>left</i> <b>and</b> <i>formula</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>left</i> <b>or</b> <i>formula</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>left</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>left</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>false</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>not</b> <i>formula</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>(</b> <i>formula</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
</td></tr></table></td></tr></table>
The above is usually acceptable if the operator, such as <b>and</b>, is commutative or right-associative. However, if the operator is left-associative, the above strategy would not necessarily lead to a correct parse tree. Can you explain why? In such a scenario, other techniques would need to be employed. If the operator is indeed associative or right-associative, however, the parser implementation could then look something like the following:</span>
        
<div class="code"><div class="source"><br/><span class="keyword">def</span>&nbsp;formula(tokens):<br/>&nbsp;&nbsp;&nbsp;&nbsp;(e1,&nbsp;tokens)&nbsp;=&nbsp;left(tokens)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[0]&nbsp;==&nbsp;<span class="literal">'and'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(e2,&nbsp;tokens)&nbsp;=&nbsp;formula(tokens[1:])<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;({<span class="literal">'And'</span>:[e1,e2]},&nbsp;tokens[1:])<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;...</span><br/><br/><span class="keyword">def</span>&nbsp;left(tokens):<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[0]&nbsp;==&nbsp;<span class="literal">'true'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;(<span class="literal">'True'</span>,&nbsp;tokens[1:])<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tokens[0]&nbsp;==&nbsp;<span class="literal">'false'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;(<span class="literal">'False'</span>,&nbsp;tokens[1:])<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;...</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">Note that performing left factoring does <i>not</i> change the definition of the concrete syntax, the definition of the abstract syntax of a language (i.e., the set of parse trees), or the meaning of a language. Left factoring is merely a strategy for converting a grammar definition into a definition that is easier to implement using a recursive descent parser; it is an implementation strategy, not a definition. Thus, the resulting parse trees should contain no record or indication that the grammar was left-factored before the parser was implemented.</span>
      </div></div></div></div>
</div>
<a name="4"></a>
<div class="section"><hr style="margin-bottom:120px;"/><h2 class="linked"><span class="link-title">[<a href="#4">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">4.</span> Semantics, Evaluation, and Interpretation</h2>
  <a name="4.1"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#4.1">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">4.1.</span> Formally defining an abstract syntax</h3>
<span class="text">While the abstract syntax of a programming language is the set of data structure instances that represent programs, it is also useful to model the abstract syntax as a mathematical object in its own right. This makes it possible to define formally (i.e., mathematically, independently of any implementation language, platform, operating system, and so on) the meaning of a language, and how programs can be run. It also makes it possible to formally define analyses on programs, as well as properties of transformations over programs.</span>
<span class="text">Typically, an abstract syntax definition will closely match a concrete syntax definition, except that there is no need to specify the token set, and redundant syntactic constructs and syntactic sugar will be eliminated. For example, parentheses are a syntactic convention that is not necessary if one is working with parse trees because parse trees are already grouped implicitly due to the tree structure of the abstract syntax instance.</span>
<a name="7bf280c88ee14a299c3490762a33e4dd"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#7bf280c88ee14a299c3490762a33e4dd">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">The following is an example of an abstract syntax definition.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>formula</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> | <b>false</b> | <b>not</b> <i>formula</i> | <i>formula</i> <b>and</b> <i>formula</i> | <i>formula</i> <b>or</b> <i>formula</i>
</td></tr></table></td></tr></table>
Notice the omission of the parentheses. Also, there is no need to be concerned with the fixity (i.e., infix vs. prefix) of binary operators, since this definition is not being used to implement a parsing algorithm.</span>
      </div></div></div></div>
  <a name="4.2"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#4.2">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">4.2.</span> Denotational semantics and operational semantics</h3>
<span class="text">The abstract syntax of a programming language is a set of symbolic objects (i.e., the abstract syntax instances, such as programs) that have no meaning unless a meaning is assigned to them. There are two ways in which we can assign meaning to these objects. We can choose to assign a mathematical object to each abstract syntax instance, or we can define a collection of deterministic transformations that specify how we can convert each abstract syntax instance into another abstract syntax instance. Roughly speaking, assigning a mathematical object to each program tells us what it <i>means</i>, while specifying symbolic converion rules tells us how to <i>run</i> the program.</span>
<a name="41aa3d27c2754fa880cb8c2280322f63"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#41aa3d27c2754fa880cb8c2280322f63">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="definition_required"><b>Definition:</b> 
The <i>denotational semantics</i> of an abstract syntax is a mapping from the set of abstract syntax instances <i>A</i> to some mathematical set of objects <i>D</i>, which is often called a <i>semantic domain</i> or just <i>domain</i>. The mapping from <i>A</i> to <i>D</i> itself is often denoted using the circumfix Oxford double bracket notation [[ ... ]], and the definition of a denotational semantics of <i>A</i> (i.e., the definition of this mapping [[ ... ]]) is often specified using a collection of inference rules.
      </div></div></div>
<a name="63092f7e13d44b0cac8bde679e6f2c6d"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#63092f7e13d44b0cac8bde679e6f2c6d">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="definition_required"><b>Definition:</b> 
Let <i>A</i> be an abstract syntax of a programming language. The <i>operational semantics</i> of an abstract syntax is a set of rules that specify how each abstract syntax instance <i>a</i> <span style="font-size:12px;">&#8712;</span> <i>A</i> can be transformed some kind of object that represents the result of performing the computation described by <i>A</i>.
      </div></div></div>
<span class="text">There are distinct kinds of operational semantics, such as <i>small-step semantics</i> and <i>big-step semantics</i> (also known as <i>natural semantics</i>). In this course, the operational semantics we will be using is closest to big-step semantics, with some simplifications. We adopt this particular approach to defining operational semantics because it corresponds more closely to a functional, recursive implementation of an algorithm for interpreting programs.
<br/><br/>
The operational semantics for a programming language represents a <i>contract</i>, a set of <i>constraints</i>, or a set of <i>requirements</i> that an algorithm that implementing an interpreter or compiler of that language must respect in order to be considered correct. However, whoever builds an implementation of an interpreter or compiler for a language has full freedom and flexibility in how they choose to implement the interpreter in all other aspects as long as it conforms to the operational semantics. This is what makes it possible to introduce optimizations into interpreters and compilers (such as optimizations to improve performance or reduce use of memory) while preserving the correctness of their behavior. The operational semantics for a programming language is defined using a collection of <i>inference rules</i>.</span>
<a name="9af40ca04b2f44c795bbb02e7bed83ef"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#9af40ca04b2f44c795bbb02e7bed83ef">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="definition_required"><b>Definition:</b> 
        
<span class="text">An <i>inference rule</i> is a notation used within mathematics and computer science to define relationships between mathematical facts and formulas. Each inference rule consists of a horizontal line with zero or more logical formulas above the line and one logial formula below the line. The logical formulas above the line are called <i>premises</i>, and the formula below the line is called the <i>conclusion</i>.</span>
        <div class="inferences"><table class="inference"><tr><td class="title">[Name-of-Inference-Rule]</td><td><table><tr><td class="premises">&nbsp;<i>premise</i> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>premise</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>conclusion</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Example]</td><td><table><tr><td class="premises">&nbsp;<b>sun is out</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <b>sky is clear</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>it is not raining</b>&nbsp;</td></tr></table></td></tr></table></div>
        
<span class="text">An inference rule can be interpreted as a portion of a larger algorithm. The premises specify the recursive calls, or calls to other functions, that may need to be made, and the results that are obtained from those invocations. The conclusion specifies what inputs can be handled by that inference rule, and what outputs should be returned given those inputs and the premises.</span>
        <div class="inferences"><table class="inference"><tr><td class="title">[Algorithm-Case]</td><td><table><tr><td class="premises">&nbsp;<i>input<sub>1</sub></i> &dArr; <i>output<sub>1</sub></i> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>input<sub>2</sub></i> &dArr; <i>output<sub>2</sub></i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>input<sub>0</sub></i> &dArr; <i>output<sub>0</sub></i>&nbsp;</td></tr></table></td></tr></table></div>
        
<span class="text">Note that in the above, <i>input<sub>1</sub></i> and <i>input<sub>2</sub></i> may depend on <i>input<sub>0</sub></i>, and <i>output<sub>0</sub></i> may depend on <i>output<sub>1</sub></i> and <i>output<sub>2</sub></i>. In other words, one could rewrite an inference rule in the following way using natural language:</span>
        <div class="inferences"><table class="inference"><tr><td class="title">[Algorithm-Case]</td><td><table><tr><td class="premises">&nbsp;<b>invoking this or another algorithm with</b> <i>input<sub>1</sub></i> <b>yields</b> <i>output<sub>1</sub></i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>given</b> <i>input<sub>0</sub></i>, <b> and if premises above are true, then output</b> <i>output<sub>0</sub></i>&nbsp;</td></tr></table></td></tr></table></div>
       </div></div></div></div>
  <a name="4.3"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#4.3">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">4.3.</span> Evaluation of expressions</h3>
<span class="text">The abstract syntax, or a subset of the abstract syntax, of a programming language is considered to be a set of <i>expressions</i> if the language's operational semantics do not impose any restrictions on the <i>order</i> in which a computation can operate on the expression to produce a result, called a <i>value</i>. This is possible because expressions usually represent operations with no <i>side effects</i>, such as emitting output to a screen, reading or writing files, looking at a clock, controlling a device, and so on.</span>
<a name="b16e887dc1bc430da525e124a5f603b1"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#b16e887dc1bc430da525e124a5f603b1">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="definition_required"><b>Definition:</b> 
Let <i>A</i> be an abstract syntax of a programming language, and let <i>V</i> be some subset of <i>A</i> that we will call the <i>value set</i>. This set will represent the possible meanings of parse trees in <i>A</i>, and it will represent the possible results of evaluating parse trees in <i>A</i>. Values that can occur directly within abstract syntax trees of the language (e.g., numeric and string literals, constructors, and so on) are usually called <i>constants</i>.
      </div></div></div>
<a name="53f0258543cc4f4592e7dc534bdfff60"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#53f0258543cc4f4592e7dc534bdfff60">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="definition_required"><b>Definition:</b> 
An <i>evaluation algorithm</i> converts any abstract syntax tree that represents an expression into an abstract syntax tree that represents a value.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">expressions<br/>(abstract syntax)</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">evaluation<br/>algorithm</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">values<br/>(abstract syntax)</td>
  </tr>
</table>
</div>
      </div></div></div>
<a name="634d9dc447034b4abc749a6713b63c19"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#634d9dc447034b4abc749a6713b63c19">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">Define the abstract syntax according to the following grammar, with <i>A</i> consisting of all formula abstract syntax instances, and <i>V</i> = {<b>true</b>, <b>false</b>} consisting of all value abstract syntax instances:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>formula</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>value</i> | <b>not</b> <i>formula</i> | <i>formula</i> <b>and</b> <i>formula</i> | <i>formula</i> <b>or</b> <i>formula</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>value</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> | <b>false</b>
</td></tr></table></td></tr></table>
The following is a definition of an operational semantics for this language.</span>
        <div class="inferences"><table class="inference"><tr><td class="title">[True]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>true</b> &dArr; <b>true</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[False]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>false</b> &dArr; <b>false</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Not-True]</td><td><table><tr><td class="premises">&nbsp;<i>f</i> &dArr; <b>true</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>not</b> <i>f</i> &dArr; <b>false</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Not-False]</td><td><table><tr><td class="premises">&nbsp;<i>f</i> &dArr; <b>false</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>not</b> <i>f</i> &dArr; <b>true</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[And-True-True]</td><td><table><tr><td class="premises">&nbsp;<i>f</i><sub>1</sub> &dArr; <b>true</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>f</i><sub>2</sub> &dArr; <b>true</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>f</i><sub>1</sub> <b>and</b> <i>f</i><sub>2</sub> &dArr; <b>true</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[And-True-False]</td><td><table><tr><td class="premises">&nbsp;<i>f</i><sub>1</sub> &dArr; <b>true</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>f</i><sub>2</sub> &dArr; <b>false</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>f</i><sub>1</sub> <b>and</b> <i>f</i><sub>2</sub> &dArr; <b>false</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[And-False-True]</td><td><table><tr><td class="premises">&nbsp;<i>f</i><sub>1</sub> &dArr; <b>false</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>f</i><sub>2</sub> &dArr; <b>true</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>f</i><sub>1</sub> <b>and</b> <i>f</i><sub>2</sub> &dArr; <b>false</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[And-False-False]</td><td><table><tr><td class="premises">&nbsp;<i>f</i><sub>1</sub> &dArr; <b>false</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>f</i><sub>2</sub> &dArr; <b>false</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>f</i><sub>1</sub> <b>and</b> <i>f</i><sub>2</sub> &dArr; <b>false</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Or-True-True]</td><td><table><tr><td class="premises">&nbsp;<i>f</i><sub>1</sub> &dArr; <b>true</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>f</i><sub>2</sub> &dArr; <b>true</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>f</i><sub>1</sub> <b>or</b> <i>f</i><sub>2</sub> &dArr; <b>true</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Or-True-False]</td><td><table><tr><td class="premises">&nbsp;<i>f</i><sub>1</sub> &dArr; <b>true</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>f</i><sub>2</sub> &dArr; <b>false</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>f</i><sub>1</sub> <b>or</b> <i>f</i><sub>2</sub> &dArr; <b>true</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Or-False-True]</td><td><table><tr><td class="premises">&nbsp;<i>f</i><sub>1</sub> &dArr; <b>false</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>f</i><sub>2</sub> &dArr; <b>true</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>f</i><sub>1</sub> <b>or</b> <i>f</i><sub>2</sub> &dArr; <b>true</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Or-False-False]</td><td><table><tr><td class="premises">&nbsp;<i>f</i><sub>1</sub> &dArr; <b>false</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>f</i><sub>2</sub> &dArr; <b>false</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>f</i><sub>1</sub> <b>or</b> <i>f</i><sub>2</sub> &dArr; <b>false</b>&nbsp;</td></tr></table></td></tr></table></div>
      </div></div></div>
<a name="60b6dc0bb16b498594677f3bb08ccc82"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#60b6dc0bb16b498594677f3bb08ccc82">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">The rules in the above example are numerous, and having this many rules in a definition becomes impractical (especially with more complex operators and language constructs). To address this, we can define a meta-language on the set of values <i>V</i> = {<b>true</b>, <b>false</b>}.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">&not; <b>true</b> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>false</b></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
&not; <b>false</b> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<b>true</b> &and; <b>true</b> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<b>true</b> &and; <b>false</b> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>false</b></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<b>false</b> &and; <b>true</b> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>false</b></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<b>false</b> &and; <b>false</b> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>false</b></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<b>true</b> &or; <b>true</b> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<b>true</b> &or; <b>false</b> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<b>false</b> &or; <b>true</b> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<b>false</b> &or; <b>false</b> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>false</b>
</td></tr></table></td></tr></table>
The definition then becomes more concise.</span>
        <div class="inferences"><table class="inference"><tr><td class="title">[True]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>true</b> &dArr; <b>true</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[False]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>false</b> &dArr; <b>false</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Not]</td><td><table><tr><td class="premises">&nbsp;<i>f</i> &dArr; <i>v</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>not</b> <i>f</i> &dArr; &not; <i>v</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[And]</td><td><table><tr><td class="premises">&nbsp;<i>f</i><sub>1</sub> &dArr; <i>v</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>f</i><sub>2</sub> &dArr; <i>v</i><sub>2</sub>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>f</i><sub>1</sub> <b>and</b> <i>f</i><sub>2</sub> &dArr; <i>v</i><sub>1</sub> &and; <i>v</i><sub>2</sub>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Or]</td><td><table><tr><td class="premises">&nbsp;<i>f</i><sub>1</sub> &dArr; <i>v</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>f</i><sub>2</sub> &dArr; <i>v</i><sub>2</sub>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>f</i><sub>1</sub> <b>or</b> <i>f</i><sub>2</sub> &dArr; <i>v</i><sub>1</sub> &or; <i>v</i><sub>2</sub>&nbsp;</td></tr></table></td></tr></table></div>
        
<span class="text">We can convert the above operational semantics inference rules into a Python implementation of an interpreter for this simple language. The functions <code>vnot</code>, <code>vand</code>, and <code>vor</code> correspond to &not;, &and;, and &or;, respectively, in the operational semantics.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">def</span>&nbsp;vnot(v):<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;v&nbsp;==&nbsp;<span class="literal">'True'</span>:&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="literal">'False'</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;v&nbsp;==&nbsp;<span class="literal">'False'</span>:&nbsp;<span class="keyword">return</span>&nbsp;<span class="literal">'True'</span><br/><br/><span class="keyword">def</span>&nbsp;vand(v1,&nbsp;v2):<br/>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;v1&nbsp;==&nbsp;<span class="literal">'True'</span>&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;v2&nbsp;==&nbsp;<span class="literal">'True'</span>:&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="literal">'True'</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;v1&nbsp;==&nbsp;<span class="literal">'True'</span>&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;v2&nbsp;==&nbsp;<span class="literal">'False'</span>:&nbsp;<span class="keyword">return</span>&nbsp;<span class="literal">'False'</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;v1&nbsp;==&nbsp;<span class="literal">'False'</span>&nbsp;<span class="keyword">and</span>&nbsp;v2&nbsp;==&nbsp;<span class="literal">'True'</span>:&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="literal">'False'</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;v1&nbsp;==&nbsp;<span class="literal">'False'</span>&nbsp;<span class="keyword">and</span>&nbsp;v2&nbsp;==&nbsp;<span class="literal">'False'</span>:&nbsp;<span class="keyword">return</span>&nbsp;<span class="literal">'False'</span><br/><br/><span class="keyword">def</span>&nbsp;vor(v1,&nbsp;v2):<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;v1&nbsp;==&nbsp;<span class="literal">'True'</span>&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;v2&nbsp;==&nbsp;<span class="literal">'True'</span>:&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="literal">'True'</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;v1&nbsp;==&nbsp;<span class="literal">'True'</span>&nbsp;&nbsp;<span class="keyword">and</span>&nbsp;v2&nbsp;==&nbsp;<span class="literal">'False'</span>:&nbsp;<span class="keyword">return</span>&nbsp;<span class="literal">'True'</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;v1&nbsp;==&nbsp;<span class="literal">'False'</span>&nbsp;<span class="keyword">and</span>&nbsp;v2&nbsp;==&nbsp;<span class="literal">'True'</span>:&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="literal">'True'</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;v1&nbsp;==&nbsp;<span class="literal">'False'</span>&nbsp;<span class="keyword">and</span>&nbsp;v2&nbsp;==&nbsp;<span class="literal">'False'</span>:&nbsp;<span class="keyword">return</span>&nbsp;<span class="literal">'False'</span><br/><br/>Node&nbsp;=&nbsp;<span class="builtin">dict</span><br/>Leaf&nbsp;=&nbsp;<span class="builtin">str</span><br/><br/><span class="keyword">def</span>&nbsp;evaluate(e):<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="builtin">type</span>(e)&nbsp;==&nbsp;Node:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;label&nbsp;<span class="keyword">in</span>&nbsp;e:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;children&nbsp;=&nbsp;e[label]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Not'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;children[0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;evaluate(f)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;vnot(v)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">elif</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'And'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Notice&nbsp;that&nbsp;we&nbsp;can&nbsp;make&nbsp;the&nbsp;recursive&nbsp;calls</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;below&nbsp;in&nbsp;any&nbsp;order&nbsp;we&nbsp;like;&nbsp;the&nbsp;order&nbsp;of&nbsp;the</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;calls&nbsp;is&nbsp;not&nbsp;specified&nbsp;by&nbsp;the&nbsp;operational</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;semantics.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f1&nbsp;=&nbsp;children[0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1&nbsp;=&nbsp;evaluate(f1)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f2&nbsp;=&nbsp;children[1]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v2&nbsp;=&nbsp;evaluate(f2)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;vand(v1,&nbsp;v2)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">elif</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Or'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f2&nbsp;=&nbsp;children[1]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v2&nbsp;=&nbsp;evaluate(f2)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f1&nbsp;=&nbsp;children[0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1&nbsp;=&nbsp;evaluate(f1)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;vor(v1,&nbsp;v2)<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">elif</span>&nbsp;<span class="builtin">type</span>(e)&nbsp;==&nbsp;Leaf:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;e&nbsp;==&nbsp;<span class="literal">'True'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="literal">'True'</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;e&nbsp;==&nbsp;<span class="literal">'False'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="literal">'False'</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">In fact, we could convert the above so that it returns a Python value directly, rather than an abstract syntax tree corresponding to a value.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">def</span>&nbsp;evaluate(e):<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="builtin">type</span>(e)&nbsp;==&nbsp;Node:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;label&nbsp;<span class="keyword">in</span>&nbsp;e:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;children&nbsp;=&nbsp;e[label]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Not'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;children[0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;evaluate(f)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">not</span>&nbsp;v&nbsp;<span class="comment">#&nbsp;Use&nbsp;the&nbsp;Python&nbsp;not&nbsp;operator.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">elif</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'And'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f1&nbsp;=&nbsp;children[0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1&nbsp;=&nbsp;evaluate(f1)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f2&nbsp;=&nbsp;children[1]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v2&nbsp;=&nbsp;evaluate(f2)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;v1&nbsp;<span class="keyword">and</span>&nbsp;v2&nbsp;<span class="comment">#&nbsp;Use&nbsp;the&nbsp;Python&nbsp;and&nbsp;operator.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">elif</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Or'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f2&nbsp;=&nbsp;children[1]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v2&nbsp;=&nbsp;evaluate(f2)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f1&nbsp;=&nbsp;children[0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1&nbsp;=&nbsp;evaluate(f1)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;v1&nbsp;<span class="keyword">or</span>&nbsp;v2&nbsp;<span class="comment">#&nbsp;Use&nbsp;the&nbsp;Python&nbsp;or&nbsp;operator.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">elif</span>&nbsp;<span class="builtin">type</span>(e)&nbsp;==&nbsp;Leaf:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;e&nbsp;==&nbsp;<span class="literal">'True'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="builtin">True</span>&nbsp;<span class="comment">#&nbsp;Use&nbsp;the&nbsp;Python&nbsp;True&nbsp;constant.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;e&nbsp;==&nbsp;<span class="literal">'False'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="builtin">False</span>&nbsp;<span class="comment">#&nbsp;Use&nbsp;the&nbsp;Python&nbsp;False&nbsp;constant.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
      </div></div></div></div>
  <a name="4.4"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#4.4">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">4.4.</span> Execution of sequences of statements</h3>
<span class="text">The abstract syntax, or a subset of the abstract syntax, of a programming language is considered to be a set of <i>statements</i> if the operational semantics for that syntax impose a sequential ordering on the computation they represent. This usually corresponds to the notion of a single point of <i>control flow</i> traversing the program's abstract syntax as the program is executed (which is a good model of a computer architecture that contains only a single processor that can perform one instruction at a time).
<br/><br/>
Languages that have statements and a notion of control flow are called <i>imperative</i>. Languages that have only expressions and no statements can be called <i>pure</i> or <i>functional</i>, although that terminology will often have additional meanings in such a context that we will go over in subsequent sections.</span>
<a name="db57dc0684174cd097ebf73d733dc9bc"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#db57dc0684174cd097ebf73d733dc9bc">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="definition_required"><b>Definition:</b> 
Let <i>A</i> be an abstract syntax of a programming language, and let <i>V</i> be some subset of <i>A</i>. Let <i>O</i> be a set of possible outputs (e.g., a text terminal or file).
        <ul>
          <li>In this course, we will denote a possible output in <i>O</i> using the symbol <i>o</i>.</li>
          <li>We denote the empty output using <i>o</i><sub>0</sub>.</li>
          <li>We denote an output <i>o</i> <b>preceded</b> by the value <i>v</i> as <i>v</i>;<i>o</i> (that is, <i>v</i> is the first value in the output <i>v</i>;<i>o</i>, and <i>o</i> is the rest).</li>
          <li>Given two outputs <i>o</i><sub>1</sub> and <i>o</i><sub>2</sub>, <i>o</i><sub>1</sub>;<i>o</i><sub>2</sub> represents two outputs in sequence: <i>o</i><sub>1</sub> followed by <i>o</i><sub>2</sub>.</li>
        </ul>
      </div></div></div>
<a name="28221c6d8fdd4748bd22545462178e97"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#28221c6d8fdd4748bd22545462178e97">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="definition_required"><b>Definition:</b> 
An <i>execution algorithm</i> converts any abstract syntax tree that represents a sequence of statements into an abstract syntax tree that represents an output.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">statement sequence<br/>(abstract syntax)</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">execution<br/>algorithm</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">output<br/>(record of side effects)</td>
  </tr>
</table>
</div>
      </div></div></div>
<span class="text">Thus, we can represent an output in Python using, for example, a list of values.</span>
<a name="5dead3e1ed524b24a68fc4f4b393eb8a"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#5dead3e1ed524b24a68fc4f4b393eb8a">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">We present an operational semantics for a simple programming language with statements. 
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>print</b> <i>formula</i> <b>;</b> <i>program</i> | <b>end</b> <b>;</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>formula</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>value</i> | <b>not</b> <i>formula</i> | <i>formula</i> <b>and</b> <i>formula</i> | <i>formula</i> <b>or</b> <i>formula</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>value</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> | <b>false</b>
</td></tr></table></td></tr></table>
Recall that <i>O</i> represents the set of outputs (e.g., to the terminal), with <i>o</i><sub>0</sub> representing the empty output and <i>v</i>;<i>o</i> representing a terminal <i>o</i> with the value <i>v</i> as its first output.</span>
        <div class="inferences"><table class="inference"><tr><td class="title">[Statement-Print]</td><td><table><tr><td class="premises">&nbsp;<i>p</i> &dArr; <i>o</i> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>f</i> &dArr; <i>v</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>print</b> <i>f</i> <b>;</b> <i>p</i> &dArr; <i>v</i>;<i>o</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-End]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>end ;</b> &dArr; <i>o</i><sub>0</sub>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-True]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>true</b> &dArr; <b>true</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-False]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>false</b> &dArr; <b>false</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-Not]</td><td><table><tr><td class="premises">&nbsp;<i>f</i> &dArr; <i>v</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>not</b> <i>f</i> &dArr; &not; <i>v</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-And]</td><td><table><tr><td class="premises">&nbsp;<i>f</i><sub>1</sub> &dArr; <i>v</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>f</i><sub>2</sub> &dArr; <i>v</i><sub>2</sub>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>f</i><sub>1</sub> <b>and</b> <i>f</i><sub>2</sub> &dArr; <i>v</i><sub>1</sub> &and; <i>v</i><sub>2</sub>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-Or]</td><td><table><tr><td class="premises">&nbsp;<i>f</i><sub>1</sub> &dArr; <i>v</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>f</i><sub>2</sub> &dArr; <i>v</i><sub>2</sub>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>f</i><sub>1</sub> <b>or</b> <i>f</i><sub>2</sub> &dArr; <i>v</i><sub>1</sub> &or; <i>v</i><sub>2</sub>&nbsp;</td></tr></table></td></tr></table></div>
        
<span class="text">We can convert the above operational semantics inference rules into a Python implementation of an interpreter for this simple language. We represent outputs in <i>O</i> as Python lists of values, because lists preserve order. Note that we refer to the implementation of <code>evaluate()</code> from a <a href="60b6dc0bb16b498594677f3bb08ccc82">previous example</a>.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">def</span>&nbsp;execute(s):<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="builtin">type</span>(s)&nbsp;==&nbsp;Leaf:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;s&nbsp;==&nbsp;<span class="literal">'End'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;[]<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">elif</span>&nbsp;<span class="builtin">type</span>(s)&nbsp;==&nbsp;Node:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;label&nbsp;<span class="keyword">in</span>&nbsp;s:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Print'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;children&nbsp;=&nbsp;s[label]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;children[0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;children[1]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;evaluate(f)&nbsp;<span class="comment">#&nbsp;Implemented&nbsp;elsewhere.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o&nbsp;=&nbsp;execute(p)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;[v]&nbsp;+&nbsp;o<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">As before, we can actually use the Python <code>print()</code> function and turn this into an interpreter that uses the Python runtime system directly to interpret the program. However, we must be careful about where we put the call to <code>print()</code>: it must be invoked in a way that conforms to a <i>pre-order</i> traversal of the syntax tree.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">def</span>&nbsp;execute(s):<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="builtin">type</span>(s)&nbsp;==&nbsp;Leaf:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;s&nbsp;==&nbsp;<span class="literal">'End'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;[]<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">elif</span>&nbsp;<span class="builtin">type</span>(s)&nbsp;==&nbsp;Node:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;label&nbsp;<span class="keyword">in</span>&nbsp;s:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Print'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;children&nbsp;=&nbsp;s[label]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;children[0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;children[1]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;evaluate(f)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="builtin">print</span>(v)&nbsp;<span class="comment">#&nbsp;Must&nbsp;appear&nbsp;before&nbsp;recursive&nbsp;call.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o&nbsp;=&nbsp;execute(p)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;[v]&nbsp;+&nbsp;o<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
      </div></div></div>
<span class="text">In an operational semantics for a language with variables and variable assignment, a data structure called an <i>environment</i> is usually used to represent what variables are in scope, as well as the values assigned to variables. We introduce a mathematical definition of an environment so that we can employ it within our operational semantics definitions.</span>
<a name="e1a5053a93d54ad4b02da10e4981b810"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#e1a5053a93d54ad4b02da10e4981b810">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="definition_required"><b>Definition:</b> 
        Given a programming language definition with a set of values <i>V</i> and a set of possible variable names <i>X</i> (as defined by the concrete syntax), an <i>environment</i> or <i>context</i> is a mapping from a subset of the variables <i>X</i> to the set of values <i>V</i>.      
        <ul>
          <li>In this course, we will usually denote an environment using the symbol &Sigma;.</li>
          <li>Given a variable name <i>x</i> <span style="font-size:12px;">&#8712;</span> <i>X</i>, we denote by &Sigma;(<i>x</i>) the value that the environment &Sigma; assigns to <i>x</i>.</li>
          <li>An empty environment (one that does not map any variable names to any values) is denoted using &Sigma;<sub>0</sub>.</li>
          <li>Given an environment &Sigma;, a variable <i>x</i> <span style="font-size:12px;">&#8712;</span> <i>X</i>, and a value <i>v</i> <span style="font-size:12px;">&#8712;</span> <i>V</i>, we denote by &Sigma; &#8846; {<i>x</i> &#x21A6; <i>v</i>} the extension of the environment &Sigma; with a new mapping from <i>x</i> to <i>v</i> (i.e., if &Sigma;' = &Sigma; &#8846; {<i>x</i> &#x21A6; <i>v</i>} then &Sigma;'(<i>x</i>) = <i>v</i>).</li>
        </ul>
      </div></div></div>
<span class="text">We can update our diagram for an execution algorithm.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:#ECECEC;">
      <table class="container">
        <tr>
          <td class="box" style="background-color:powderblue;">environment</td>
          <td class="box" style="background-color:powderblue;">statement sequence<br/>(abstract syntax)</td>
        </tr>
      </table>
    </td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">execution<br/>algorithm</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">output<br/>(record of side effects)</td>
  </tr>
</table>
</div> 
Within implementations of interpreters and compilers, environments will often be represented with finite maps, associative lists, dictionary, or stacks, depending on the structure and semantics of the language.</span>
<a name="cbfa02d3624d42b08704d6a4c4fb9e03"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#cbfa02d3624d42b08704d6a4c4fb9e03">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">We present an operational semantics for a simple programming language with variables and variable assignment.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>print</b> <i>formula</i> <b>;</b> <i>program</i> | <b>assign</b> <i>variable</i> <b>:=</b> <i>formula</i> <b>;</b> <i>program</i> | <b>end</b> <b>;</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>formula</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>value</i> | <i>variable</i> | <b>not</b> <i>formula</i> | <i>formula</i> <b>and</b> <i>formula</i> | <i>formula</i> <b>or</b> <i>formula</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>variable</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid variable name as defined by the concrete syntax</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>value</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> | <b>false</b>
</td></tr></table></td></tr></table>
Notice the use of an environment &Sigma;, also known as a context, that maps variable names to values.</span>
        <div class="inferences"><table class="inference"><tr><td class="title">[Statement-Assign]</td><td><table><tr><td class="premises">&nbsp;&Sigma; &#8846; {<i>x</i> &#x21A6; <i>v</i>}, <i>p</i> &dArr; <i>o</i> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;, <i>f</i> &dArr; <i>v</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <b>assign</b> <i>x</i> <b>:=</b> <i>f</i> <b>;</b> <i>p</i> &dArr; <i>o</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-Print]</td><td><table><tr><td class="premises">&nbsp;&Sigma;, <i>p</i> &dArr; <i>o</i> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;, <i>f</i> &dArr; <i>v</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <b>print</b> <i>f</i> <b>;</b> <i>p</i> &dArr; <i>v</i>;<i>o</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-End]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <b>end ;</b> &dArr; <i>o</i><sub>0</sub>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-True]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <b>true</b> &dArr; <b>true</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-False]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <b>false</b> &dArr; <b>false</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-Not]</td><td><table><tr><td class="premises">&nbsp;&Sigma;, <i>f</i> &dArr; <i>v</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <b>not</b> <i>f</i> &dArr; &not; <i>v</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-And]</td><td><table><tr><td class="premises">&nbsp;&Sigma;, <i>f</i><sub>1</sub> &dArr; <i>v</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;, <i>f</i><sub>2</sub> &dArr; <i>v</i><sub>2</sub>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <i>f</i><sub>1</sub> <b>and</b> <i>f</i><sub>2</sub> &dArr; <i>v</i><sub>1</sub> &and; <i>v</i><sub>2</sub>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-Or]</td><td><table><tr><td class="premises">&nbsp;&Sigma;, <i>f</i><sub>1</sub> &dArr; <i>v</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;, <i>f</i><sub>2</sub> &dArr; <i>v</i><sub>2</sub>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <i>f</i><sub>1</sub> <b>or</b> <i>f</i><sub>2</sub> &dArr; <i>v</i><sub>1</sub> &or; <i>v</i><sub>2</sub>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-Variable]</td><td><table><tr><td class="premises">&nbsp;&Sigma;(<i>x</i>) = <i>v</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <i>x</i> &dArr; <i>v</i>&nbsp;</td></tr></table></td></tr></table></div>
        
<span class="text">We can convert the above operational semantics inference rules into a Python implementation of an interpreter for this language. We represent environments as dictionaries in which variable names are labels, and these labels map to values in the language. The functions <code>vnot</code>, <code>vand</code>, and <code>vor</code> are the same as those in a <a href="60b6dc0bb16b498594677f3bb08ccc82">previous example</a>.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">def</span>&nbsp;evaluate(env,&nbsp;e):<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="builtin">type</span>(e)&nbsp;==&nbsp;Node:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;label&nbsp;<span class="keyword">in</span>&nbsp;e:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;children&nbsp;=&nbsp;e[label]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Not'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;children[0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;evaluate(env,&nbsp;f)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;vnot(v)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">elif</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'And'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f1&nbsp;=&nbsp;children[0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1&nbsp;=&nbsp;evaluate(env,&nbsp;f1)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f2&nbsp;=&nbsp;children[1]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v2&nbsp;=&nbsp;evaluate(env,&nbsp;f2)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;vand(v1,&nbsp;v2)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">elif</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Or'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f2&nbsp;=&nbsp;children[1]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v2&nbsp;=&nbsp;evaluate(env,&nbsp;f2)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f1&nbsp;=&nbsp;children[0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1&nbsp;=&nbsp;evaluate(env,&nbsp;f1)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;vor(v1,&nbsp;v2)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">elif</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Variable'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;children[0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;x&nbsp;<span class="keyword">in</span>&nbsp;env:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;env[x]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(x&nbsp;+&nbsp;<span class="literal">"&nbsp;is&nbsp;unbound."</span>)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="builtin">exit</span>()<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">elif</span>&nbsp;<span class="builtin">type</span>(e)&nbsp;==&nbsp;Leaf:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;e&nbsp;==&nbsp;<span class="literal">'True'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="literal">'True'</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;e&nbsp;==&nbsp;<span class="literal">'False'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="literal">'False'</span><br/><br/><span class="keyword">def</span>&nbsp;execute(env,&nbsp;s):<br/>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;<span class="builtin">type</span>(s)&nbsp;==&nbsp;Leaf:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;s&nbsp;==&nbsp;<span class="literal">'End'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;(env,&nbsp;[])<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">elif</span>&nbsp;<span class="builtin">type</span>(s)&nbsp;==&nbsp;Node:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;label&nbsp;<span class="keyword">in</span>&nbsp;s:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Print'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;children&nbsp;=&nbsp;s[label]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;children[0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;children[1]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;evaluate(env,&nbsp;f)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o&nbsp;=&nbsp;execute(env,&nbsp;p)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;[v]&nbsp;+&nbsp;o<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Assign'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;children&nbsp;=&nbsp;s[label]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;children[0][<span class="literal">'Variable'</span>][0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;children[1]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;children[2]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;evaluate(env,&nbsp;f)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;env[x]&nbsp;=&nbsp;v<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o&nbsp;=&nbsp;execute(env,&nbsp;p)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;o<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
      </div></div></div>
<span class="text">If an abstract syntax parse tree node for a statement can have two or more children that are also statement sequences, and if the operational semantics of the language require that statements must be executed consecutively (i.e., not in parallel), then the execution algorithm must also return a new copy of the environment, modified to reflect the variable assignments that might have occurred in the statement sequence.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:#ECECEC;">
      <table class="container">
        <tr>
          <td class="box" style="background-color:powderblue;">environment</td>
          <td class="box" style="background-color:powderblue;">statement sequence<br/>(abstract syntax)</td>
        </tr>
      </table>
    </td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">execution<br/>algorithm</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:#ECECEC;">
      <table class="container">
        <tr>
          <td class="box" style="background-color:powderblue;">environment</td>
          <td class="box" style="background-color:powderblue;">output<br/>(record of side effects)</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
</div></span>
<a name="c09ab939e50b40428d392867c00b4710"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#c09ab939e50b40428d392867c00b4710">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">We present an operational semantics for an extension of a language in a <a href="#cbfa02d3624d42b08704d6a4c4fb9e03">previous example</a>.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>print</b> <i>formula</i> <b>;</b> <i>program</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
  <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>assign</b> <i>variable</i> <b>:=</b> <i>formula</i> <b>;</b> <i>program</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
  <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>repeat</b> <b>twice</b> <b>{</b> <i>program</i> <b>}</b> <i>program</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
  <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>end</b> <b>;</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
    <td></tr></table></td><td style="text-align:center;"> &#8942; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> 
</td></tr></table></td></tr></table>
An example of a program in this language is presented below:</span>
        
<div class="code"><div class="source"><br/>print&nbsp;true;<br/>repeat&nbsp;twice&nbsp;{<br/>&nbsp;&nbsp;print&nbsp;false;<br/>}<br/>print&nbsp;true;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">The operational semantics inference rules are the same as those in a <a href="#cbfa02d3624d42b08704d6a4c4fb9e03">previous example</a>. However, we must modify the inference rules for statements. In particular, the predicate &dArr; that defines execution of statements must also specify the new environment that exists after a statement is executed. This is to capture the fact that a program may have variable assignments in a block of code that may be executed multiple times (or, in other languages with branching constructs, may be executed conditionally).</span>
        <div class="inferences"><table class="inference"><tr><td class="title">[Statement-Assign]</td><td><table><tr><td class="premises">&nbsp;&Sigma;<sub>1</sub> &#8846; {<i>x</i> &#x21A6; <i>v</i>}, <i>p</i> &dArr; &Sigma;<sub>2</sub>, <i>o</i> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;<sub>1</sub>, <i>f</i> &dArr; <i>v</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;<sub>1</sub>, <b>assign</b> <i>x</i> <b>:=</b> <i>f</i> <b>;</b> <i>p</i> &dArr; &Sigma;<sub>2</sub>, <i>o</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-Print]</td><td><table><tr><td class="premises">&nbsp;&Sigma;<sub>1</sub>, <i>p</i> &dArr; &Sigma;<sub>2</sub>, <i>o</i> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;<sub>1</sub>, <i>f</i> &dArr; <i>v</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;<sub>1</sub>, <b>print</b> <i>f</i> <b>;</b> <i>p</i> &dArr; &Sigma;<sub>2</sub>, <i>v</i>;<i>o</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-Repeat-Twice]</td><td><table><tr><td class="premises">&nbsp;
              &Sigma;<sub>1</sub>, <i>p</i><sub>1</sub> &dArr; &Sigma;<sub>2</sub>, <i>o</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;<sub>2</sub>, <i>p</i><sub>1</sub> &dArr; &Sigma;<sub>3</sub>, <i>o</i><sub>2</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;<sub>3</sub>, <i>p</i><sub>2</sub> &dArr; &Sigma;<sub>4</sub>, <i>o</i><sub>3</sub>
            &nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;<sub>1</sub>, <b>repeat twice</b> <b>{</b> <i>p</i><sub>1</sub> <b>}</b> <i>p</i><sub>2</sub> &dArr; &Sigma;<sub>4</sub>, <i>o</i><sub>1</sub>;<i>o</i><sub>2</sub>;<i>o</i><sub>3</sub>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-End]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <b>end ;</b> &dArr; &Sigma;, <i>o</i><sub>0</sub>&nbsp;</td></tr></table></td></tr></table></div>

        
<span class="text">We can convert the above operational semantics inference rules into a Python implementation of an interpreter for this language. The implementation of <code>evaluate()</code> is the same as the one in a <a href="#cbfa02d3624d42b08704d6a4c4fb9e03">previous example</a>, while the implementation of <code>execute()</code> from <a href="#cbfa02d3624d42b08704d6a4c4fb9e03">that example</a> must be modified so that it also returns an updated version of the environment data structure.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">def</span>&nbsp;execute(env,&nbsp;s):<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="builtin">type</span>(s)&nbsp;==&nbsp;Leaf:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;s&nbsp;==&nbsp;<span class="literal">'End'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;(env,&nbsp;[])<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">elif</span>&nbsp;<span class="builtin">type</span>(s)&nbsp;==&nbsp;Node:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;label&nbsp;<span class="keyword">in</span>&nbsp;s:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Print'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;children&nbsp;=&nbsp;s[label]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;children[0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;children[1]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;evaluate(env,&nbsp;f)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(env,&nbsp;o)&nbsp;=&nbsp;execute(env,&nbsp;p)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;(env,&nbsp;[v]&nbsp;+&nbsp;o)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Assign'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;children&nbsp;=&nbsp;s[label]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;children[0][<span class="literal">'Variable'</span>][0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;children[1]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;children[2]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;evaluate(env,&nbsp;f)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;env[x]&nbsp;=&nbsp;v<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(env,&nbsp;o)&nbsp;=&nbsp;execute(env,&nbsp;p)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;(env,&nbsp;o)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'RepeatTwice'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;children&nbsp;=&nbsp;s[label]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body&nbsp;=&nbsp;children[0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rest&nbsp;=&nbsp;children[1]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;env1&nbsp;=&nbsp;env<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(env2,&nbsp;o1)&nbsp;=&nbsp;execute(env1,&nbsp;body)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(env3,&nbsp;o2)&nbsp;=&nbsp;execute(env2,&nbsp;body)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(env4,&nbsp;o3)&nbsp;=&nbsp;execute(env3,&nbsp;rest)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;(env4,&nbsp;o1&nbsp;+&nbsp;o2&nbsp;+&nbsp;o3)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
      </div></div></div></div><br/><hr/><a name="4.5"></a><a name="assignment2"></a><a name="hw2"></a><div class="assignment"><h3 class="linked"><span class="link-title">[<a href="#4.5">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">4.5.</span> <span class="assignment_title">Assignment #2: More Parsing Algorithms and Interpreters</span></h3><div class="instructions">
        
<span class="text">In this assignment you will implement a full, working interpreter for a small imperative programming language. You must submit two Python source file named <code>hw2/parse.py</code> and <code>hw2/interpret.py</code>. Please follow the <a href="http://www.cs.bu.edu/teaching/hw/gsubmit/">gsubmit</a> directions and remember to put your files in the <code>hw2</code> directory.
<br/><br/>
Your solutions to each of the problem parts below will be graded on their correctness, concision, and mathematical legibility. The different problems and problem parts rely on the lecture notes and on each other; carefully consider whether you can use functions from the lecture notes, or functions you define in one part within subsequent parts. You may want to import the following library functions in your code:</span>
        
<div class="code"><div class="source"><br/><span class="keyword">from</span>&nbsp;math&nbsp;<span class="keyword">import</span>&nbsp;log,&nbsp;floor<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text"><b style="color:green;">A testing script with several test cases is available for download: <a href="a2-tests.py"><code>a2-tests.py</code></a>. Feel free to modify or extend it as you see fit.</b></span>
      </div><ol class="problems"><li class="problem">
<span class="text">In this problem you will implement a parser for a simple programming language. All the functions you define in this problem should appear in the file <code>parse.py</code>. You should adapt the techniques and/or code from <b><a href="#assignment1">Assignment #1</a></b> where appropriate to complete this problem. Recall that all parsers take a sequence of tokens (and possibly a flag) as their input, and return a tuple containing a parse tree and a sequence of remaining tokens.</span><ol class="parts"><li class="part">
<span class="text">Include in your code the parsers <code>variable()</code> and <code>number()</code> that can parse token sequences that conform to the following two productions:          
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>variable</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <code>[a-z][A-Za-z]*</code> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>number</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <code>(0|[1-9][0-9]*)</code>
</td></tr></table></td></tr></table></span></li><li class="part">
<span class="text">Implement a parser <code>formula()</code> that can parse token sequences that conform to the following production. You may need to perform left factoring on a production before you can implement a working parser. Note that the <b>or</b> operator is omitted intentionally to avoid dealing with issues related to left-associativity. <b style="color:green;">When parsing the choice "<b>(</b> <i>formula</i> <b>)</b>", you should simply return the parse tree that is obtained from the recursive call corresponding to <i>formula</i></b>.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>formula</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>formula</i> <b>and</b> <i>formula</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
            <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>not (</b> <i>formula</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
            <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>(</b> <i>formula</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
            <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>variable</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
            <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
            <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>false</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
</td></tr></table></td></tr></table></span></li><li class="part">
<span class="text">Implement a parser <code>term()</code> that can parse token sequences that conform to the following productions. These productions ensure that the traditional order of operations for addition and multiplication is preserved in a parser tree. However, you may need to perform left factoring on a production before you can implement a working parser. <b style="color:green;">When parsing the choice "<b>(</b> <i>term</i> <b>)</b>", you should simply return the parse tree that is obtained from the recursive call corresponding to <i>term</i></b>.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>term</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>factor</i> <b>+</b> <i>term</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
            <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>factor</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>factor</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>factor</i> <b>*</b> <i>factor</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
            <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>log (</b> <i>term</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
            <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>(</b> <i>term</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
            <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>variable</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
            <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>number</i>
</td></tr></table></td></tr></table></span></li><li class="part">
<span class="text">Implement a parser <code>program()</code> that can parse token sequences that conform to the following production. <b style="color:green;">Note that the last choice in the production defining <i>program</i> is meaningful: it means that an empty token sequence is a valid program. The parse tree corresponding to an empty program should be <code>'End'</code>.</b>
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>print</b> <i>expression</i> <b>;</b> <i>program</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>assign</b> <i>variable</i> <b>:=</b> <i>expression</i> <b>;</b> <i>program</i></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>if</b> <i>expression</i> <b>{</b> <i>program</i> <b>}</b> <i>program</i></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>while</b> <i>expression</i> <b>{</b> <i>program</i> <b>}</b> <i>program</i></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>expression</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>term</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                  <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>formula</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
</td></tr></table></td></tr></table>
Recall that the last <i>program</i> subtree in each of the choices in the production defining <i>program</i> represent the <i>rest</i> of the program. For example, in the choice "<b>if</b> <i>expression</i> <b>{</b> <i>program</i> <b>}</b> <i>program</i>", the first <i>program</i> subtree is the body of the <b>if</b> statement, while the second <i>program</i> subtree is the rest of the program. For another example, the following is one possible program in this language:</span>
<div class="code"><div class="source"><br/>if&nbsp;true&nbsp;{<br/>&nbsp;&nbsp;print&nbsp;true;<br/>}<br/>print&nbsp;false;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li></ol></li><li class="problem">
<span class="text">In this problem you will implement an interpreter for a simple programming language. All the functions you define in this problem should appear in the file <code>interpret.py</code>. Your interpreter must conform to the operational semantics for this language, as presented in each of the problem parts below.</span><ol class="parts"><li class="part">
<span class="text">Implement a function <code>evalTerm(env, t)</code> that takes an environment <code>env</code> and a parse tree <code>t</code> as its two arguments. The function should return the value that corresponds to the evaluation of the parse tree <code>t</code>, as determined by the operational semantics below.</span><div class="inferences"><table class="inference"><tr><td class="title">[Term-Number]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <i>n</i> &dArr; <i>n</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Term-Variable]</td><td><table><tr><td class="premises">&nbsp;&Sigma;(<i>x</i>) = <i>v</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <i>x</i> &dArr; <i>v</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Term-Log]</td><td><table><tr><td class="premises">&nbsp;&Sigma;, <i>t</i> &dArr; <i>v</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <b>log</b> <i>t</i> &dArr; &lfloor; log<sub>2</sub> (<i>v</i>) &rfloor;&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Term-Plus]</td><td><table><tr><td class="premises">&nbsp;&Sigma;, <i>t</i><sub>1</sub> &dArr; <i>v</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;, <i>t</i><sub>2</sub> &dArr; <i>v</i><sub>2</sub>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <i>t</i><sub>1</sub> <b>+</b> <i>t</i><sub>2</sub> &dArr; <i>v</i><sub>1</sub> + <i>v</i><sub>2</sub>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Term-Mult]</td><td><table><tr><td class="premises">&nbsp;&Sigma;, <i>t</i><sub>1</sub> &dArr; <i>v</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;, <i>t</i><sub>2</sub> &dArr; <i>v</i><sub>2</sub>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <i>t</i><sub>1</sub> <b>*</b> <i>t</i><sub>2</sub> &dArr; <i>v</i><sub>1</sub> &sdot; <i>v</i><sub>2</sub>&nbsp;</td></tr></table></td></tr></table></div></li><li class="part">
<span class="text">Implement a function <code>evalFormula(env, f)</code> that takes an environment <code>env</code> and a parse tree <code>f</code> as its two arguments. The function should return the value that corresponds to the evaluation of the parse tree <code>f</code>, as determined by the operational semantics below.</span><div class="inferences"><table class="inference"><tr><td class="title">[Formula-True]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <b>true</b> &dArr; <b>true</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-False]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <b>false</b> &dArr; <b>false</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-Variable]</td><td><table><tr><td class="premises">&nbsp;&Sigma;(<i>x</i>) = <i>v</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <i>x</i> &dArr; <i>v</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-Not]</td><td><table><tr><td class="premises">&nbsp;&Sigma;, <i>f</i> &dArr; <i>v</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <b>not</b> <i>f</i> &dArr; &not; <i>v</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-And]</td><td><table><tr><td class="premises">&nbsp;&Sigma;, <i>f</i><sub>1</sub> &dArr; <i>v</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;, <i>f</i><sub>2</sub> &dArr; <i>v</i><sub>2</sub>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <i>f</i><sub>1</sub> <b>and</b> <i>f</i><sub>2</sub> &dArr; <i>v</i><sub>1</sub> &and; <i>v</i><sub>2</sub>&nbsp;</td></tr></table></td></tr></table></div></li><li class="part">
<span class="text">Implement a function <code>execProgram(env, s)</code> that takes an environment <code>env</code> and a parse tree <code>s</code> as its two arguments. The function should return a tuple containing the output (represented as a list of values) and an updated environment that represent the result of the execution of the program <code>s</code> as determined by the operational semantics below.</span><div class="inferences"><table class="inference"><tr><td class="title">[Statement-Print]</td><td><table><tr><td class="premises">&nbsp;&Sigma;<sub>1</sub>, <i>p</i> &dArr; &Sigma;<sub>2</sub>, <i>o</i> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;<sub>1</sub>, <i>e</i> &dArr; <i>v</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;<sub>1</sub>, <b>print</b> <i>e</i> <b>;</b> <i>p</i> &dArr; &Sigma;<sub>2</sub>, <i>v</i>;<i>o</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-Assign]</td><td><table><tr><td class="premises">&nbsp;&Sigma;<sub>1</sub> &#8846; {<i>x</i> &#x21A6; <i>v</i>}, <i>p</i> &dArr; &Sigma;<sub>2</sub>, <i>o</i> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;<sub>1</sub>, <i>e</i> &dArr; <i>v</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;<sub>1</sub>, <b>assign</b> <i>x</i> <b>:=</b> <i>e</i> <b>;</b> <i>p</i> &dArr; &Sigma;<sub>2</sub>, <i>o</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-If-False]</td><td><table><tr><td class="premises">&nbsp;&Sigma;<sub>1</sub>, <i>p</i><sub>2</sub> &dArr; &Sigma;<sub>2</sub>, <i>o</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;<sub>1</sub>, <i>e</i> &dArr; <b>false</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;<sub>1</sub>, <b>if</b> <i>e</i> <b>{</b> <i>p</i><sub>1</sub> <b>}</b> <i>p</i><sub>2</sub> &dArr; &Sigma;<sub>2</sub>, <i>o</i><sub>1</sub>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-If-True]</td><td><table><tr><td class="premises">&nbsp;&Sigma;<sub>1</sub>, <i>p</i><sub>1</sub> &dArr; &Sigma;<sub>2</sub>, <i>o</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;<sub>2</sub>, <i>p</i><sub>2</sub> &dArr; &Sigma;<sub>3</sub>, <i>o</i><sub>2</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;<sub>1</sub>, <i>e</i> &dArr; <b>true</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;<sub>1</sub>, <b>if</b> <i>e</i> <b>{</b> <i>p</i><sub>1</sub> <b>}</b> <i>p</i><sub>2</sub> &dArr; &Sigma;<sub>3</sub>, <i>o</i><sub>1</sub>;<i>o</i><sub>2</sub>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-While-False]</td><td><table><tr><td class="premises">&nbsp;&Sigma;<sub>1</sub>, <i>p</i><sub>2</sub> &dArr; &Sigma;<sub>2</sub>, <i>o</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;<sub>1</sub>, <i>e</i> &dArr; <b>false</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;<sub>1</sub>, <b>while</b> <i>e</i> <b>{</b> <i>p</i><sub>1</sub> <b>}</b> <i>p</i><sub>2</sub> &dArr; &Sigma;<sub>2</sub>, <i>o</i><sub>1</sub>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-While-True]</td><td><table><tr><td class="premises">&nbsp;
                    &Sigma;<sub>1</sub>, <i>p</i><sub>1</sub> &dArr; &Sigma;<sub>2</sub>, <i>o</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;<sub>2</sub>, <b>while</b> <i>e</i> <b>{</b> <i>p</i><sub>1</sub> <b>}</b> <i>p</i><sub>2</sub> &dArr; &Sigma;<sub>3</sub>, <i>o</i><sub>2</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;<sub>1</sub>, <i>e</i> &dArr; <b>true</b>
                  &nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;<sub>1</sub>, <b>while</b> <i>e</i> <b>{</b> <i>p</i><sub>1</sub> <b>}</b> <i>p</i><sub>2</sub> &dArr; &Sigma;<sub>3</sub>, <i>o</i><sub>1</sub>;<i>o</i><sub>2</sub>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-End]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <b>end ;</b> &dArr; &Sigma;, <i>o</i><sub>0</sub>&nbsp;</td></tr></table></td></tr></table></div></li><li class="part">
<span class="text">Implement a function <code>interpret()</code> that takes a single string as its argument. The function should tokenize the string, parse it to generate a parse tree, and then execute it to obtain an output. It should then return the output. <b style="color:green;">Your implementation only needs to interpret entire programs; you do not need to interpret stand-alone terms or formulas.</b></span></li></ol></li><li class="problem">
<span class="text"><b>Extra credit:</b> Implement one or more of the following extensions and optimizations (listed in order of increasing difficulty).</span><ol class="parts"><li class="part">
<span class="text">Optimize your implementation of <code>evalFormula()</code> to use "short-circuiting" when evaluating the <code>and</code> operator: if the left-hand subtree evaluates to <code>'False'</code>, then do not evaluate the right subtree at all.</span></li><li class="part">
<span class="text">Add the infix relational operators <b>==</b> and <b>&lt;</b> to the language. You will need to extend both the parsing and evaluation algorithms.</span></li><li class="part">
<span class="text">Optimize your implementation of <code>evalProgram()</code> not to evaluate the expression in an assignment statement if the variable being assigned never appears in the rest of the program. You may want to implement a helper function that checks if a variable appears in a parse tree corresponding to a program.</span></li></ol></li></ol>
</div><hr/><br/>
  <a name="4.6"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#4.6">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">4.6.</span> Interpreters</h3>
<span class="text">An interpreter is an algorithm that invokes evaluation and execution algorithms as required by the operational semantics for a language.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">program<br/>(abstract syntax)</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:#ECECEC;">
      <table class="container">
        <tr>
          <td class="box" style="background-color:lightyellow;">evaluation<br/>algorithm</td>
          <td class="box" style="background-color:lightyellow;">execution<br/>algorithm</td>
        </tr>
      </table>
    </td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">output and/or<br/>value(s)<br/></td>
  </tr>
</table>
</div>
Often, the term <i>interpreter</i>will refer to the entire toolchain of components that make it possible to convert the character string (i.e., concrete syntax) representation of a program in the source language into value(s) and/or a record of the side effects of a program. In these cases, we will refer to the individual component that performs interpretation as the <i>interpretation algorithm</i> or <i>interpretation component</i>.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">character string<br/>(concrete syntax)</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:#EFEFEF;">
      <table class="container">
        <tr>
        <td class="box" style="background-color:lightyellow;">parser</td>
        <td><span style="font-size:20px;">&#8658;</span></td>
        <td class="box" style="background-color:powderblue;">abstract<br/>syntax</td>
        <td><span style="font-size:20px;">&#8658;</span></td>
        <td class="box" style="background-color:lightyellow;">interpretation<br/>algorithm</td>
        </tr>
      </table>
      <br/>interpreter
    </td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">output and/or<br/>value(s)<br/></td>
    <td></td>
    <td></td>
  </tr>
</table>
</div></span></div>
</div>
<a name="5"></a>
<div class="section"><hr style="margin-bottom:120px;"/><h2 class="linked"><span class="link-title">[<a href="#5">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">5.</span> Compilation</h2>
<span class="text">Compilation involves translating or transforming one programming language (sometimes called the <i>source</i> language) into another (often called the <i>target</i> language). It is often the case that the target language is a more "low-level" language that more closely corresponds to the capabilities of a physical (i.e., electronic) device, such as the central processor (CPU), memory, and other devices that constitute a modern computer. However, today, compilation could also refer to any transformation from one programming language to another. For example, it might be necessary to compile PHP to ASP, which are both server-side web application scripting languages, in order to migrate software from one operating system to another.</span>
  <a name="5.1"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#5.1">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">5.1.</span> History, background, and context</h3>
<span class="text">One way to summarize a very thin slice of the history of general-purpose computers and their relationship with programming languages is to consider how the increasingly complex structure of a computer both enabled and required increasingly abstract programming languages and programming language features.
<br/><br/>
The three major categories of concept involved are the program, the computing device, and the physical laws upon which the computing device is based. As long as the physical laws being used are predictable (i.e., consistent across time and space), we can build computing devices that behave the same way even if they are operated in different places or at different times. We can then interpret what that device does in some meaningful way (e.g., as arithmetic operations). To perform different kinds of tasks using the device, we would need some kind of way to change its initial configuration (i.e., to "program" it).
<div class="diagram">
<table class="container">
  <tr><td class="box" style="background-color:lightyellow;">program (e.g., input/configuration, instructions, etc.)</td></tr>
  <tr><td class="box" style="background-color:orange;">computing device (e.g., difference engine, modern CPU, quantum computer, etc.)</td></tr>
  <tr><td class="box" style="background-color:powderblue;">physical laws (mechanics, electricity, chemistry, biology, quantum mechanics, etc.)</td></tr>
</table>
</div>
Until the 1940s, all artifacts that could be considered computing devices (e.g., an abacus, <a href="http://en.wikipedia.org/wiki/Difference_engine">Babbage's difference engine</a>, etc.) were single-purpose machines that could only perform the same operation (but possibly on different inputs, which corresponded to different initial configurations of the device). In the early 1940s, a number of computers were built (such as the <a href="http://en.wikipedia.org/wiki/ENIAC">ENIAC</a> and <a href="http://en.wikipedia.org/wiki/Colossus_computer">Colossus</a>) that could be physically reconfigured to perform different operations. Arguably, the "program" was the machine's physical configuration. In the late 1940s, computers were developed (or improved, as in the case of ENIAC) that could operate according to a program stored in a memory device. At this point, both the program and the input were stored in a single, unified memory component; the program told the central processing unit (CPU) what operations to perform, and what modifications to make to memory. This characteristic is part of what's known as the <a href="http://en.wikipedia.org/wiki/Von_Neumann_architecture">Von Neumann architecture</a>.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:#EEEEEE;">memory
      <table class="container">
        <tr>
          <td class="box" style="background-color:lightyellow;">input</td>
          <td class="box" style="background-color:lightyellow;">program</td>
        </tr>
      </table>
    </td>
  </tr>
  <tr><td class="box" style="background-color:orange;">central processing unit (CPU)</td></tr>
</table>
</div>
Subsequent improvements to computing device components in the 1950s and onward primarily served to make the components smaller, cheaper, faster, and more reliable while still conforming to the Von Neumann architecture. However, the programs controlling these devices continued to become more and more sophisticated.
<br/><br/>
Machine languages were developed in the 1940s (particularly in the very late 1940s) and the 1950s. These consisted of small collections of instructions that corresponded to operations that could be performed by the CPU. A program was then a list of machine language instructions, and the abstraction this supplied to the programmer was that of a block of memory indexed by an integer range, and a single processor that could perform a sequence of operations on memory. The diagram below provides a stylized depiction of the view from a user's or programmer's perspective.
<div class="diagram">
<table class="container">
  <tr><td class="box" style="background-color:lightyellow;">machine program</td></tr>
  <tr><td class="box" style="background-color:#ECECEC;">machine languauge</td></tr>
  <tr>
    <td class="box" style="background-color:#CCCCCC;">
      <table class="container">
        <tr>
          <td class="box" style="background-color:orange;">CPU</td>
          <td class="box" style="background-color:orange;">memory</td>
        </tr>
      </table>
      hardware
    </td>
  </tr>
</table>
</div>
In part because using machine languages to specify the desired behavior of computers was time-consuming and error-prone, more human-friendly and legible languages were developed in the mid and late 1950s, such as FORTRAN, LISP, and COBOL. These programs were mechanically transformed into machine language programs using a compiler, which was itself a program. For example, after a human wrote a FORTRAN program, it could be compiled once into a machine language program by running the compiler once. The machine language program this produced could then be run any number of times or copied and reused later.
<div class="diagram">
<table class="container">
  <tr><td class="box" style="background-color:#ECECEC;">FORTRAN program</td></tr>
  <tr><td class="box" style="background-color:#ECECEC;">FORTRAN compiler</td></tr>
  <tr><td class="box" style="background-color:lightyellow;">machine program</td></tr>
  <tr><td class="box" style="background-color:#ECECEC;">machine languauge</td></tr>
  <tr>
    <td class="box" style="background-color:#CCCCCC;">
      <table class="container">
        <tr>
          <td class="box" style="background-color:orange;">CPU</td>
          <td class="box" style="background-color:orange;">memory</td>
        </tr>
      </table>
      hardware
    </td>
  </tr>
</table>
</div>
Special-purpose applications could be written using either a machine language or a high-level language.
<div class="diagram">
<table class="container">
  <tr><td class="box" style="background-color:lightyellow;">application</td></tr>
  <tr><td class="box" style="background-color:#ECECEC;">high-level program</td></tr>
  <tr><td class="box" style="background-color:#ECECEC;">compiler</td></tr>
  <tr><td class="box" style="background-color:lightyellow;">machine program</td></tr>
  <tr><td class="box" style="background-color:#ECECEC;">machine languauge</td></tr>
  <tr>
    <td class="box" style="background-color:#CCCCCC;">
      <table class="container">
        <tr>
          <td class="box" style="background-color:orange;">CPU</td>
          <td class="box" style="background-color:orange;">memory</td>
        </tr>
      </table>
      hardware
    </td>
  </tr>
</table>
</div>
Once it became possible for non-experts and multiple users to use a computer with a variety of different components beyond the memory and CPU (due to advances in many areas, including reductions in cost and the availability of better interface devices and special-purpose components), operating systems were developed to make it possible to manage multiple applications that might run by different users and might employ different components. However, all the applications would need to be either written using a machine language, or written in a language that could be compiled into a machine language. The operating system would then manage how these machine programs could use the various components and resources available to the computer (including the resource of time).
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" colspan="2" style="background-color:#EEEEEE;">
      user A
      <table class="container">
        <tr>
          <td class="box" style="background-color:lightyellow;">application</td>
          <td class="box" style="background-color:lightyellow;">application</td>
        </tr>
      </table>
    </td>
    <td class="box" colspan="2" style="background-color:#EEEEEE;">
      user B
      <table class="container">
        <tr>
          <td class="box" style="background-color:lightyellow;">application</td>
          <td class="box" style="background-color:lightyellow;">application</td>
        </tr>
      </table>
    </td>
  </tr>
  <tr>
    <td class="box" style="background-color:#EEEEEE;">high-level<br/>program</td>
    <td class="box" style="background-color:#EEEEEE;">high-level<br/>program</td>
    <td class="box" style="background-color:#EEEEEE;">high-level<br/>program</td>
    <td class="box" style="background-color:#EEEEEE;">high-level<br/>program</td>
  </tr>
  <tr><td class="box" colspan="4" style="background-color:#ECECEC;">compiler</td></tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">machine<br/>program</td>
    <td class="box" style="background-color:lightyellow;">machine<br/>program</td>
    <td class="box" style="background-color:lightyellow;">machine<br/>program</td>
    <td class="box" style="background-color:lightyellow;">machine<br/>program</td>
  </tr>
  <tr><td class="box" colspan="4" style="background-color:#ECECEC;">machine languauge</td></tr>
  <tr><td class="box" colspan="4" style="background-color:lightyellow;">operating system</td></tr>
  <tr>
    <td class="box" colspan="4" style="background-color:#CCCCCC;">
      <table class="container">
        <tr>
          <td class="box" style="background-color:orange;">CPU</td>
          <td class="box" style="background-color:orange;">CPU</td>
          <td class="box" style="background-color:orange;">CPU</td>
          <td class="box" style="background-color:orange;">memory</td>
          <td class="box" style="background-color:orange;">input device</td>
          <td class="box" style="background-color:orange;">output device</td>
          <td class="box" style="background-color:orange;">other device</td>
        </tr>
      </table>
      hardware
    </td>
  </tr>
</table>
</div>
One could collapse this into a relatively simple diagram by omitting the portions of the diagram that do not represent components that either appear to be running to the user, or are actually running on the device.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:lightyellow;">application</td>
    <td class="box" style="background-color:lightyellow;">application</td>
    <td class="box" style="background-color:lightyellow;">application</td>
    <td class="box" style="background-color:lightyellow;">application</td>
  </tr>
  <tr><td class="box" colspan="4" style="background-color:lightyellow;">operating system</td></tr>
  <tr><td class="box" colspan="4" style="background-color:#CCCCCC;">hardware</td></tr>
</table>
</div>
The above diagram might represent a single computer in a single physical location running a single operating system and a few applications. Today, this picture is much more complicated. While many devices are still captured by the above diagram, in many other cases the actual abstractions provided are much more rich and diverse, and they reflect the diverse ecosystem of capabilities and components available to a user, programmer, or application.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" colspan="10" style="background-color:lightyellow;">app.</td>
    <td class="box" style="background-color:lightyellow;">app.</td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td class="box" colspan="11" style="background-color:lightyellow;">web app. platform</td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td class="box" colspan="11" style="background-color:lightyellow;">browser</td>
    <td class="box" style="background-color:lightyellow;">app.</td>
    <td class="box" colspan="3" style="background-color:lightyellow;">app.</td>
  </tr>
  <tr>
    <td class="box" colspan="8" style="background-color:lightyellow;">API</td>
    <td class="box" style="background-color:lightyellow;">API</td>
    <td class="box" colspan="3" style="background-color:lightyellow;">OS</td>
    <td class="box" colspan="3" style="background-color:lightyellow;">OS</td>
  </tr>
  <tr>
    <td class="box" colspan="8" style="background-color:lightyellow;">web service</td>
    <td class="box" style="background-color:lightyellow;">web service</td>
    <td class="box" colspan="3" style="background-color:lightyellow;">virtual machine</td>
    <td class="box" colspan="3" style="background-color:lightyellow;">virtual machine</td>
  </tr>
  <tr>
    <td class="box" colspan="8" style="background-color:lightyellow;">dist. platform</td>
    <td class="box" style="background-color:lightyellow;">web server</td>
    <td class="box" colspan="6" style="background-color:lightyellow;">virtualization layer</td></tr>
  <tr>
    <td class="box" colspan="3" style="background-color:lightyellow;">controller</td>
    <td class="box" colspan="5" style="background-color:lightyellow;">controller</td>
    <td class="box" style="background-color:lightyellow;">OS</td>
    <td class="box" colspan="6" style="background-color:lightyellow;">host operating system</td>
  </tr>
  <tr>
    <td class="box" style="background-color:#CCCCCC; font-size:8px;">node</td>
    <td class="box" style="background-color:#CCCCCC; font-size:8px;">node</td>
    <td class="box" style="background-color:#CCCCCC; font-size:8px;">node</td>
    <td class="box" style="background-color:#CCCCCC; font-size:8px;">node</td>
    <td class="box" style="background-color:#CCCCCC; font-size:8px;">node</td>
    <td class="box" style="background-color:#CCCCCC; font-size:8px;">node</td>
    <td class="box" style="background-color:#CCCCCC; font-size:8px;">node</td>
    <td class="box" style="background-color:#CCCCCC; font-size:8px;">node</td>
    <td class="box" style="background-color:#CCCCCC;">server</td>
    <td class="box" colspan="6" style="background-color:#CCCCCC;">hardware (web/cloud server)</td>
  </tr>
</table>
</div>
Today, the picture is much more complicated. Many applications running on a device actually provide capabilities that are assembled from a collection of underlying layers of potentially interdependent components. Every component in every layer must provide an interface and a collection of abstractions that capture its capabilities and communicate them to users (and expose them to the components on the layers above). Effectively, every component in every layer has a programming language, and assembling multilayered applications may require many compilation steps at various layers.</span></div>
  <a name="5.2"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#5.2">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">5.2.</span> Transformations between abstract syntaxes</h3>
<a name="dfe2befbecb0490b8983a5bc51697a09"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#dfe2befbecb0490b8983a5bc51697a09">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="definition_required"><b>Definition:</b> 
Given two abstract syntaxes <i>A</i> and <i>B</i> (i.e., both <i>A</i> and <i>B</i> are sets of parse trees that conform to two distinct grammars), an algorithm that <i>always terminates</i> and maps parse trees in <i>A</i> to parse trees in <i>B</i> is called a <i>compilation algorithm</i>, and it is said to <i>compile</i> programs in the language corresponding to <i>A</i> into programs in the language corresponding to <i>B</i>. Note that while a compiler must always terminate on all inputs, it is allowed to return an error on some inputs.
      </div></div></div>
<span class="text">Note the similarities and distinctions between an interpreter and a compiler. Both interpreters and compilers map some set of abstract syntax trees to some other set of abstract syntax trees (in the case of interpreters, the resulting abstract syntax trees are usually <i>values</i> that are simpler than programs). However, an interpreter might not terminate (e.g., if the program it is interpreting does not terminate when it is evaluated and/or executed), while a compiler must terminate. Furthermore, an interpreter must keep track of both values and side effects (such as output), while a compiler is simply transforming one program into another program without concerning itself with what the program might do when evaluated/executed.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">source language<br/>abstract syntax</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">compiler</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">target language<br/>abstract syntax</td>
  </tr>
</table>
</div>
Often, the term <i>compiler</i> will refer to the entire toolchain of components that make it possible to convert the character string (i.e., concrete syntax) representation of a program in the source language into the concrete syntax representation of the program in the target language. In these cases, we will refer to the individual component that performs compilation as the <i>compilation algorithm</i> or <i>compilation component</i>.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">source language<br/>concrete syntax</td>
    <td></td>
    <td></td>
    <td></td>
    <td class="box" style="background-color:powderblue;">libraries</td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&#8659;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td><span style="font-size:20px;">&#8659;</span></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">parser</td>
    <td></td>
    <td></td>
    <td></td>
    <td class="box" style="background-color:lightyellow;">linker</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">target language<br/>concrete syntax</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&#8659;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td><span style="font-size:20px;">&#8657;</span></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td class="box" style="background-color:powderblue;">source language<br/>abstract syntax</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">compilation<br/>algorithm</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">target language<br/>abstract syntax</td>
    <td></td>
    <td></td>
  </tr>
</table>
</div>
Furthermore, a compilation algorithm will often consist of multiple stages. Each stage may perform some specific task, such as simplifying the features used in a program (e.g., eliminating procedures and replacing them with labels and branching statements, or eliminating variable names and replacing them with explicit memory addresses), or it may perform optimizations (e.g., elimination of unreachable code blocks). The <i>intermediate representation</i> (IR) between each stage might be a distinct abstract syntax data structure.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">source<br/>language<br/>abstract<br/>syntax</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">comp.<br/>alg. A</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">IR<br/>#1</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">comp.<br/>alg. B</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">IR<br/>#2</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">comp.<br/>alg. C</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">target<br/>language<br/>abstract<br/>syntax</td>
  </tr>
</table>
</div></span></div>
  <a name="5.3"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#5.3">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">5.3.</span> Machine languages and bytecodes</h3>
<a name="a3c0158e667c47a8b3b73cf929ebc7af"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#a3c0158e667c47a8b3b73cf929ebc7af">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="definition_required"><b>Definition:</b> 
Given a model of a computer that consists of a single central processing unit (CPU) that can perform some basic operations, and a block of memory (accessible to the CPU) that is organized using some kind of sequential and/or hierarchical addressing scheme (e.g., positive integers in some range represent memory locations), a <i>machine language</i>, <i>assembly language</i>, or <i>machine code</i> is an imperative programming language that consists of instructions that can directly be executed by a single CPU.
      </div></div></div>
<span class="text">Note that in modern systems and networks, machine code might not be executed by a CPU directly. Instead, a program might be running on an operating system that might itself be running on a virtual machine, which is being simulated by a program that runs on a physical computer but emulates the behavior of a (perhaps very different) CPU and memory.</span>
<a name="91ebfabbdd9f42e7bfd579be18a6d52a"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#91ebfabbdd9f42e7bfd579be18a6d52a">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="definition_required"><b>Definition:</b> 
A <i>bytecode</i> is a low-level programming language that is similar to a machine language (i.e., the instructions in the language are primarily for manipulating memory and performing basic arithmetic and logical operations) but is not platform-dependent (i.e., dependent on a particular CPU model), and itself needs to be either interpreted (e.g., by a run-time system or virtual machine) or compiled into a machine language.
      </div></div></div>
<span class="text">Note that there is a distinction between machine code and bytecode, though this distinction is increasingly harder to discern in practice with the advent of widespread virtualization. Usually, machine code is said to be <i>executed</i> when it is run on its native CPU, and <i>simulated</i> if it is being executed by some software application that emulates the behavior of a CPU; bytecode is typically executed by an interpreter, which might be called a <i>run-time system</i> or a <i>virtual machine</i> (depending on the features and capabilities of the interpreter, some of which will be discussed in more detail in subsequent sections). Examples of bytecodes include the Java bytecode (interpreted by the Java Virtual Machine, or JVM) and the Python bytecode.</span>
<a name="3ee4c63a96db4254ba2b6ad0ee4e29a2"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#3ee4c63a96db4254ba2b6ad0ee4e29a2">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">Consider the following target language, which has many characteristics of a machine language or bytecode. A program consists of an ordered sequence of instructions that can manipulate a block of memory addresses.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>instruction</i> <i>program</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
              <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>instruction</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>label</b> <i>label</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>branch</b> <i>label</i> <i>address</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>branch</b> <i>label</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>set</b> <i>address</i> <i>number</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>copy</b> <i>address</i> <i>address</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>add</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>label</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid label</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>address</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any positive integer or zero</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>number</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any positive integer or zero</i>
</td></tr></table></td></tr></table>
We can implement a simple Python simulator (or virtual machine, if the above is a bytecode) for this language.</span>
        
<div class="code"><div class="source"><br/><span class="comment">#&nbsp;Simulate&nbsp;a&nbsp;machine&nbsp;running&nbsp;the&nbsp;program&nbsp;represented&nbsp;by&nbsp;the&nbsp;string&nbsp;s.</span><br/><span class="keyword">def</span>&nbsp;simulate(s):<br/>&nbsp;&nbsp;&nbsp;&nbsp;instructions&nbsp;=&nbsp;[l.split(<span class="literal">"&nbsp;"</span>)&nbsp;<span class="keyword">for</span>&nbsp;l&nbsp;<span class="keyword">in</span>&nbsp;s.split(<span class="literal">"\n"</span>)]<br/>&nbsp;&nbsp;&nbsp;&nbsp;mem&nbsp;=&nbsp;{0:&nbsp;0}<br/>&nbsp;&nbsp;&nbsp;&nbsp;control&nbsp;=&nbsp;0<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;control&nbsp;<&nbsp;<span class="builtin">len</span>(instructions):<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inst&nbsp;=&nbsp;instructions[control]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;inst[0]&nbsp;==&nbsp;<span class="literal">'label'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">pass</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;For&nbsp;two&nbsp;arguments,&nbsp;test&nbsp;the&nbsp;memory&nbsp;address&nbsp;in&nbsp;the&nbsp;second</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;argument;&nbsp;given&nbsp;one&nbsp;argument,&nbsp;branch&nbsp;unconditionally.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;inst[0]&nbsp;==&nbsp;<span class="literal">'branch'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="builtin">len</span>(inst)&nbsp;==&nbsp;2&nbsp;<span class="keyword">or</span>&nbsp;mem[<span class="builtin">int</span>(inst[2])]&nbsp;!=&nbsp;0:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;control&nbsp;=&nbsp;instructions.index([<span class="literal">'label'</span>,&nbsp;inst[1]])<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">continue</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;inst[0]&nbsp;==&nbsp;<span class="literal">'set'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mem[<span class="builtin">int</span>(inst[1])]&nbsp;=&nbsp;<span class="builtin">int</span>(inst[2])<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;inst[0]&nbsp;==&nbsp;<span class="literal">'copy'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mem[<span class="builtin">int</span>(inst[2])]&nbsp;=&nbsp;mem[<span class="builtin">int</span>(inst[1])]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;inst[0]&nbsp;==&nbsp;<span class="literal">'add'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mem[0]&nbsp;=&nbsp;mem[1]&nbsp;+&nbsp;mem[2]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;control&nbsp;=&nbsp;control&nbsp;+&nbsp;1<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;mem[0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">A program in this language might look as follows:</span>
        
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;p&nbsp;=&nbsp;<span class="literal">''</span><span class="literal">'<br/>&nbsp;&nbsp;label&nbsp;start<br/>&nbsp;&nbsp;set&nbsp;1&nbsp;2<br/>&nbsp;&nbsp;set&nbsp;2&nbsp;3<br/>&nbsp;&nbsp;branch&nbsp;skip&nbsp;1<br/>&nbsp;&nbsp;set&nbsp;2&nbsp;40<br/>&nbsp;&nbsp;label&nbsp;skip<br/>&nbsp;&nbsp;add<br/>&nbsp;&nbsp;'</span><span class="literal">''</span><br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;simulate(p)<br/>5<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>        
      </div></div></div>
<a name="3246043602d540668dc63d5b6277a47f"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#3246043602d540668dc63d5b6277a47f">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">In this example, the target language will be a slightly more complex machine language than the one presented in <a href="3ee4c63a96db4254ba2b6ad0ee4e29a2">a previous example</a>. A program consists of an ordered sequence of instructions that can manipulate a block of memory addresses. The abstract syntax for the language is presented below.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>instruction</i> <i>program</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
              <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>instruction</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>label</b> <i>label</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>goto</b> <i>label</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>branch</b> <i>label</i> <i>address</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>jump</b> <i>address</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>set</b> <i>address</i> <i>number</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>copy</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>add</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>label</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any alphanumeric character string</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>address</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any integer</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>number</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any integer</i>
</td></tr></table></td></tr></table>
When a machine is running a program, the state of the machine consists of a single block of memory (indexed by integers: both negative and positive) and a single integer representing the machine's position in the sequence of instructions (this integer represents which instruction in the program currently has <i>control</i>, i.e., which instruction is being executed by the CPU). The memory has eight special memory locations, which are defined below:
<ul>
  <li><b>memory address 0:</b> the address of the result of an <b>add</b> operation;</li>
  <li><b>memory address 1:</b> the address of the first input to an <b>add</b> operation;</li>
  <li><b>memory address 2:</b> the address of the second input to an <b>add</b> operation;</li>
  <li><b>memory address 3:</b> the address containing the "from" address for a <b>copy</b> operation;</li>
  <li><b>memory address 4:</b> the address containing the "to" address for a <b>copy</b> operation;</li>
  <li><b>memory address 5:</b> the output buffer (set to &#8722;1 after every step);</li>
  <li><b>memory address 6:</b> the address of the program's control index.</li>
</ul>
The meaning of each instruction is described below:
<ul>
  <li><b>label <i>l</i>:</b> there is no effect and control is passed to the next instruction;</li>
  <li><b>goto <i>l</i>:</b> control immediately moves to the program instruction <b>label</b> <i>l</i>;</li>
  <li><b>branch <i>l</i> <i>a</i>:</b> control immediately moves to the program instruction <b>label</b> <i>l</i> if memory address <i>a</i> contain a non-zero integer;</li>
  <li><b>jump <i>a</i>:</b> if the integer <i>i</i> is stored in memory address <i>a</i>, control moves immediately to the <i>i</i>th instruction in the program;</li>
  <li><b>set <i>a</i> <i>n</i>:</b> memory address <i>a</i> is set to the integer <i>n</i>;</li>
  <li><b>copy:</b> if <i>a</i> is the integer stored in memory address 3, and <i>b</i> is the integer stored in memory address 4, then the contents of memory address <i>a</i> are copied to memory address <i>b</i>;</li>
  <li><b>add:</b> the contents of memory location 1 and memory location 2 are added and stored in memory location 0.</li>
</ul>
We can implement a simple <a href="hw3/machine.py">Python simulator</a> for this language.
<br/><br/>
As an example of how this language might be used, suppose we want to write a program in this language to copy the contents of memory address 10 to memory address 20. The machine language program presented below would have this behavior:</span>   
        
<div class="code"><div class="source"><br/>set&nbsp;3&nbsp;10<br/>set&nbsp;4&nbsp;20<br/>copy<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">In fact, we can write a Python program that can generate an instance of the above for any two addresses. Notice that the <code>copy()</code> function below can be viewed as a macro that generates a specific machine language program.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">def</span>&nbsp;copy(frm,&nbsp;to):<br/>&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;[\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">'set&nbsp;3&nbsp;'</span>&nbsp;+&nbsp;<span class="builtin">str</span>(frm),\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">'set&nbsp;4&nbsp;'</span>&nbsp;+&nbsp;<span class="builtin">str</span>(to),\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">'copy'</span>\<br/>&nbsp;&nbsp;&nbsp;]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">Suppose we have another macro <code>increment()</code> that takes a single argument, a memory address, and generates a machine program that increments the value at the address specified memory address. We could then implement the following macro, which will set an entire region of memory to a particular constant.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">def</span>&nbsp;setAllToInRegion(constant,&nbsp;startAddr,&nbsp;endAddr):<br/>&nbsp;&nbsp;<span class="comment">#&nbsp;Memory&nbsp;location&nbsp;8&nbsp;contains&nbsp;the&nbsp;constant.</span><br/>&nbsp;&nbsp;<span class="comment">#&nbsp;Memory&nbsp;location&nbsp;9&nbsp;contains&nbsp;the&nbsp;counter.&nbsp;&nbsp;</span><br/>&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;[\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">'set&nbsp;8&nbsp;'</span>&nbsp;+&nbsp;<span class="builtin">str</span>(constant),\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">'set&nbsp;9&nbsp;'</span>&nbsp;+&nbsp;<span class="builtin">str</span>(startAddr),\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">'label&nbsp;loop'</span>\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Set&nbsp;second&nbsp;argument&nbsp;(destination)&nbsp;of&nbsp;copy.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;copy(9,4)\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;[\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Set&nbsp;first&nbsp;argument&nbsp;(source)&nbsp;for&nbsp;copy.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">'set&nbsp;3&nbsp;8'</span>,\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">'copy'</span>\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Increment&nbsp;the&nbsp;counter.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;increment(9)&nbsp;\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;If&nbsp;counter&nbsp;is&nbsp;endAddr,&nbsp;break&nbsp;out&nbsp;of&nbsp;loop;</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;otherwise,&nbsp;go&nbsp;back&nbsp;to&nbsp;the&nbsp;beginning&nbsp;of&nbsp;the&nbsp;loop.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;We&nbsp;check&nbsp;by&nbsp;adding&nbsp;-endAddr&nbsp;to&nbsp;the&nbsp;counter.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;First&nbsp;argument&nbsp;of&nbsp;add.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;copy(9,1)&nbsp;\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;[\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Second&nbsp;argument&nbsp;of&nbsp;add.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">'set&nbsp;2&nbsp;-'</span>&nbsp;+&nbsp;<span class="builtin">str</span>(endAddr),\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">'add'</span>,\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">'branch&nbsp;loop&nbsp;0'</span>\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">Running <code>setAllToInRegion()</code> on specific inputs generates a machine language program for a particular region.</span>
        
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;setAllToInRegion(3,&nbsp;10,&nbsp;100)<br/>[<span class="literal">'set&nbsp;8&nbsp;3'</span>,&nbsp;<br/>&nbsp;<span class="literal">'set&nbsp;9&nbsp;10'</span>,&nbsp;<br/>&nbsp;<span class="literal">'label&nbsp;loop'</span>,&nbsp;<br/>&nbsp;<span class="literal">'set&nbsp;3&nbsp;9'</span>,&nbsp;<br/>&nbsp;<span class="literal">'set&nbsp;4&nbsp;4'</span>,&nbsp;<br/>&nbsp;<span class="literal">'copy'</span>,&nbsp;<br/>&nbsp;<span class="literal">'set&nbsp;3&nbsp;8'</span>,&nbsp;<br/>&nbsp;<span class="literal">'copy'</span>,&nbsp;<br/>&nbsp;<span class="literal">'#&nbsp;increment()&nbsp;done&nbsp;as&nbsp;homework.'</span>,<br/>&nbsp;<span class="literal">'set&nbsp;3&nbsp;9'</span>,&nbsp;<br/>&nbsp;<span class="literal">'set&nbsp;4&nbsp;1'</span>,&nbsp;<br/>&nbsp;<span class="literal">'copy'</span>,&nbsp;<br/>&nbsp;<span class="literal">'set&nbsp;2&nbsp;-100'</span>,&nbsp;<br/>&nbsp;<span class="literal">'add'</span>,&nbsp;<br/>&nbsp;<span class="literal">'branch&nbsp;loop&nbsp;0'</span>]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
      </div></div></div></div>
  <a name="5.4"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#5.4">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">5.4.</span> Compiling expressions to a machine language or bytecode</h3>
<span class="text">In order to compile a high-level language to a machine language that only provides the CPU and indexed memory abstractions, it is necessary to transform the high-level language's parse tree into a series of instructions that manipulate memory in a way that appears identical to the behavior of the high-level program when it is being interpreted.
<br/><br/>
Since machine language programs describe how to manipulate memory, it is a good idea to plan how the machine program will utilize the memory available to it to store intermediate results it needs to compute while the program is running.</span>
<a name="f7d602562fe211e38cf6ce3f5508acd9"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#f7d602562fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="definition_required"><b>Definition:</b> 
The region of memory that a machine program uses to store values (i.e., results of computing expressions) is called the <i>heap</i>.
<br/><br/>
As a machine program continues running and computing more results, it <i>grows</i> the heap by adding values to new memory locations. To keep track of this at the time of compilation, the compiler might maintain a counter that stores the current "top" of the heap. When a machine program is running, it may itself maintain a <i>heap pointer</i> to keep track of the last item stored on the heap, primarily so that it knows where to look for more space if it wants to store more values in memory.
      </div></div></div>
<a name="f288b6e6a04d45e58feb24c6f72de96a"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#f288b6e6a04d45e58feb24c6f72de96a">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">Suppose we are starting with the following source language:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>formula</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> | <b>false</b> | <b>not</b> <i>formula</i> | <i>formula</i> <b>and</b> <i>formula</i> | <i>formula</i> <b>or</b> <i>formula</i>
</td></tr></table></td></tr></table>
How can we implement a compiler that converts formulas in the source language into sequences of instructions in the target language in the <a href="#3ee4c63a96db4254ba2b6ad0ee4e29a2">previous example</a>?
<br/><br/>
We can approach this problem by constructing a function <code>compileFormula()</code> that takes as its input the parse tree, and a variable <code>heap</code> that represents the highest address in memory that contains a computed value (in our case, <code>1</code> can represent <b>true</b> and <code>0</code> can represent <b>false</b>). The function returns a list of machine language instructions that computes that value, as well as the memory address where that value would be stored if anyone actually executed (or simulated) the machine language program.</span>       
        
<div class="code"><div class="source"><br/><span class="keyword">def</span>&nbsp;compileFormula(f,&nbsp;heap&nbsp;=&nbsp;3,&nbsp;fresh&nbsp;=&nbsp;0):<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="builtin">type</span>(f)&nbsp;==&nbsp;Leaf:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;f&nbsp;==&nbsp;<span class="literal">'True'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Find&nbsp;a&nbsp;new&nbsp;memory&nbsp;address&nbsp;on&nbsp;the&nbsp;heap.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heap&nbsp;=&nbsp;heap&nbsp;+&nbsp;1<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Generate&nbsp;instruction&nbsp;to&nbsp;store&nbsp;the&nbsp;integer&nbsp;representing&nbsp;True&nbsp;on&nbsp;the&nbsp;heap.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inst&nbsp;=&nbsp;<span class="literal">'set&nbsp;'</span>&nbsp;+&nbsp;<span class="builtin">str</span>(heap)&nbsp;+&nbsp;<span class="literal">'&nbsp;1'</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Return&nbsp;the&nbsp;instruction&nbsp;list&nbsp;and&nbsp;top&nbsp;of&nbsp;the&nbsp;heap.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;([inst],&nbsp;heap,&nbsp;fresh)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;f&nbsp;==&nbsp;<span class="literal">'False'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Find&nbsp;a&nbsp;new&nbsp;memory&nbsp;address&nbsp;on&nbsp;the&nbsp;heap.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heap&nbsp;=&nbsp;heap&nbsp;+&nbsp;1<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Generate&nbsp;instruction&nbsp;to&nbsp;store&nbsp;the&nbsp;integer&nbsp;representing&nbsp;False&nbsp;on&nbsp;the&nbsp;heap.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inst&nbsp;=&nbsp;<span class="literal">'set&nbsp;'</span>&nbsp;+&nbsp;<span class="builtin">str</span>(heap)&nbsp;+&nbsp;<span class="literal">'&nbsp;0'</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Return&nbsp;the&nbsp;instruction&nbsp;list&nbsp;and&nbsp;top&nbsp;of&nbsp;the&nbsp;heap.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;([inst],&nbsp;heap,&nbsp;fresh)<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;type(f)&nbsp;==&nbsp;Node:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;label&nbsp;<span class="keyword">in</span>&nbsp;f:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;children&nbsp;=&nbsp;f[label]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;label&nbsp;==&nbsp;<span class="literal">'Not'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Compile&nbsp;the&nbsp;subtree&nbsp;f&nbsp;to&nbsp;obtain&nbsp;the&nbsp;list&nbsp;of</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;instructions&nbsp;that&nbsp;computes&nbsp;the&nbsp;value&nbsp;represented</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;by&nbsp;f.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;children[0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(insts,&nbsp;heap,&nbsp;fresh)&nbsp;=&nbsp;compileFormula(f,&nbsp;heap,&nbsp;fresh)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Generate&nbsp;more&nbsp;instructions&nbsp;to&nbsp;change&nbsp;the&nbsp;memory</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;location&nbsp;in&nbsp;accordance&nbsp;with&nbsp;the&nbsp;definition&nbsp;of&nbsp;the</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Not&nbsp;operation.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instsNot&nbsp;=&nbsp;\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="literal">"branch&nbsp;setZero"</span>&nbsp;+&nbsp;str(fresh)&nbsp;+&nbsp;<span class="literal">"&nbsp;"</span>&nbsp;+&nbsp;<span class="builtin">str</span>(heap),\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">"set&nbsp;"</span>&nbsp;+&nbsp;<span class="builtin">str</span>(heap)&nbsp;+&nbsp;<span class="literal">"&nbsp;1"</span>,\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">"branch&nbsp;finish"</span>&nbsp;+&nbsp;<span class="builtin">str</span>(fresh),\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">"label&nbsp;setZero"</span>&nbsp;+&nbsp;<span class="builtin">str</span>(fresh),\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">"set&nbsp;"</span>&nbsp;+&nbsp;<span class="builtin">str</span>(heap)&nbsp;+&nbsp;<span class="literal">"&nbsp;0"</span>,\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">"label&nbsp;finish"</span>&nbsp;+&nbsp;<span class="builtin">str</span>(fresh)\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;(insts&nbsp;+&nbsp;instsNot,&nbsp;heap,&nbsp;fresh&nbsp;+&nbsp;1)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Or'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Compile&nbsp;the&nbsp;two&nbsp;subtrees&nbsp;and&nbsp;get&nbsp;the&nbsp;instructions</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;lists&nbsp;as&nbsp;well&nbsp;as&nbsp;the&nbsp;addresses&nbsp;in&nbsp;which&nbsp;the&nbsp;results</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;of&nbsp;computing&nbsp;the&nbsp;two&nbsp;subtrees&nbsp;would&nbsp;be&nbsp;stored&nbsp;if&nbsp;someone</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;were&nbsp;to&nbsp;run&nbsp;those&nbsp;machine&nbsp;instructions.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f1&nbsp;=&nbsp;children[0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f2&nbsp;=&nbsp;children[1]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(insts1,&nbsp;heap2,&nbsp;fresh1)&nbsp;=&nbsp;compileFormula(f1,&nbsp;heap,&nbsp;fresh)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(insts2,&nbsp;heap3,&nbsp;fresh2)&nbsp;=&nbsp;compileFormula(f2,&nbsp;heap2,&nbsp;fresh1)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Increment&nbsp;the&nbsp;heap&nbsp;counter&nbsp;so&nbsp;we&nbsp;store&nbsp;the</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;result&nbsp;of&nbsp;computing&nbsp;Or&nbsp;in&nbsp;a&nbsp;new&nbsp;location.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heap4&nbsp;=&nbsp;heap3&nbsp;+&nbsp;1<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Add&nbsp;instructions&nbsp;that&nbsp;compute&nbsp;the&nbsp;result&nbsp;of&nbsp;the</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Or&nbsp;operation.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instsOr&nbsp;=&nbsp;\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="literal">"copy&nbsp;"</span>&nbsp;+&nbsp;<span class="builtin">str</span>(heap2)&nbsp;+&nbsp;<span class="literal">"&nbsp;1"</span>,\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">"copy&nbsp;"</span>&nbsp;+&nbsp;<span class="builtin">str</span>(heap3)&nbsp;+&nbsp;<span class="literal">"&nbsp;2"</span>,\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">"add"</span>,\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">"branch&nbsp;setOne"</span>&nbsp;+&nbsp;<span class="builtin">str</span>(fresh2)&nbsp;+&nbsp;<span class="literal">"&nbsp;0"</span>,\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">"branch&nbsp;finish"</span>&nbsp;+&nbsp;<span class="builtin">str</span>(fresh2),\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">"label&nbsp;setOne"</span>&nbsp;+&nbsp;<span class="builtin">str</span>(fresh2),\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">"set&nbsp;0&nbsp;1"</span>,\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">"label&nbsp;finish"</span>&nbsp;+&nbsp;<span class="builtin">str</span>(fresh2),\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="literal">"copy&nbsp;0&nbsp;"</span>&nbsp;+&nbsp;<span class="builtin">str</span>(heap4)\<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;(insts1&nbsp;+&nbsp;insts2&nbsp;+&nbsp;instsOr,&nbsp;heap4,&nbsp;fresh2&nbsp;+&nbsp;1)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
      </div></div></div></div>
  <a name="5.5"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#5.5">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">5.5.</span> Compiling statement sequences and procedures to a machine language or bytecode</h3>
<a name="f7d604542fe211e38cf6ce3f5508acd9"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#f7d604542fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="definition_required"><b>Definition:</b> 
The region of memory that a machine program uses to store information that makes it possible to simulate calls to named procedures is called the <i>stack</i>.
<br/><br/>
In its simplest form, the stack is simply a region of memory that holds integers corresponding to program locations. The top of the stack always corresponds to the program location to which control must move once the procedure that is currently being simulated reaches the end of its body.
      </div></div></div>
<a name="f7d618222fe211e38cf6ce3f5508acd9"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#f7d618222fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">Suppose we are starting with the following source language:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>variable</i> <b>:=</b> <i>formula</i> <b>;</b> <i>program</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>print</b> <i>formula</i> <b>;</b> <i>program</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>procedure</b> <i>variable</i> <b>{</b> <i>program</i> <b>}</b> <i>program</i>  </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>call</b> <i>variable</i> <b>;</b> <i>program</i>  </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>formula</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> | <b>false</b> | <i>variable</i> | <b>not</b> <i>formula</i> | <i>formula</i> <b>and</b> <i>formula</i> | <i>formula</i> <b>or</b> <i>formula</i>
</td></tr></table></td></tr></table>
How can we implement a compiler that converts formulas in the source language into sequences of instructions in the target language in a <a href="#3246043602d540668dc63d5b6277a47f">previous example</a>?</span>   
      </div></div></div></div><br/><hr/><a name="5.6"></a><a name="assignment3"></a><a name="hw3"></a><div class="assignment"><h3 class="linked"><span class="link-title">[<a href="#5.6">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">5.6.</span> <span class="assignment_title">Assignment #3: Compilation and Review of Interpretation</span></h3><div class="instructions">
In this assignment you will practice implementing interpretation and compilation algorithms using Python. You must submit four Python source files:
<ul>
  <li><code><a href="hw3/parse.py">hw3/parse.py</a></code> (there is no need to modify this file);</li>
  <li><code><a href="hw3/interpret.py">hw3/interpret.py</a></code>;</li>
  <li><code><a href="hw3/machine.py">hw3/machine.py</a></code>;</li>
  <li><code>hw3/compile.py</code>.</li>
</ul>
Please follow the <a href="http://www.cs.bu.edu/teaching/hw/gsubmit/">gsubmit</a> directions and remember to put your files in the <code>hw3</code> directory.
<br/><br/>
Your solutions to each of the problem parts below will be graded on their correctness, concision, and mathematical legibility. The different problems and problem parts rely on the lecture notes and on each other; carefully consider whether you can use functions from the lecture notes, or functions you define in one part within subsequent parts.
<br/><br/>
<b style="color:green;">A testing script with several test cases is available for download: <a href="a3-tests.py"><code>a3-tests.py</code></a>. You should be able to place it in the same directory with the other assignment files and run it. Feel free to modify or extend it as you see fit.</b>
<br/><br/>
<b style="color:green;">A full solution to this assignment is now available here: <a href="hw3/solutions/"><code>/hw3/solutions</code></a>.</b>
      
      </div><ol class="problems"><li class="problem">
<span class="text">In this problem, you will implement an interpreter for a high-level language. All the functions you define should be included in the file <code><a href="hw3/interpret.py">hw3/interpret.py</a></code>. The abstract syntax for the language is presented below:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>term</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;">  <i>number</i> | <i>variable</i> | <i>term</i> <b>+</b> <i>term</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>formula</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;">  <b>true</b> | <b>false</b> | <i>variable</i>
                  <!-- | <b>forall</b> <i>variable</i> <b>to</b> <i>number</i> <b>,</b>&nbsp; <i>formula</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;"> -->
                  | <b>not</b> <i>formula</i> | <i>formula</i> <b>and</b> <i>formula</i> | <i>formula</i> <b>or</b> <i>formula</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                  <!-- | <i>term</i> <b>==</b> <i>term</i> -->
                  <!-- | <i>term</i> <b>&lt;</b> <i>term</i> -->
<i>expression</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>term</i> | <i>formula</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>print</b> <i>expression</i> <b>;</b> <i>program</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>variable</i> <b>:=</b> <i>expression</i> <b>;</b> <i>program</i></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>if</b> <i>expression</i> <b>{</b> <i>program</i> <b>}</b> <i>program</i></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>while</b> <i>expression</i> <b>{</b> <i>program</i> <b>}</b> <i>program</i></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>procedure</b> <i>variable</i> <b>{</b> <i>program</i> <b>}</b> <i>program</i>  </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>call</b> <i>variable</i> <b>;</b> <i>program</i>  </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
</td></tr></table></td></tr></table>
The relevant portions of the operational semantics are provided below:</span><div class="inferences"><table class="inference"><tr><td class="title">[Term-Variable]</td><td><table><tr><td class="premises">&nbsp;&Sigma;(<i>x</i>) = <i>t</i> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;, <i>t</i> &dArr; <i>v</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <i>x</i> &dArr; <i>v</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-Variable]</td><td><table><tr><td class="premises">&nbsp;&Sigma;(<i>x</i>) = <i>f</i> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;, <i>f</i> &dArr; <i>v</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <i>x</i> &dArr; <i>v</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-Or]</td><td><table><tr><td class="premises">&nbsp;&Sigma;, <i>f</i><sub>1</sub> &dArr; <i>v</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;, <i>f</i><sub>2</sub> &dArr; <i>v</i><sub>2</sub>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <i>f</i><sub>1</sub> <b>or</b> <i>f</i><sub>2</sub> &dArr; <i>v</i><sub>1</sub> &or; <i>v</i><sub>2</sub>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-Assign]</td><td><table><tr><td class="premises">&nbsp;&Sigma;<sub>1</sub> &#8846; {<i>x</i> &#x21A6; <i>e</i>}, <i>p</i> &dArr; &Sigma;<sub>2</sub>, <i>o</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;<sub>1</sub>, <b>assign</b> <i>x</i> <b>:=</b> <i>e</i> <b>;</b> <i>p</i> &dArr; &Sigma;<sub>2</sub>, <i>o</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-Procedure]</td><td><table><tr><td class="premises">&nbsp;&Sigma;<sub>1</sub> &#8846; {<i>x</i> &#x21A6; <i>p</i><sub>1</sub>}, <i>p</i><sub>2</sub> &dArr; &Sigma;<sub>2</sub>, <i>o</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;<sub>1</sub>, <b>procedure</b> <i>x</i> <b>{</b> <i>p</i><sub>1</sub> <b>}</b> <i>p</i><sub>2</sub> &dArr; &Sigma;<sub>2</sub>, <i>o</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-Call]</td><td><table><tr><td class="premises">&nbsp;&Sigma;<sub>1</sub>(<i>x</i>) = <i>p</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;<sub>1</sub>, <i>p</i><sub>1</sub> &dArr; &Sigma;<sub>2</sub>, <i>o</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;<sub>2</sub>, <i>p</i><sub>2</sub> &dArr; &Sigma;<sub>3</sub>, <i>o</i><sub>2</sub>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;<sub>1</sub>, <b>call</b> <i>x</i> <b>;</b> <i>p</i><sub>2</sub> &dArr; &Sigma;<sub>3</sub>, <i>o</i><sub>1</sub>;<i>o</i><sub>2</sub>&nbsp;</td></tr></table></td></tr></table></div>
<span class="text">The remaining rules 
<span style="font-variant:small-caps;">[Term-Number]</span>, 
<span style="font-variant:small-caps;">[Term-Plus]</span>, 
<span style="font-variant:small-caps;">[Formula-True]</span>, 
<span style="font-variant:small-caps;">[Formula-False]</span>, 
<span style="font-variant:small-caps;">[Formula-Not]</span>, 
<span style="font-variant:small-caps;">[Formula-And]</span>, 
<span style="font-variant:small-caps;">[Statement-Print]</span>, 
<span style="font-variant:small-caps;">[Statement-If-False]</span>, 
<span style="font-variant:small-caps;">[Statement-If-True]</span>, 
<span style="font-variant:small-caps;">[Statement-While-False]</span>, 
<span style="font-variant:small-caps;">[Statement-While-True]</span>, and 
<span style="font-variant:small-caps;">[Statement-End]</span> are exactly the same as those in <b><a href="#assignment2">Assignment #2</a></b>. Notice the subtle differences between the above rules for <span style="font-variant:small-caps;">[Formula-Variable]</span>, <span style="font-variant:small-caps;">[Term-Variable]</span>, and <span style="font-variant:small-caps;">[Statement-Assign]</span> and the versions of these in <b><a href="#assignment2">Assignment #2</a></b>: in the above rules, expressions are only evaluated at the time a variable is encountered, and not at the time of assignment. Also notice that the environment now also contains mappings from procedure names to procedure bodies.</span><ol class="parts"><li class="part">
<span class="text">Implement a function <code>evalTerm(env, t)</code> that takes an environment <code>env</code> and a parse tree <code>t</code> as its two arguments. The function should return the value that corresponds to the evaluation of the parse tree <code>t</code>, as determined by the operational semantics.</span></li><li class="part">
<span class="text">Implement a function <code>evalFormula(env, f)</code> that takes an environment <code>env</code> and a parse tree <code>f</code> as its two arguments. The function should return the value that corresponds to the evaluation of the parse tree <code>t</code>, as determined by the operational semantics.</span></li><li class="part">
<span class="text">Implement a function <code>execProgram(env, s)</code> that takes an environment <code>env</code> and a parse tree <code>s</code> as its two arguments. The function should return a tuple containing an updated environment and the output (represented as a list of values) that represent the result of the execution of the program <code>s</code> as determined by the operational semantics.</span></li></ol></li><li class="problem">
<span class="text">In this problem you will implement several helper functions for building sequences of instructions in a machine language. The file <code><a href="hw3/machine.py">hw3/machine.py</a></code> already contains a simulator for the machine language with which you will be working; the machine language is defined in detail in <a href="#3246043602d540668dc63d5b6277a47f">a previous example in the lecture notes</a>.
Although any correct implementation is acceptable, it is suggested that you follow the conventions below:
<ul>
  <li>use negative memory addresses, starting at <code>-1</code>, for the stack;</li>
  <li>use memory address <code>7</code> to store the memory address of the top of the stack;</li>
  <li>use memory addresses <code>8</code> and higher for the heap (i.e., results of computations).</li>
</ul>
All the functions you define should be included in the file <code><a href="hw3/machine.py">hw3/machine.py</a></code>.</span><ol class="parts"><li class="part">
<span class="text">Implement a function <code>increment(addr)</code> that takes a single integer argument <code>addr</code>. The function should return a list of instructions (in which each instruction is represented as a string in the list). These instructions should correspond to a machine language program that increments by <code>1</code> the integer stored in the memory location <code>addr</code> and cleans up any memory addresses it used in the process by setting them back to <code>0</code>.</span></li><li class="part">
<span class="text">Implement a function <code>decrement(addr)</code> that takes a single integer argument <code>addr</code>. The function should return a sequence of instructions (represented as a Python list of strings). These instructions should correspond to a machine language program that decrements by <code>1</code> the integer stored in the memory location <code>addr</code> and cleans up any memory addresses it used in the process by setting them back to <code>0</code>.</span></li><li class="part">
<span class="text">Implement a function <code>call(name)</code> that takes a single argument: <code>name</code> is a string corresponding to the name of a procedure. The function should return a sequence of instructions that performs the following operations:
<ul>
  <li>update the integer stored in the memory address that contains the address of the top of the call stack (i.e., decrement it, since the stack is in the part of memory indexed using negative integers);</li>
  <li>store the current program location at the top of the call stack;</li>
  <li>increment the value at the top of the call stack so it refers to the location in the program to which control should return after the end of the procedure being invoked;</li>
  <li><b>goto</b> the procedure body that corresponds to the procedure <code>name</code> supplied;</li>
  <li>update the integer stored in the memory address that contains the address of the top of the call stack (i.e., increment it, since the stack is in the part of memory indexed using negative integers).</li>
</ul>
The third step above is crucial: failing to specify the correct return location in the program can lead to an infinite loop.</span></li><li class="part">
<span class="text">Implement a function <code>procedure(name, body)</code> that takes two arguments: <code>name</code> is a string corresponding to the name of a procedure, and <code>body</code> is a sequence of machine language instructions (represented as a Python list of strings). The function should return a sequence of instructions that includes:
<ul>
  <li>a <b>goto</b> instruction so that the procedure body is skipped by default if instructions are being executed sequentially;</li>
  <li>a label identifying the start of the procedure body;</li>
  <li>the procedure body</li>
  <li>instructions to <b>jump</b> back to the machine language program location that invoked the procedure;</li>
  <li>a label identifying the end of the procedure body.</li>
</ul></span></li></ol></li><li class="problem">
<span class="text">In this problem you will implement a compiler. The source language of the compiler will be the language for which you implemented an interpreter in <b>Problem #1</b>. The target language will be the machine language with which you worked in <b>Problem #2</b>.</span><ol class="parts"><li class="part">
<span class="text">Implement a function <code>compileTerm(env, t, heap)</code> that takes three arguments: <code>env</code> is a mapping from variables to memory addresses, <code>t</code> is a <i>term</i> parse tree, and <code>heap</code> is the memory address of the current top of the heap. The function should return a tuple <code>(insts, addr, heap)</code> in which <code>insts</code> is a sequence of machine language instructions (represented as a Python list of strings) that perform the computation represented by the parse tree, <code>addr</code> is the address of the result, and <code>heap</code> is an integer representing the memory of the top of the heap after the computation is performed.</span></li><li class="part">
<span class="text">Implement a function <code>compileFormula(env, f, heap)</code>. The requirements for this function are the same as those for <code>compileTerm(env, t, heap)</code>, except that it must handle <i>formula</i> parse trees.</span></li><li class="part">
<span class="text">Implement a function <code>compileProgram(env, s, heap)</code> that takes three arguments: <code>env</code> is a mapping from variables to memory addresses, <code>s</code> is a <i>program</i> parse tree, and <code>heap</code> is the memory address of the current top of the heap. The function should return a tuple <code>(env, insts, heap)</code> in which <code>env</code> is an updated environment, <code>insts</code> is a sequence of machine language instructions (represented as a Python list of strings) that perform the computation represented by the parse tree, and <code>heap</code> is an integer representing the memory of the top of the heap after the computation is performed.</span></li><li class="part">
<span class="text">Implement a function <code>compile(s)</code> that takes a single string <code>s</code> that is a concrete syntax representation of a program in the source programming language and returns its compiled form: a sequence of instructions in the target machine language.</span></li></ol></li></ol>
</div><hr/><br/>
  <a name="5.7"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#5.7">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">5.7.</span> Common optimizations</h3>
<span class="text">Optimization algorithms are typically transformations of the abstract syntax of a language. In a compiler, this abstract syntax is usually that of a particular intermediate representation used within the compiler, but optimizations might occur at any stage in the compilation process.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">source<br/>language<br/>abstract<br/>syntax</td>
    <td><span style="font-size:20px;">&rArr;<br/>&lArr;</span></td>
    <td class="box" style="background-color:lightyellow;">optimization<br/>algorithm #1</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">compilation<br/>algorithm A</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:powderblue;">intermediate<br/>representation<br/>(IR) #1</td>
    <td><span style="font-size:20px;">&rArr;<br/>&lArr;</span></td>
    <td class="box" style="background-color:lightyellow;">optimization<br/>algorithm #2</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">compilation<br/>algoritm B</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:powderblue;">intermediate<br/>representation<br/>(IR) #2</td>
    <td><span style="font-size:20px;">&rArr;<br/>&lArr;</span></td>
    <td class="box" style="background-color:lightyellow;">optimization<br/>algorithm #3</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">compilation<br/>algorithm C</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:powderblue;">target<br/>language<br/>abstract<br/>syntax</td>
    <td><span style="font-size:20px;">&rArr;<br/>&lArr;</span></td>
    <td class="box" style="background-color:lightyellow;">optimization<br/>algorithm #4</td>
  </tr>
</table>
</div></span>
<a name="f7d61c822fe211e38cf6ce3f5508acd9"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#f7d61c822fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="definition_required"><b>Definition:</b> 
<i>Loop unrolling</i> involves duplicating loop bodies a constant number of times, typically to reduce the number of conditional <b>branch</b> instructions that must occur if the number of loop iterations is known at compile time.
      </div></div></div>
<a name="f7d6137c2fe211e38cf6ce3f5508acd9"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#f7d6137c2fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="definition_required"><b>Definition:</b> 
<i>Constant folding</i> involves replacing subtrees (typically expressions) within an abstract syntax tree with values (the value should normally correspond to the result of evaluating the expression).
      </div></div></div></div>
  <a name="5.8"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#5.8">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">5.8.</span> Correctness of compilation algorithms</h3>
<span class="text">Compilers represent a unique kind of software application because their implementation can affect the quality of all the software applications that they compile. This means that compiler flaws can be particularly expensive; as a result, there may be many practical justifications for investing heavily in verifying that a compiler, or components thereof, behave correctly. However, to determine whether a compiler behaves correctly, it is first necessary to define what constitutes correct behavior.
<br/><br/>
One way to define correct behavior is to appeal to the operational semantics of the source and target languages.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">source language<br/>abstract syntax</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">compilation<br/>algorithm</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">target language<br/>abstract syntax</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&#8659;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td><span style="font-size:20px;">&#8659;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">source language<br/>operational semantics<br/>(interpreter)</td>
    <td></td>
    <td></td>
    <td></td>
    <td class="box" style="background-color:lightyellow;">target language<br/>operational semantics<br/>(simulator)</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&#8659;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:powderblue;">source language<br/>abstract syntax<br/>for values/outputs</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">simple<br/>conversion<br/>algorithm for<br/>values/outputs</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">target language<br/>abstract syntax<br/>for values/outputs</td>
  </tr>
</table>
</div></span>
<a name="f7d611922fe211e38cf6ce3f5508acd9"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#f7d611922fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="definition_required"><b>Definition:</b> 
Suppose we are given a source and target language (including the definitions of the abstract syntax and the operational semantics for each language, as well as corresponding interpretation/simulation functions <b>interpret()</b> and <b>simulate()</b>), a simple conversion algorithm <b>convert()</b> between the sets of values and outputs in each language, and a compilation algorithm <b>compile()</b>.
<br/><br/>
The compilation algorithm <b>compile()</b> is <i>correct</i> (or <i>behaves correctly</i>) if for all possible input programs <i>p</i> in the source language, the following equation is true:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><b>simulate(compile(</b><i>p</i><b>))</b><td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>convert(interpret(</b><i>p</i><b>))</b>
</td></tr></table></td></tr></table>
      </div></div></div>
<span class="text">Notice that the <a href="#f7d611922fe211e38cf6ce3f5508acd9">above definition</a> of correctness is functional but perhaps not practical. If the operational semantics of one or both languages does not capture running time, security (e.g., stack overflows), or other concerns, the definition may be inadequate. We will discuss these issues in more detail in a <a href="#6">subsequent section</a>.
<br/><br/>
If the number of possible programs in the source language is infinite, it is impossible to check that the equation in the <a href="#f7d611922fe211e38cf6ce3f5508acd9">above definition</a> holds for all possible programs through testing alone, though testing can provide some confidence. Nevertheless, it may be possible to mathematically <i>prove</i> that the equation holds without doing any testing at all.
<br/><br/>
Software testing and verification is a broad area of research and practice that spans multiple (sometimes disparate) disciplines and communities. In this subsection, we will focus on three specific categories of testing and verification that are useful for determining the correctness of compiler implementations. These three categories represent only a small (but important) subset of the approaches currently being developed and used.</span>
<a name="f7d6204c2fe211e38cf6ce3f5508acd9"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#f7d6204c2fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="definition_required"><b>Definition:</b> 
        
<span class="text">There are at least three possible approaches to verifying that a compiler's behavior conforms to its specification. These include:</span>
        <ul><li>suites of individual test cases;</li><li>bounded exhaustive testing;</li><li>formal (usually inductive) proof of correctness over all inputs.</li></ul>
      </div></div></div>
<a name="f7d61a842fe211e38cf6ce3f5508acd9"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#f7d61a842fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">Bounded exhaustive testing involves defining a metric on inputs (e.g., a mapping from inputs to an integer), and then testing all inputs for which the matric is below a certain integer bound. For example, let us consider a simple language for formulas:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>formula</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> | <b>false</b> | <b>not</b> <i>formula</i>| <i>formula</i> <b>and</b> <i>formula</i> | <i>formula</i> <b>or</b> <i>formula</i> 
</td></tr></table></td></tr></table>
We can define a metric on the set of abstract syntax trees that conform to the above definition: the depth of the tree.</span>
        
<div class="code"><div class="source"><br/>Node&nbsp;=&nbsp;<span class="builtin">dict</span><br/>Leaf&nbsp;=&nbsp;<span class="builtin">str</span><br/><br/><span class="keyword">def</span>&nbsp;metric(f):<br/>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;<span class="builtin">type</span>(f)&nbsp;==&nbsp;Leaf:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;1<br/>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;<span class="builtin">type</span>(f)&nbsp;==&nbsp;Node:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;label&nbsp;<span class="keyword">in</span>&nbsp;f:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;1&nbsp;+&nbsp;<span class="builtin">max</span>([metric(child)&nbsp;<span class="keyword">for</span>&nbsp;child&nbsp;<span class="keyword">in</span>&nbsp;f[label]])<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">We can then generate all trees whose metric falls within a specified bound.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">def</span>&nbsp;formulas(n):<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;n&nbsp;<=&nbsp;0:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[]<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">elif</span>&nbsp;n&nbsp;==&nbsp;1:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;[<span class="literal">'True'</span>,&nbsp;<span class="literal">'False'</span>]<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fs&nbsp;=&nbsp;formulas(n-1)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fsN&nbsp;=&nbsp;[]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fsN&nbsp;+=&nbsp;[{<span class="literal">'Not'</span>:[f]}&nbsp;<span class="keyword">for</span>&nbsp;f&nbsp;<span class="keyword">in</span>&nbsp;fs]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fsN&nbsp;+=&nbsp;[{<span class="literal">'And'</span>:[f1,f2]}&nbsp;<span class="keyword">for</span>&nbsp;f1&nbsp;<span class="keyword">in</span>&nbsp;fs&nbsp;<span class="keyword">for</span>&nbsp;f2&nbsp;<span class="keyword">in</span>&nbsp;fs]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fsN&nbsp;+=&nbsp;[{<span class="literal">'Or'</span>:[f1,f2]}&nbsp;<span class="keyword">for</span>&nbsp;f1&nbsp;<span class="keyword">in</span>&nbsp;fs&nbsp;<span class="keyword">for</span>&nbsp;f2&nbsp;<span class="keyword">in</span>&nbsp;fs]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;fs&nbsp;+&nbsp;fsN<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">It is then possible to use the above code to generate test cases automatically, and to check the equation specifying compiler correctness against each test case.</span>
      </div></div></div></div>
</div><a name="M.1"></a><div class="midterm"><hr style="margin-bottom:120px;"/><h2 class="linked"><span class="link-title">[<a href="#M.1">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">Midterm.</span> Programming Languages, Interpreters, and Compilers</h2><div class="instructions">
      
<span class="text"><i>This material is no longer available.</i></span>
    </div>
</div>
<a name="6"></a>
<div class="section"><hr style="margin-bottom:120px;"/><h2 class="linked"><span class="link-title">[<a href="#6">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">6.</span> Static Analysis and Abstract Interpretation</h2>
<span class="text">Most compilers and interpreters perform basic error checking and <i>static analysis</i> before running or compiling a program. This serves a variety of purposes, some of which include:
<ul>
  <li>catching errors in the program before incurring the cost (in time, power, etc.) or actually running it;</li>
  <li>returning more detailed and user-friendly error messages;</li>
  <li>determining information about the program that is required for the optimization and compilation algorithms (e.g., detecting opportunities for constant folding);</li>
  <li>improving performance of interpreted or compiled programs by eliminating run-time error checking;</li>
  <li>eliminating invalid test cases when doing bounded exhaustive testing.</li>
</ul>
Static analysis is related to a broader concept: <i>abstract interpretation</i>. It is possible to analyze programs along a variety of other dimensions that may of interest, including, for example, the program's range of outputs, the program's running time, the monetary cost of running the program, the program's power consumption, and so on.
<br/><br/>
Both static analysis and abstract interpretation algorithms are conventionally expected to terminate in a finite, and typically relatively fast, amount of time (e.g., it should be possible to run a new static analysis or abstract interpretation each and every time the program is compiled, even during an interactive programming and/or testing session).
<br/><br/>
In this section we present a notation for defining static analysis and abstract interpretation algorithms. This notation is very similar to the one we introduced for defining the <a href="#4.2">operational semantics</a> of programming languages.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">source<br/>language<br/>concrete<br/>syntax</td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td class="box" style="background-color:powderblue;">target<br/>language<br/>abstract<br/>syntax</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td><span style="font-size:20px;">&uArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">parser</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">source<br/>language<br/>abstract<br/>syntax</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">static<br/>analysis<br/>algorithms</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">abstract<br/>syntax<br/>or IR</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">compilation<br/>algorithms</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td class="box" style="background-color:powderblue;">syntax<br/>errors</td>
    <td></td>
    <td></td>
    <td></td>
    <td class="box" style="background-color:powderblue;">other errors<br/>(unbound variables,<br/>type errors, etc.)</td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
</table>
</div></span>
  <a name="6.1"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#6.1">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">6.1.</span> Monomorphic type systems and type checking</h3>
<span class="text">A <i>type checking</i> algorithm is a specific kind of static analysis algorithm. It represents a "low-resolution" evaluation of the abstract syntax tree of a program to determine the <i>type</i> that can be assigned to every subtree in that program.</span>
<a name="f7d607382fe211e38cf6ce3f5508acd9"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#f7d607382fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">Suppose we are working with a programming language with the following abstract syntax.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>expression</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> | <b>false</b> | <i>number</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>not</b> <i>expression</i>  </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>expression</i> <b>and</b> <i>expression</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>expression</i> <b>or</b> <i>expression</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>expression</i> <b>+</b> <i>expression</i>
</td></tr></table></td></tr></table>
The abstrac syntax for types is defined as follows:                   
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">           
<i>type</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b style="color:firebrick">integer</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b style="color:firebrick">boolean</b>
</td></tr></table></td></tr></table>
We can define a set of type inference rules for this language. These rules constitute the type system for the language.</span>
        <div class="inferences"><table class="inference"><tr><td class="title">[Formula-True]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&#8866; <b>true</b>: <b style="color:firebrick">boolean</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-False]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&#8866; <b>false</b>: <b style="color:firebrick">boolean</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-Not]</td><td><table><tr><td class="premises">&nbsp;&#8866; <i>e</i>: <b style="color:firebrick">boolean</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&#8866; <b>not</b> <i>e</i>: <b style="color:firebrick">boolean</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-And]</td><td><table><tr><td class="premises">&nbsp;&#8866; <i>e</i><sub>1</sub>: <b style="color:firebrick">boolean</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &#8866; <i>e</i><sub>2</sub>: <b style="color:firebrick">boolean</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&#8866; <i>e</i><sub>1</sub> <b>and</b> <i>e</i><sub>2</sub>: <b style="color:firebrick">boolean</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-Or]</td><td><table><tr><td class="premises">&nbsp;&#8866; <i>e</i><sub>1</sub>: <b style="color:firebrick">boolean</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;  &#8866; <i>e</i><sub>2</sub>: <b style="color:firebrick">boolean</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&#8866; <i>e</i><sub>1</sub> <b>or</b> <i>e</i><sub>2</sub>: <b style="color:firebrick">boolean</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Term-Number]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&#8866; <i>number</i>: <b style="color:firebrick">integer</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Term-Plus]</td><td><table><tr><td class="premises">&nbsp;&#8866; <i>e</i><sub>1</sub>: <b style="color:firebrick">integer</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &#8866; <i>e</i><sub>2</sub>: <b style="color:firebrick">integer</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&#8866; <i>e</i><sub>1</sub> <b>+</b> <i>e</i><sub>2</sub>: <b style="color:firebrick">integer</b>&nbsp;</td></tr></table></td></tr></table></div>
        
<span class="text">We can convert the above inference rules into a type checking algorithm; the process is almost identical to the process used for converting an operational semantics into an interpreter implementation.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">def</span>&nbsp;typeCheck(e):<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="builtin">type</span>(e)&nbsp;==&nbsp;Leaf:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;e&nbsp;==&nbsp;<span class="literal">'True'</span>&nbsp;<span class="keyword">or</span>&nbsp;e&nbsp;==&nbsp;<span class="literal">'False'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="literal">'boolean'</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="builtin">type</span>(e)&nbsp;==&nbsp;Node:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;label&nbsp;<span class="keyword">in</span>&nbsp;e:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Number'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="literal">'integer'</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Not'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[e1]&nbsp;=&nbsp;e[label]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t1&nbsp;=&nbsp;typeCheck(e1)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;t1&nbsp;!=&nbsp;<span class="literal">'boolean'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="builtin">print</span>(<span class="literal">"not&nbsp;must&nbsp;be&nbsp;applied&nbsp;to&nbsp;a&nbsp;boolean"</span>)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="builtin">None</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="literal">'boolean'</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;...</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Plus'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[e1,e2]&nbsp;=&nbsp;e[label]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t1&nbsp;=&nbsp;typeCheck(e1)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t2&nbsp;=&nbsp;typeCheck(e2)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;t1&nbsp;!=&nbsp;<span class="literal">'integer'</span>&nbsp;<span class="keyword">or</span>&nbsp;t2&nbsp;!=&nbsp;<span class="literal">'integer'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="builtin">print</span>(<span class="literal">"+&nbsp;requires&nbsp;integer&nbsp;arguments"</span>)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="builtin">None</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="literal">'integer'</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
      </div></div></div>
<a name="f7d615702fe211e38cf6ce3f5508acd9"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#f7d615702fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">Suppose we are working with a programming language with the following abstract syntax.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>program</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>variable</i> <b>:=</b> <i>expression</i> <b>;</b> <i>program</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>expression</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>variable</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>constant</i>  </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>not</b> <i>expression</i>  </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>expression</i> <b>and</b> <i>expression</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>expression</i> <b>or</b> <i>expression</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>expression</i> <b>*</b> <i>expression</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                   <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>expression</i> <b>+</b> <i>expression</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>constant</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>true</b> | <b>false</b> | <i>number</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>number</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid integer</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>variable</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid variable</i></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
<i>type</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b style="color:firebrick">integer</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b style="color:firebrick">boolean</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b style="color:firebrick">void</b>
</td></tr></table></td></tr></table>
We can define a set of type inference rules for this language. These rules constitute the type system for the language.</span>
        <div class="inferences"><table class="inference"><tr><td class="title">[Statement-Assign]</td><td><table><tr><td class="premises">&nbsp;&Gamma; &#8846; {<i>x</i> &#x21A6; &tau;} &#8866; <i>p</i>: <b style="color:firebrick">void</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>e</i>: &tau;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>x</i> <b>:=</b> <i>e</i> <b>;</b> <i>p</i> : <b style="color:firebrick">void</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-End]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b style="color:gray;">end</b>: <b style="color:firebrick">void</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Variable]</td><td><table><tr><td class="premises">&nbsp;&Gamma;(<i>x</i>) = &tau;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>x</i>: &tau;&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-True]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b>true</b>: <b style="color:firebrick">boolean</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-False]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b>false</b>: <b style="color:firebrick">boolean</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-Not]</td><td><table><tr><td class="premises">&nbsp;&Gamma; &#8866; <i>e</i>: <b style="color:firebrick">boolean</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b>not</b> <i>e</i>: <b style="color:firebrick">boolean</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-And]</td><td><table><tr><td class="premises">&nbsp;&Gamma; &#8866; <i>e</i><sub>1</sub>: <b style="color:firebrick">boolean</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>e</i><sub>2</sub>: <b style="color:firebrick">boolean</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>e</i><sub>1</sub> <b>and</b> <i>e</i><sub>2</sub>: <b style="color:firebrick">boolean</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Formula-Or]</td><td><table><tr><td class="premises">&nbsp;&Gamma; &#8866; <i>e</i><sub>1</sub>: <b style="color:firebrick">boolean</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>e</i><sub>2</sub>: <b style="color:firebrick">boolean</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>e</i><sub>1</sub> <b>or</b> <i>e</i><sub>2</sub>: <b style="color:firebrick">boolean</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Term-Number]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>number</i>: <b style="color:firebrick">integer</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Term-Plus]</td><td><table><tr><td class="premises">&nbsp;&Gamma; &#8866; <i>e</i><sub>1</sub>: <b style="color:firebrick">integer</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>e</i><sub>2</sub>: <b style="color:firebrick">integer</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>e</i><sub>1</sub> <b>+</b> <i>e</i><sub>2</sub>: <b style="color:firebrick">integer</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Term-Mult]</td><td><table><tr><td class="premises">&nbsp;&Gamma; &#8866; <i>e</i><sub>1</sub>: <b style="color:firebrick">integer</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>e</i><sub>2</sub>: <b style="color:firebrick">integer</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>e</i><sub>1</sub> <b>*</b> <i>e</i><sub>2</sub>: <b style="color:firebrick">integer</b>&nbsp;</td></tr></table></td></tr></table></div>
      </div></div></div>
<a name="f7d60f9e2fe211e38cf6ce3f5508acd9"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#f7d60f9e2fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">Suppose we are working with a programming language that supports the definition of functions that take a single integer argument.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">program <i>p</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>function</b> <i>f</i> <b>(</b> <b>int</b> <i>x</i> <b>)</b> <b>{</b> <b>return</b> <i>e</i> <b>;</b> <b>}</b> <i>p</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>x</i> <b>:=</b> <i>e</i> <b>;</b> <i>p</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
expression <i>e</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>x</i> | <i>n</i> | <i>e</i> <b>+</b> <i>e</i> | <i>f</i> <b>(</b> <i>e</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
number <i>n</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid integer</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
variable <i>f</i>, <i>x</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid variable</i></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
type &tau; <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b style="color:firebrick">int</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b style="color:firebrick">int <span style="font-size:12px;">&#8594;</span> int</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b style="color:firebrick">void</b>
</td></tr></table></td></tr></table>
We can define a set of type inference rules for this language. These rules constitute the type system for the language.</span>
        <div class="inferences"><table class="inference"><tr><td class="title">[Statement-Assign]</td><td><table><tr><td class="premises">&nbsp;
            &Gamma; &#8846; {<i>x</i> &#x21A6; <b style="color:firebrick">int</b>} &#8866; <i>p</i>: <b style="color:firebrick">void</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>e</i>: <b style="color:firebrick">int</b>
            &nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>x</i> <b>:=</b> <i>e</i> <b>;</b> <i>p</i> : <b style="color:firebrick">void</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-Function]</td><td><table><tr><td class="premises">&nbsp;
            &Gamma; &#8846; {<i>f</i> &#x21A6; <b style="color:firebrick">int <span style="font-size:12px;">&#8594;</span> int</b>} &#8866; <i>p</i>: <b style="color:firebrick">void</b> 
            &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8846; {<i>x</i> &#x21A6; <b style="color:firebrick">int</b>} &#8866; <i>e</i>: <b style="color:firebrick">int</b>
            &nbsp;</td></tr><tr><td class="conclusion">&nbsp;
            &Gamma; &#8866; <b>function</b> <i>f</i> <b>(</b> <b style="color:firebrick">int</b> <i>x</i> <b>)</b> <b>{</b> <b>return</b> <i>e</i> <b>;</b> <b>}</b> <i>p</i> : <b style="color:firebrick">void</b>
            &nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-End]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b style="color:gray;">end</b>: <b style="color:firebrick">void</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Term-Variable]</td><td><table><tr><td class="premises">&nbsp;&Gamma;(<i>x</i>) = <b style="color:firebrick">int</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>x</i>: <b style="color:firebrick">int</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Term-Number]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>n</i>: <b style="color:firebrick">int</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Term-Plus]</td><td><table><tr><td class="premises">&nbsp;&Gamma; &#8866; <i>e</i><sub>1</sub>: <b style="color:firebrick">int</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>e</i><sub>2</sub>: <b style="color:firebrick">int</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>e</i><sub>1</sub> <b>+</b> <i>e</i><sub>2</sub>: <b style="color:firebrick">int</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Term-Apply]</td><td><table><tr><td class="premises">&nbsp;&Gamma;(<i>f</i>) = <b style="color:firebrick">int <span style="font-size:12px;">&#8594;</span> int</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>e</i>: <b style="color:firebrick">int</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>f</i> <b>(</b> <i>e</i> <b>)</b>: <b style="color:firebrick">int</b>&nbsp;</td></tr></table></td></tr></table></div>
        
<span class="text">Before implementing a type checking algorithm, suppose we want to implement an interpreter for this language. Below is an example of how it might be implemented.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">def</span>&nbsp;evaluate(env,&nbsp;e):<br/>&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="builtin">type</span>(e)&nbsp;==&nbsp;Node:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;label&nbsp;<span class="keyword">in</span>&nbsp;e:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;children&nbsp;=&nbsp;e[label]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Number'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;children[0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;n<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">elif</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Plus'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[e1,e2]&nbsp;=&nbsp;children<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;evaluate(env,&nbsp;e1)&nbsp;+&nbsp;evaluate(env,&nbsp;e2)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">elif</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Variable'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;children[0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value&nbsp;=&nbsp;env[x]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;value<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">elif</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Apply'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[f,&nbsp;eArg]&nbsp;=&nbsp;children<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;f[<span class="literal">'Variable'</span>][0]&nbsp;<span class="comment">#&nbsp;Unpack.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;env[f][<span class="literal">'Function'</span>][2][<span class="literal">'Variable'</span>][0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eBody&nbsp;=&nbsp;env[f][<span class="literal">'Function'</span>][3]&nbsp;<span class="comment">#&nbsp;Body.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vArg&nbsp;=&nbsp;evaluate(env,&nbsp;eArg)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;envF&nbsp;=&nbsp;env.copy()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;envF[x]&nbsp;=&nbsp;vArg<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vResult&nbsp;=&nbsp;evaluate(envF,&nbsp;eBody)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;vResult<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/><span class="keyword">def</span>&nbsp;execute(env,&nbsp;s):<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="builtin">type</span>(s)&nbsp;==&nbsp;Leaf:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;s&nbsp;==&nbsp;<span class="literal">'End'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;(env,&nbsp;[])<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">elif</span>&nbsp;type(s)&nbsp;==&nbsp;Node:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;label&nbsp;<span class="keyword">in</span>&nbsp;s:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Assign'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[var,&nbsp;e,&nbsp;p]&nbsp;=&nbsp;s[label]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;var[<span class="literal">'Variable'</span>][0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;env[x]&nbsp;=&nbsp;evaluate(env,&nbsp;e)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(env,&nbsp;o)&nbsp;=&nbsp;execute(env,&nbsp;p)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;(env,&nbsp;o)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Function'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[f,&nbsp;ty,&nbsp;x,&nbsp;e,&nbsp;p]&nbsp;=&nbsp;s[label]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;f[<span class="literal">'Variable'</span>][0]&nbsp;<span class="comment">#&nbsp;Unpack.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;env[f]&nbsp;=&nbsp;s<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(env,&nbsp;o)&nbsp;=&nbsp;execute(env,&nbsp;p)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;(env,&nbsp;o)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div> 
        
<span class="text">A type checking algorithm implementation is presented below.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">def</span>&nbsp;tyExpr(env,&nbsp;e):<br/>&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="builtin">type</span>(e)&nbsp;==&nbsp;Node:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;label&nbsp;<span class="keyword">in</span>&nbsp;e:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;children&nbsp;=&nbsp;e[label]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Number'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="literal">'TyInt'</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">elif</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Variable'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;children[0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;env[x]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">elif</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Apply'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[f,&nbsp;eArg]&nbsp;=&nbsp;children<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;f[<span class="literal">'Variable'</span>][0]&nbsp;<span class="comment">#&nbsp;Unpack.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tyArg&nbsp;=&nbsp;tyExpr(env,&nbsp;eArg)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tyFunArg&nbsp;=&nbsp;env[f][<span class="literal">'Arrow'</span>][0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tyArg&nbsp;==&nbsp;tyFunArg:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;env[f][<span class="literal">'Arrow'</span>][1]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/><span class="keyword">def</span>&nbsp;tyProg(env,&nbsp;s):<br/>&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="builtin">type</span>(s)&nbsp;==&nbsp;Leaf:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;s&nbsp;==&nbsp;<span class="literal">'End'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="literal">'Void'</span><br/>&nbsp;&nbsp;&nbsp;<span class="keyword">elif</span>&nbsp;type(s)&nbsp;==&nbsp;Node:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;label&nbsp;<span class="keyword">in</span>&nbsp;s:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Assign'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[x,e,p]&nbsp;=&nbsp;s[label]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;x[<span class="literal">'Variable'</span>][0]&nbsp;<span class="comment">#&nbsp;Unpack.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tExpr&nbsp;=&nbsp;tyExpr(env,&nbsp;e)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;env[x]&nbsp;=&nbsp;tExpr<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tProg&nbsp;=&nbsp;tyProg(env,&nbsp;p)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;tExpr&nbsp;==&nbsp;<span class="literal">'TyInt'</span>&nbsp;<span class="keyword">and</span>&nbsp;tProg&nbsp;==&nbsp;<span class="literal">'Void'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="literal">'Void'</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Function'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[f,&nbsp;tyArg,&nbsp;x,&nbsp;e,&nbsp;p]&nbsp;=&nbsp;s[label]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;=&nbsp;f[<span class="literal">'Variable'</span>][0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;x[<span class="literal">'Variable'</span>][0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;envF&nbsp;=&nbsp;env.copy()<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;envF[x]&nbsp;=&nbsp;<span class="literal">'TyInt'</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tBody&nbsp;=&nbsp;tyExpr(envF,&nbsp;e)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;env[name]&nbsp;=&nbsp;{<span class="literal">'Arrow'</span>:[tyArg,tBody]}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tProg&nbsp;=&nbsp;tyProg(env,&nbsp;p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;tProg<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
      </div></div></div>
<a name="f7d61e6c2fe211e38cf6ce3f5508acd9"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#f7d61e6c2fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">Suppose we are working with a programming language that supports the definition of functions that take a single string argument. The type system of this language supports explicit tracking of the sizes of strings.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">program <i>p</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>function</b> <i>f</i> <b>(</b> <b style="color:firebrick">string[</b><i>k</i><b style="color:firebrick">]</b> <i>x</i> <b>)</b> <b>{</b> <b>return</b> <i>e</i> <b>;</b> <b>}</b> <i>p</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>x</i> <b>:=</b> <i>e</i> <b>;</b> <i>p</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
expression <i>e</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>x</i> | <i>s</i> | <i>e</i> <b>+</b> <i>e</i> | <i>f</i> <b>(</b> <i>e</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
string <i>s</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid string</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
variable <i>f</i>, <i>x</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid variable</i></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
type &tau; <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b style="color:firebrick">string[</b><i>k</i><b style="color:firebrick">]</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b style="color:firebrick">string[</b><i>k</i><b style="color:firebrick">] <span style="font-size:12px;">&#8594;</span> string</b><b style="color:firebrick">[</b><i>k</i><b style="color:firebrick">]</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b style="color:firebrick">void</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
type size <i>k</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid integer</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>k</i> <b>+</b> <i>k</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
</td></tr></table></td></tr></table>
We can define a set of type inference rules for this language. These rules constitute the type system for the language.</span>
        <div class="inferences"><table class="inference"><tr><td class="title">[Statement-Assign]</td><td><table><tr><td class="premises">&nbsp;
            &Gamma; &#8846; {<i>x</i> &#x21A6; <b style="color:firebrick">string[</b><i>k</i><b style="color:firebrick">]</b>} &#8866; <i>p</i>: <b style="color:firebrick">void</b> 
            &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>e</i>: <b style="color:firebrick">string[</b><i>k</i><b style="color:firebrick">]</b>
            &nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>x</i> <b>:=</b> <i>e</i> <b>;</b> <i>p</i> : <b style="color:firebrick">void</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-Function]</td><td><table><tr><td class="premises">&nbsp;
            &Gamma; &#8846; {<i>f</i> &#x21A6; <b style="color:firebrick">string[</b><i>k</i><sub>1</sub><b style="color:firebrick">]</b> <b><span style="font-size:12px;">&#8594;</span></b> <b style="color:firebrick">string[</b><i>k</i><sub>2</sub><b style="color:firebrick">]</b>} &#8866; <i>p</i>: <b style="color:firebrick">void</b> 
            &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8846; {<i>x</i> &#x21A6; <b style="color:firebrick">string[</b><i>k</i><sub>1</sub><b style="color:firebrick">]</b>} &#8866; <i>e</i>: <b style="color:firebrick">string[</b><i>k</i><sub>2</sub><b style="color:firebrick">]</b>
            &nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b>function</b> <i>f</i> <b>(</b> <b style="color:firebrick">string[</b><i>k</i><sub>1</sub><b style="color:firebrick">]</b> <i>x</i> <b>)</b> <b>{</b> <b>return</b> <i>e</i> <b>;</b> <b>}</b> <i>p</i> : <b style="color:firebrick">void</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-End]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b style="color:gray;">end</b>: <b style="color:firebrick">void</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Term-Variable]</td><td><table><tr><td class="premises">&nbsp;&Gamma;(<i>x</i>) = <b style="color:firebrick">string[</b><i>k</i><b style="color:firebrick">]</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>x</i>: <b style="color:firebrick">string[</b><i>k</i><b style="color:firebrick">]</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Term-Number]</td><td><table><tr><td class="premises">&nbsp;|<i>s</i>| = <i>k</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>s</i>: <b style="color:firebrick">string[</b><i>k</i><b style="color:firebrick">]</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Term-Concat]</td><td><table><tr><td class="premises">&nbsp;
            &Gamma; &#8866; <i>e</i><sub>1</sub>: <b style="color:firebrick">string[</b><i>k</i><sub>1</sub><b style="color:firebrick">]</b> 
            &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>e</i><sub>2</sub>: <b style="color:firebrick">string[</b><i>k</i><sub>2</sub><b style="color:firebrick">]</b>
            &nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <i>e</i><sub>1</sub> <b>+</b> <i>e</i><sub>2</sub>: <b style="color:firebrick">string[</b><i>k</i><sub>1</sub><b>+</b><i>k</i><sub>2</sub><b style="color:firebrick">]</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Term-Apply]</td><td><table><tr><td class="premises">&nbsp;
            &Gamma;(<i>f</i>) = <b style="color:firebrick">string[</b><i>k</i><sub>1</sub><b style="color:firebrick">]</b> <b><span style="font-size:12px;">&#8594;</span></b> <b style="color:firebrick">string[</b><i>k</i><sub>2</sub><b style="color:firebrick">]</b> 
            &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>e</i>: <b style="color:firebrick">string[</b><i>k</i><sub>1</sub><b style="color:firebrick">]</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;
            &Gamma; &#8866; <i>f</i> <b style="color:firebrick">(</b> <i>e</i> <b style="color:firebrick">)</b>: <b style="color:firebrick">string[</b><i>k</i><sub>2</sub><b style="color:firebrick">]</b>
            &nbsp;</td></tr></table></td></tr></table></div>
      </div></div></div></div>
  <a name="6.2"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#6.2">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">6.2.</span> Abstract interpretation</h3>
<span class="text">An <i>abstract interpretation</i> algorithm is a specific kind of interpreter for a programming language: it must always terminate (and, typically, it must run quickly), and it typically provides information about the given program along some dimension of interest (i.e., not the value(s) it produces).</span>
<a name="f7d60ab22fe211e38cf6ce3f5508acd9"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#f7d60ab22fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">Suppose we are working with a simple general-purpose programming language with the following abstract syntax.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">program <i>p</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>print</b> <i>e</i> <b>;</b> <i>p</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>for</b> <i>x</i> <b>to</b> <i>n</i> <b>{</b> <i>p</i> <b>}</b> <i>p</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>procedure</b> <i>x</i> <b>{</b> <i>p</i> <b>}</b> <i>p</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>call</b> <i>x</i> <b>;</b> <i>p</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
               <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
expression <i>e</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>n</i> | <i>e</i> <b>*</b> <i>e</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
number <i>n</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid integer</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
variable <i>x</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid variable</i></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
</td></tr></table></td></tr></table>
We want to define an abstract interpretation over the above language to a language that describes running times of programs. The language for running times has the following syntax:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">running time <i>t</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b style="color:firebrick;"><i>n</i></b>  | <b style="color:firebrick;"><i>t</i> <b>+</b> <i>t</i></b> | <b style="color:firebrick;"><i>t</i> <b>*</b> <i>t</i></b> | <b style="color:firebrick;"><b>(</b> <i>t</i> <b>)</b> </b> 
</td></tr></table></td></tr></table>
We can define the following abstract interpretation of the language:</span>
        <div class="inferences"><table class="inference"><tr><td class="title">[Expression-Number]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&#8866; <i>n</i> : <b style="color:firebrick;">1</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Expression-Mult]</td><td><table><tr><td class="premises">&nbsp;&#8866; <i>e</i><sub>1</sub>: <b style="color:firebrick;"><i>t</i><sub>1</sub></b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &#8866; <i>e</i><sub>1</sub>: <b style="color:firebrick;"><i>t</i><sub>2</sub></b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&#8866; <i>e</i><sub>1</sub> <b>*</b> <i>e</i><sub>2</sub>: <b style="color:firebrick;"><i>t</i><sub>1</sub> + <i>t</i><sub>2</sub></b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-Print]</td><td><table><tr><td class="premises">&nbsp;&Gamma; &#8866; <i>p</i>: <b style="color:firebrick;"><i>t</i><sub>1</sub></b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &#8866; <i>e</i>: <b style="color:firebrick;"><i>t</i><sub>2</sub></b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b>print</b> <i>e</i> <b>;</b> <i>p</i> : <b style="color:firebrick;"><i>t</i><sub>1</sub> + <i>t</i><sub>2</sub></b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-For]</td><td><table><tr><td class="premises">&nbsp;&Gamma; &#8866; <i>p</i><sub>1</sub>: <b style="color:firebrick;"><i>t</i><sub>1</sub></b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>p</i><sub>2</sub>: <b style="color:firebrick;"><i>t</i><sub>2</sub></b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b>for</b> <i>x</i> <b>to</b> <i>n</i> <b>{</b> <i>p</i><sub>1</sub> <b>}</b> <i>p</i><sub>2</sub> : <b style="color:firebrick;">(<i>n</i> * <i>t</i><sub>1</sub>) + <i>t</i><sub>2</sub></b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-Procedure]</td><td><table><tr><td class="premises">&nbsp;&Gamma; &#8866; <i>p</i><sub>1</sub>: <b style="color:firebrick;"><i>t</i><sub>1</sub></b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8846; {<i>x</i> &#x21A6; <b style="color:firebrick;"><i>t</i><sub>1</sub></b>} &#8866; <i>p</i><sub>2</sub>: <b style="color:firebrick;"><i>t</i><sub>2</sub></b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b>procedure</b> <b>{</b> <i>p</i><sub>1</sub> <b>}</b> <i>p</i><sub>2</sub> : <b style="color:firebrick;"><i>t</i><sub>2</sub></b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-Call]</td><td><table><tr><td class="premises">&nbsp;&Gamma;(<i>x</i>) = <b style="color:firebrick;"><i>t</i><sub>2</sub></b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>p</i>: <b style="color:firebrick;"><i>t</i><sub>1</sub></b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b>call</b> <i>x</i> <b>;</b> <i>p</i> : <b style="color:firebrick;"><i>t</i><sub>1</sub> + <i>t</i><sub>2</sub></b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-End]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b style="color:gray;">end</b> : <b style="color:firebrick;">0</b>&nbsp;</td></tr></table></td></tr></table></div>
        
<span class="text">We can implement the above inference rules as an abstract interpretation algorithm.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">def</span>&nbsp;timeExpr(e):<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;type(e)&nbsp;==&nbsp;Node:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;label&nbsp;<span class="keyword">in</span>&nbsp;e:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;children&nbsp;=&nbsp;e[label]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Number'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;1<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">elif</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Mult'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[e1,e2]&nbsp;=&nbsp;children<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;timeExpr(e1)&nbsp;+&nbsp;timeExpr(e2)<br/><br/><span class="keyword">def</span>&nbsp;timeProg(env,&nbsp;s):<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="builtin">type</span>(s)&nbsp;==&nbsp;Leaf:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;s&nbsp;==&nbsp;<span class="literal">'End'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;0<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">elif</span>&nbsp;type(s)&nbsp;==&nbsp;Node:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;label&nbsp;<span class="keyword">in</span>&nbsp;s:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Print'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[e,p]&nbsp;=&nbsp;s[label]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;timeExpr(e)&nbsp;+&nbsp;timeProg(env,&nbsp;p)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'For'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[var,&nbsp;num,&nbsp;p1,&nbsp;p2]&nbsp;=&nbsp;s[label]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;num[<span class="literal">'Number'</span>][0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;n&nbsp;*&nbsp;timeProg(env,&nbsp;p1)&nbsp;+&nbsp;timeProg(env,&nbsp;p2)<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;...</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
      </div></div></div>
<a name="f7d60d822fe211e38cf6ce3f5508acd9"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#f7d60d822fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">Suppose we are working with a simple programming language for reserving cloud computing resources with the following abstract syntax.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">program <i>p</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>reserve</b> <i>d</i> <b>;</b> <i>p</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
           <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>for</b> <i>x</i> <b>to</b> <i>n</i> <b>{</b> <i>p</i> <b>}</b> <i>p</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
           <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>procedure</b> <i>x</i> <b>{</b> <i>p</i> <b>}</b> <i>p</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
           <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>call</b> <i>x</i> <b>;</b> <i>p</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
           <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
duration <i>d</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>n</i> <b>minutes</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
            <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>n</i> <b>hours</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
            <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>n</i> <b>days</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
number <i>n</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid integer</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
fixed-point real number <i>r</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid real number</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
variable <i>x</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid variable</i></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
</td></tr></table></td></tr></table>
We want to define an abstract interpretation over the above language to a language that describes the monetary (i.e., dollar) cost of running a program. The language for costs has the following syntax:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">cost <i>c</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b style="color:firebrick;">$<i>r</i></b> | <b style="color:firebrick;"><i>c</i> <b>+</b> <i>c</i></b> | <b style="color:firebrick;"><i>n</i> <b>*</b> <i>c</i></b> | <b style="color:firebrick;"><b>(</b> <i>c</i> <b>)</b> </b> 
</td></tr></table></td></tr></table>
Suppose that a single <b>reserve</b> <i>d</i> <b>;</b> statement reserves a distinct computing resources for the duration specified, and that the cost of any resource is always $0.60 per hour. We can define the following abstract interpretation of the language:</span>
        <div class="inferences"><table class="inference"><tr><td class="title">[Duration-Minutes]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&#8866; <i>n</i> <b>minutes</b> : <b style="color:firebrick;"><i>n</i> &sdot; $0.01</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Duration-Hours]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&#8866; <i>n</i> <b>hours</b> : <b style="color:firebrick;"><i>n</i> &sdot; $0.60</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Duration-Days]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&#8866; <i>n</i> <b>days</b> : <b style="color:firebrick;"><i>n</i> &sdot; $14.40</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-Reserve]</td><td><table><tr><td class="premises">&nbsp;&#8866; <i>d</i>: <b style="color:firebrick;"><i>c</i><sub>1</sub></b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>p</i>: <b style="color:firebrick;"><i>c</i><sub>2</sub></b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b>reserve</b> <i>d</i> <b>;</b> <i>p</i> : <b style="color:firebrick;"><i>c</i><sub>1</sub> + <i>c</i><sub>2</sub></b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-For]</td><td><table><tr><td class="premises">&nbsp;&Gamma; &#8866; <i>p</i><sub>1</sub>: <b style="color:firebrick;"><i>c</i><sub>1</sub></b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>p</i><sub>2</sub>: <b style="color:firebrick;"><i>c</i><sub>2</sub></b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b>for</b> <i>x</i> <b>to</b> <i>n</i> <b>{</b> <i>p</i><sub>1</sub> <b>}</b> <i>p</i><sub>2</sub> : <b style="color:firebrick;">(<i>n</i> * <i>c</i><sub>1</sub>) + <i>c</i><sub>2</sub></b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-Procedure]</td><td><table><tr><td class="premises">&nbsp;&Gamma; &#8866; <i>p</i><sub>1</sub>: <b style="color:firebrick;"><i>c</i><sub>1</sub></b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8846; {<i>x</i> &#x21A6; <b style="color:firebrick;"><i>c</i><sub>1</sub></b>} &#8866; <i>p</i><sub>2</sub>: <b style="color:firebrick;"><i>c</i><sub>2</sub></b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b>procedure</b> <b>{</b> <i>p</i><sub>1</sub> <b>}</b> <i>p</i><sub>2</sub> : <b style="color:firebrick;"><i>c</i><sub>2</sub></b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-Call]</td><td><table><tr><td class="premises">&nbsp;&Gamma;(<i>x</i>) = <b style="color:firebrick;"><i>c</i><sub>2</sub></b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Gamma; &#8866; <i>p</i>: <b style="color:firebrick;"><i>c</i><sub>1</sub></b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b>call</b> <i>x</i> <b>;</b> <i>p</i> : <b style="color:firebrick;"><i>c</i><sub>1</sub> + <i>c</i><sub>2</sub></b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-End]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Gamma; &#8866; <b style="color:gray;">end</b> : <b style="color:firebrick;">$0</b>&nbsp;</td></tr></table></td></tr></table></div>  
        
<span class="text">We can implement the above inference rules as an abstract interpretation algorithm.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">def</span>&nbsp;costDuration(e):<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="builtin">type</span>(e)&nbsp;==&nbsp;Node:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;label&nbsp;<span class="keyword">in</span>&nbsp;e:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;children&nbsp;=&nbsp;e[label]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Minutes'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[num]&nbsp;=&nbsp;children<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;num[<span class="literal">'Number'</span>][0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;n&nbsp;*&nbsp;0.01<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Hours'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[num]&nbsp;=&nbsp;children<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;num[<span class="literal">'Number'</span>][0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;n&nbsp;*&nbsp;0.60<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Days'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[num]&nbsp;=&nbsp;children<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;num[<span class="literal">'Number'</span>][0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;n&nbsp;*&nbsp;14.40<br/><br/><span class="keyword">def</span>&nbsp;costProg(env,&nbsp;s):<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;<span class="builtin">type</span>(s)&nbsp;==&nbsp;Leaf:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;s&nbsp;==&nbsp;<span class="literal">'End'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;0<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">elif</span>&nbsp;<span class="builtin">type</span>(s)&nbsp;==&nbsp;Node:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;label&nbsp;in&nbsp;s:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'Reserve'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[d,p]&nbsp;=&nbsp;s[label]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;costDuration(d)&nbsp;+&nbsp;costProg(env,&nbsp;p)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;label&nbsp;==&nbsp;<span class="literal">'For'</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[var,&nbsp;num,&nbsp;p1,&nbsp;p2]&nbsp;=&nbsp;s[label]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;num[<span class="literal">'Number'</span>][0]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;n&nbsp;*&nbsp;costProg(env,&nbsp;p1)&nbsp;+&nbsp;costProg(env,&nbsp;p2)<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;...</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
      </div></div></div></div>
</div>
<a name="7"></a>
<div class="section"><hr style="margin-bottom:120px;"/><h2 class="linked"><span class="link-title">[<a href="#7">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.</span> Declarative (and Functional) Programming Language Paradigms</h2>
<span class="text">In this section we introduce the notion of a programming language paradigm, define several major programming language paradigms, and discuss which paradigms are supported by some widely used modern programming languages (in practice, many languages support more than one paradigm). We assume the reader is already at least somewhat familiar with the imperative and object-oriented programming paradigms; thus, we study in detail the <i>declarative</i> programming paradigm (including an important subset, <i>functional</i> programming).</span>
  <a name="7.1"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#7.1">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.1.</span> Programming language paradigms</h3>
<span class="text">A programming language's <i>programming paradigm</i> is the collection of abstractions, tools, and techniques it makes available to a programmer. While <a href="http://en.wikipedia.org/wiki/Programming_paradigm">there is some disagreement</a> about what exactly constitutes a programming paradigm and how programming paradigms can be distinguished and categorized, there is wide agreement that at least a few distinct, widely-employed programming paradigms exist. We can enumerate these paradigms, and we can list the programming language features (i.e., abstractions) that can be used to identify and distinguish between them:</span><ul><li><b>imperative programming:</b><ul><li>mutable state and side effects:<ul><li>indexed memory regions;</li><li>named, mutable variables;</li><li>ability to interact with other "external" devices (video card, network, etc.);</li></ul></li><li>sequential execution of statements:<ul><li>one operation per time step (control flow);</li><li>branching and loops (direction of control flow);</li></ul></li><li><b><i>procedural programming:</i></b><ul><li>definition and invocation of named procedures;</li></ul></li><li>parallelism achieved with forking, threads, and message passing;</li></ul></li><li><b>object-oriented programming:</b><ul><li>data and methods organized into objects;</li><li>multiple instances of objects interacting via method calls:<ul><li>event handling;</li></ul></li><li>enforcement of encapsulation and modularity;</li></ul></li><li><b>declarative programming:</b><ul><li>static, immutable descriptions of data, models, or problems:<ul><li>user-defined data types:<ul><li>algebraic data types;</li></ul></li><li>type checking/inference.</li></ul></li><li>query sublanguage for examining/exploring static descriptions;</li><li><b><i>functional programming:</i></b><ul><li>referential transparency;</li><li>support for pattern matching/unification;</li><li>functions as values (<i><a href="http://en.wikipedia.org/wiki/First-class_function">first-class functions</a></i> and <i><a href="http://en.wikipedia.org/wiki/Higher-order_functions">higher-order functions</a></i>).</li></ul></li></ul></li></ul>
<span class="text">Mathematically, it is possible to identify which paradigms are supported by a programming language by examining its operational semantics. We have already seen many examples of an operational semantics for an imperative language (such as <a href="#cbfa02d3624d42b08704d6a4c4fb9e03">this one</a> and <a href="#c09ab939e50b40428d392867c00b4710">this one</a>).
<br/><br/>
As a result of both historical trends and of practical necessity, most widely-used programming languages support multiple programming paradigms:
<br/><br/>
<table class="fig_table" style="font-size:10px; font-family:Arial,sans-serif;">
 <tr>
  <td></td>
  <td><b>imperative</b></td>
  <td><b>procedural</b></td>
  <td><b>object-<br/>oriented</b></td>
  <td><b>declarative</b></td>
  <td><b>functional</b></td>
  <td style="padding:0px;"></td>
  <td><b>static type<br/>checking</b></td>
  <td><b>garbage<br/>collection</b></td>
  <td><b>side<br/>effects</b></td>
 </tr>
 <tr> 
  <td><b>machine<br/>languages</b></td>
  <td style="background-color:lightyellow;">some support<br/>(indexed<br/>memory,<br/>branching)</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="padding:0px;"></td>
  <td>none</td>
  <td>no</td>
  <td>yes</td>
 </tr>
 <tr> 
  <td><b>FORTRAN<br/>(initial<br/>release)</b></td>
  <td style="background-color:palegreen; border:3px dashed green;">full support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="padding:0px;"></td>
  <td>very<br/>limited</td>
  <td>no</td>
  <td>yes</td>
 </tr>
 <tr> 
  <td><b>C</b></td>
  <td style="background-color:palegreen; border:3px dashed green;">full support</td>
  <td style="background-color:palegreen; border:3px dashed green;">full support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:lightyellow;">some support<br/>(function pointers)</td>
  <td style="padding:0px;"></td>
  <td>very<br/>limited</td>
  <td>no</td>
  <td>yes</td>
 </tr>
 <tr> 
  <td><b>C++</b></td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen; border:3px dashed green;">full support</td>
  <td style="background-color:lightyellow;">class declarations,<br/>some type checking</td>
  <td style="background-color:lightyellow;">function pointers<br/>and some extensions<br/>(e.g., <a href="http://en.wikipedia.org/wiki/Standard_Template_Library">STL</a>)</td>
  <td style="padding:0px;"></td>
  <td>limited</td>
  <td>no</td>
  <td>yes</td>
 </tr>
 <tr> 
  <td><b>Java</b></td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen; border:3px dashed green;">full support</td>
  <td style="background-color:lightyellow;">type system,<br/>class declarations,<br/>abstract classes,<br/>interfaces,<br/>type checking,<br/>and type inference</td>
  <td style="background-color:lightyellow;">generics, interfaces,<br/>objects as wrappers,<br/> anonymous classes</td>
  <td style="padding:0px;"></td>
  <td style="border:3px dashed green;">extensive</td>
  <td style="border:3px dashed green;">yes</td>
  <td>yes</td>
 </tr>
 <tr> 
  <td><b>PHP</b></td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:lightyellow;">some support</td>
  <td style="padding:0px;"></td>
  <td>none</td>
  <td>yes<br/>(&ge; 5.3)</td>
  <td>yes</td>
 </tr>
 <tr> 
  <td><b>Python</b></td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="padding:0px;"></td>
  <td>none</td>
  <td>yes</td>
  <td>yes</td>
 </tr>
 <tr> 
  <td><b>JavaScript</b></td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="padding:0px;"></td>
  <td>none</td>
  <td>yes</td>
  <td>yes</td>
 </tr>
 <tr> 
  <td><b>Haskell</b></td>
  <td style="background-color:lightcyan;">meta-support<br/>(monads)</td>
  <td style="background-color:lightcyan;">meta-support<br/>(functions)</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen; border:3px dashed green;">full support</td>
  <td style="padding:0px;"></td>
  <td style="border:3px dashed green;">extensive</td>
  <td>yes</td>
  <td>some<br/>(IO<br/>monads)</td>
 </tr>
 <tr> 
  <td><b>SQL</b></td>
  <td style="background-color:lightyellow;">some support<br/>(insertion/<br/>deletion;<br/>sequences of<br/>statements in<br/>versions<br/>like MS-SQL)</td>
  <td style="background-color:lightyellow;">some support<br/>(procedures in<br/>versions<br/>like MS-SQL)</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:palegreen; border:3px dashed green;">full support<br/>(definition of<br/>schemas and<br/>tables; ability<br/>to evaluate<br/>queries over<br/>tables)</td>
  <td style="background-color:lightyellow;">some support<br/>(custom map and<br/>aggregation<br/>procedures in<br/>MS-SQL)</td>
  <td style="padding:0px;"></td>
  <td>some</td>
  <td>yes</td>
  <td>some</td>
 </tr>
 <tr> 
  <td><b>Amazon<br/>Web<br/>Services<br/>APIs</b></td>
  <td style="background-color:lightyellow;">some support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:lightyellow;">some support</td>
  <td style="background-color:lightyellow;">some support</td>
  <td style="padding:0px;"></td>
  <td>none</td>
  <td>n/a</td>
  <td>yes</td>
 </tr>
</table>
<br/>
While most languagues support many paradigms in practice, there is often a historically predominant paradigm that distinguished that programming language at the time it was introduced, that is supported natively by the programming language (i.e., without special extensions, libraries, or idioms), and that is employed by the communities of programmers who use that language. In the above, the paradigm most closely identified with each language is indicated with a dark green outline.
<br/><br/>
A note about the above chart: when it comes to <i>domain-specific</i> languages that have a very narrow purpose (such as the Amazon Web Services API) and are not meant to be general-purpose programming languages, support of a paradigm does not imply that the language supports that paradigm in general; instead, it means the language supports that paradigm insofar as it applies to that particular application domain.</span></div>
  <a name="7.2"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#7.2">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.2.</span> Substitution and unification</h3>
<span class="text">In this course, we will focus on the declarative (and functional) programming language Haskell. The Haskell syntax and operational semantics natively support <i>unification</i> in multiple ways (specifically, <i>pattern matching</i> within expressions and <i>polymorphism</i> within the type system). Unification is a general concept that is applied in some form in all areas of mathematics and computer science. In this subsection, we will define unification.</span>
<a name="f7d600442fe211e38cf6ce3f5508acd9"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#f7d600442fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="definition_required"><b>Definition:</b> 
Given a set of variables <i>X</i> and an abstract syntax <i>A</i> (i.e., a set of abstract syntax trees), a <i>substitution</i> &sigma; is a mapping from variables names in <i>X</i> to abstract syntax trees in <i>A</i>. Given an abstract syntax tree <i>a</i> <span style="font-size:12px;">&#8712;</span> <i>A</i>, we denote the result of substituting all the variables in <i>a</i> according to &sigma; using the notation &sigma;(<i>a</i>).
      </div></div></div>
<span class="text">You'll notice that we use the same mathematical object to represent both <a href="#e1a5053a93d54ad4b02da10e4981b810">environments</a> (a.k.a., contexts) and substitutions. Thus, we will use the same notation for representing manipulations involving substitutions.
<ul>
  <li>In this course, we will usually denote a substitution using the symbol &sigma;.</li>
  <li>Given a variable name <i>x</i> <span style="font-size:12px;">&#8712;</span> <i>X</i>, we denote by &sigma;(<i>x</i>) the abstract syntax tree that the environment &sigma; assigns to <i>x</i>.</li>
  <li>An empty substitution (one that does not map any variable names to any abstract syntax trees) is denoted using &sigma;<sub>0</sub>.</li>
  <li>We use the notation dom(&sigma;) to represent the set of variables that &sigma; maps to abstract syntax trees.</li>
  <li>Given two substitutions &sigma;<sub>1</sub> and &sigma;<sub>2</sub> such that dom(&sigma;<sub>1</sub>) &cap; dom(&sigma;<sub>2</sub>) = &empty; (i.e., the two substitutions do not overlap or conflict on any variables), we denote by &sigma;<sub>1</sub> &#8846; &sigma;<sub>2</sub> the substitution that can be obtained by combining the two individual substitutions. Thus, dom(&sigma;<sub>1</sub> &#8846; &sigma;<sub>2</sub>) = dom(&sigma;<sub>1</sub>) &cup; dom(&sigma;<sub>2</sub>).</li>
</ul></span>
<a name="f7d622362fe211e38cf6ce3f5508acd9"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#f7d622362fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
Suppose we have the following abstract syntax (here, <b>node</b> is an infix operator for building tree nodes):
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">tree <i>t</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>leaf</b> | <i>x</i> | <i>t</i> <b>node</b> <i>t</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
variable <i>x</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid variable</i>
</td></tr></table></td></tr></table>
Suppose we are given the following substitution, which maps the variable <i>u</i> to the tree <b>leaf</b> and the variable <i>u</i> to the tree <b>leaf</b> <b>node</b> <b>leaf</b>:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">&sigma; <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { <i>u</i> &#x21A6; <b>leaf</b>, <i>v</i> &#x21A6; <b>leaf</b> <b>node</b> <b>leaf</b> }
</td></tr></table></td></tr></table>
Applying the above substitution to a tree that does not contain any variable nodes <i>u</i> or <i>v</i> has no effect:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">&sigma;(<b>leaf</b>) <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>leaf</b>
</td></tr></table></td></tr></table>
Applying the substitution to a tree containing the variables <i>u</i> and/or <i>v</i> would result in those variables being replaced by the corresponding tree inside &sigma; (we add parentheses to the result for legibility):
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">&sigma;(<i>u</i> <b>node</b> <i>v</i>) <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> (<b>leaf</b>) <b>node</b> (<b>leaf</b> <b>node</b> <b>leaf</b>)
</td></tr></table></td></tr></table>
      </div></div></div>
<a name="f7d624202fe211e38cf6ce3f5508acd9"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#f7d624202fe211e38cf6ce3f5508acd9">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="definition_required"><b>Definition:</b> 
Given an abstract syntax <i>A</i> and two abstract syntax trees <i>a</i>, <i>b</i> <span style="font-size:12px;">&#8712;</span> <i>A</i>, we say that a substitution &sigma; <i>unifies</i> <i>a</i> and <i>b</i> if the following equation holds:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">  &sigma;(<i>a</i>) <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> &sigma;(<i>b</i>)
</td></tr></table></td></tr></table>
That is, applying the substitution to both trees produces exactly the same tree. The process of calculating the <i>smallest</i> &sigma; that guarantees the above equality is called <i>unification</i>.
      </div></div></div>
<span class="text">For those familiar with the concept of a <a href="http://en.wikipedia.org/wiki/Magma_(algebra)">magma</a>, unification corresponds to the process of solving equations on magmas (or, more generally, any algebraic structure without any reduction or cancellation laws).</span>
<a name="8dac853e5f3f4f7f88f351fe4e6673aa"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#8dac853e5f3f4f7f88f351fe4e6673aa">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="fact_required"><b>Fact:</b> 
Suppose we are given an abstract syntax <i>A</i> and two abstract syntax trees <i>a</i>, <i>b</i> <span style="font-size:12px;">&#8712;</span> <i>A</i> that contain no variables. If <i>a</i> = <i>b</i>, then it is true that for all &sigma; (including &sigma;<sub>0</sub>):
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">  &sigma;(<i>a</i>) <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> &sigma;(<i>b</i>)
</td></tr></table></td></tr></table>
If <i>a</i> &ne; <i>b</i>, then it is true that for all &sigma;:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">  &sigma;(<i>a</i>) <td></tr></table></td><td style="text-align:center;"> &ne; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> &sigma;(<i>b</i>)
</td></tr></table></td></tr></table>
      </div></div></div>
<a name="3178040e0e304dea97da80368c7741b5"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#3178040e0e304dea97da80368c7741b5">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
Suppose we have the following abstract syntax:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><i>m</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>object</b> | <i>x</i> | <i>m</i> <b>&oplus;</b> <i>m</i> | <i>m</i> <b>&otimes;</b> <i>m</i> | <b>(</b> <i>m</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
variable <i>x</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid variable</i>
</td></tr></table></td></tr></table>
Unify the following two abstract syntax trees, if possible (i.e., solve the following equation):
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">  <b>(</b><i>z</i><b> &otimes; object) &oplus;</b> <i>x</i> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>(object &otimes; </b><i>y</i><b>) &oplus; (object &otimes; object)</b>
</td></tr></table></td></tr></table>
We can proceed by breaking the problem down. Since the root nodes of both abstract syntax trees are &oplus;, we can turn the above into two equations:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">  <i>z</i><b> &otimes; object</b> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>object &otimes; </b><i>y</i>  </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
  <i>x</i> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>object &otimes; object</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
</td></tr></table></td></tr></table>
The first equation can be broken down further:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">  <i>z</i><td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>object</b>  </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
  <b>object</b> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>y</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
  <i>x</i> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>object &otimes; object</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
</td></tr></table></td></tr></table>
At this point, we can build up the substitution using the above information:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">   &sigma; <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> { <i>x</i> &#x21A6; <b>object &otimes; object</b>, <i>y</i> &#x21A6; <b>object</b>, <i>z</i> &#x21A6; <b>object</b> } </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
</td></tr></table></td></tr></table>
Thus, &sigma; as defined above unifies the two sides of the equation; the equation has a solution.
      </div></div></div>
<span class="text">The equality algorithm on abstract syntax trees is a degenerate version of a unification algorithm in which substitutions must always remain empty. This algorithm is implemented natively within Python (we have been using it every time we checked whether two trees represented as nested dictionaries are equivalent using the <code>==</code> operator), and Haskell supports the automatic derivation of this algorithm for any data type (using the <code>deriving Eq</code> directive).</span>
<a name="788d70ecb3ab4acaa98a9355657fca3d"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#788d70ecb3ab4acaa98a9355657fca3d">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="algorithm_required"><b>Algorithm (equality):</b> 
        
<span class="text">The following algorithm can determine whether two trees are equivalent. 
<ol style="list-style-type:none;">
 <li><b>equal(<b><i>a</i></b>, <b><i>b</i></b>):</b> two abstract syntax trees <i>a</i> and <i>b</i></li>
 <li>
   <ol style="list-style-type:none; margin-left:-20px;">
     <li><b>if</b> both <i>a</i> <b>and</b> <i>b</i> are leaf nodes and are equivalent
       <ol style="list-style-type:none; margin-left:-20px;">
         <li><b>return</b> <b>true</b></li>
       </ol>
     </li>
     <li><b>if</b> both <i>a</i> and <i>b</i> have the same label <b>and</b> the same number of children
       <ol style="list-style-type:none; margin-left:-20px;">
         <li>in order from left to right, check each pair of corresponding children of <i>a</i> and <i>b</i> for equality</li>
         <li><b>return</b> <b>true</b> if all the subtrees are equivalent</li>
         <li><b>return</b> <b>false</b> otherwise</li>
       </ol>
     </li>
   </ol>
 </li>
</ol></span>
      </div></div></div>
<a name="95e800c8e74e4991a2ddb48668b544e0"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#95e800c8e74e4991a2ddb48668b544e0">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="algorithm_required"><b>Algorithm (pattern matching unification):</b> 
        
<span class="text">Whether unification can be computed efficiently, or at all, depends on the subset of the abstract syntax from which inputs are drawn (i.e., it depends on what restrictions are placed on the abstract syntax trees that may need to be unified). The following algorithm, which we will call <i>pattern matching</i> unification, is guaranteed to terminate quickly (i.e., polynomial time) as long as at least one side of the equation contains no variables. It is guaranteed to quickly find a solution if it exists, as long as all variables occur exactly once.
<ol style="list-style-type:none;">
 <li><b>unify(<b><i>a</i></b>, <b><i>b</i></b>):</b> two abstract syntax trees <i>a</i> and <i>b</i></li>
 <li>
   <ol style="list-style-type:none; margin-left:-20px;">
     <li><b>if</b> both <i>a</i> <b>and</b> <i>b</i> are leaf nodes and are equivalent
       <ol style="list-style-type:none; margin-left:-20px;">
         <li><b>return</b> the empty substitution &sigma;<sub>0</sub></li>
       </ol>
     </li>
     <li><b>if</b> <i>a</i> is a variable node representing a variable <i>x</i>
       <ol style="list-style-type:none; margin-left:-20px;">
         <li><b>return</b> the substitution {<i>x</i> &#x21A6; <i>b</i>}</li>
       </ol>
     </li>
     <li><b>if</b> <i>b</i> is a variable node representing a variable <i>x</i>
       <ol style="list-style-type:none; margin-left:-20px;">
         <li><b>return</b> the substitution {<i>x</i> &#x21A6; <i>a</i>}</li>
       </ol>
     </li>
     <li><b>if</b> both <i>a</i> and <i>b</i> have the same label <b>and</b> the same number of children
       <ol style="list-style-type:none; margin-left:-20px;">
         <li>in order from left to right, unify each pair of corresponding children of <i>a</i> and <i>b</i></li>
         <li>as long as they do not overlap on any variables, combine the substitutions obtained above</li>
         <li><b>return</b> the combined substitution</li>
       </ol>
     </li>
   </ol>
 </li>
</ol></span>
      </div></div></div>
<a name="8b5c8d33b508470088319ea3bb8db343"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#8b5c8d33b508470088319ea3bb8db343">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">The Python operational semantics (and interpreter) employ a pattern matching unification algorithm in some cases. For example, it is possible to assign to arbitrarily deep tree of nested tuples.</span>
        
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;(a,(b,c),(d,(e,f),g))&nbsp;=&nbsp;(1,(2,3),(4,(5,6),7))<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;(a,b,c,d,e,f,g)<br/>(1,2,3,4,5,6,7)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
      </div></div></div></div>
  <a name="7.3"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#7.3">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.3.</span> Declarative programming languages</h3>
<span class="text">Any programming language that allows users to provide a static, immutable description of data, a model, or a problem supports the declarative programming paradigm to at least some degree. For example, languages that allow users to specify types and relationships between those types (e.g., Haskell types, Java classes, and so on) support a declarative programming paradigm for types.
<br/><br/>
In this course we will focus on declarative languages that allow users to specify data types, relationships between data types, and pure mathematical functions over those data types. In particular, we will look at the Haskell programming language.
<br/><br/>
In order to define the operational semantics for a declarative language, we must slightly modify the way in which we define an operational semantics by extending the premises and conclusions with an additional parameter representing the data, model, or problem description. We will adopt the convention of calling this parameter <i>M</i>. Thus, an intepreter for a declarative programming language first <i>builds</i> data, a model, or a problem description by parsing and collecting into a single structure all the declarations in a program. It then allows the user to <i>query</i> that structure.
<br/><br/>
In the Haskell programming language, a <i>module</i> is a collection of declarations (that can occur in any order) of variables, functions, and types. For example:</span>
<div class="code"><div class="source"><br/><span class="keyword">module</span>&nbsp;Example&nbsp;<span class="keyword">where</span><br/><br/>c&nbsp;=&nbsp;5;<br/><br/>g&nbsp;(0)&nbsp;=&nbsp;0;<br/>g&nbsp;(x)&nbsp;=&nbsp;f(x)&nbsp;+&nbsp;f(x);<br/><br/>f&nbsp;(x)&nbsp;=&nbsp;2&nbsp;*&nbsp;x&nbsp;+&nbsp;1;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">A Haskell interpreter first assembles the module without performing any evaluation, and then allows users to make queries about that module. Queries take the form of expressions, and the response to a query is the evaluation of that expression with respect to the entire module (i.e., all the definitions in the module).</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;c&nbsp;+&nbsp;c<br/>10<br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;f(4)<br/>9<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">Haskell natively supports lists and tuples, and the evaluation algorithm employs the <a href="95e800c8e74e4991a2ddb48668b544e0">pattern matching unification</a> algorithm. Suppose we have the following module:</span>
<div class="code"><div class="source"><br/><span class="keyword">module</span>&nbsp;AnotherExample&nbsp;<span class="keyword">where</span><br/><br/>f&nbsp;(-1)&nbsp;=&nbsp;1;<br/>f&nbsp;(0)&nbsp;=&nbsp;0;<br/>f&nbsp;(1)&nbsp;=&nbsp;-1;<br/><br/>(a,(b,(c,d),e))&nbsp;=&nbsp;(1,(2,(3,4),5));<br/><br/>g([x,y,z])&nbsp;=&nbsp;[z,y,x];<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">We can query the above module as follows:</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;f(-1)<br/>1<br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;d<br/>4<br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;g([1,2,3])<br/>[3,2,1]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></div>
  <a name="7.4"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#7.4">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.4.</span> Algebraic data types</h3>
<span class="text">Some declarative languages natively support abstract mathematical, logical, and algebraic structures such as BNF notation, abstract syntaxes, logical formulas and predicates, and inference rules. Haskell natively supports user-defined <i>algebraic data types</i>. An algebraic data type is effectively a user-defined abstract syntax; the Haskell syntax for defining algebraic data types corresponds closely to BNF notation. In the module below, we define an algebraic data type for representing binary trees.</span>
<div class="code"><div class="source"><br/><span class="keyword">module</span>&nbsp;Tree&nbsp;<span class="keyword">where</span><br/><br/><span class="keyword">data</span>&nbsp;Tree&nbsp;=&nbsp;Leaf&nbsp;|&nbsp;Node&nbsp;Tree&nbsp;Tree;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">Most Haskell interpreters and compilers support infix notation in data type definitions as well.</span>
<div class="code"><div class="source"><br/><span class="keyword">data</span>&nbsp;Tree&nbsp;=&nbsp;Leaf&nbsp;|&nbsp;Tree&nbsp;`Node`&nbsp;Tree;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">Once the above module is parsed and built, the user is allowed to construct instances of the <code>Tree</code> algebraic data type. However, in order to actually display instances of the data type, it is necessary to ask the Haskell interpreter to derive a definition of a <code>show</code> function automatically from the definition of the algebraic data type (something that is done implicitly in, for example, Python). Haskell requires that this be requested explicitly because it also allows users to define their own variants of such functions.</span>
<div class="code"><div class="source"><br/><span class="keyword">module</span>&nbsp;Tree&nbsp;<span class="keyword">where</span><br/><br/><span class="keyword">data</span>&nbsp;Tree&nbsp;=&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;Leaf&nbsp;<br/>&nbsp;&nbsp;|&nbsp;Node&nbsp;Tree&nbsp;Tree&nbsp;<br/>&nbsp;&nbsp;<span class="keyword">deriving</span>&nbsp;Show;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">We can now try building trees using this algebraic data type.</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;Leaf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">--&nbsp;We&nbsp;represented&nbsp;this&nbsp;using&nbsp;"Leaf"&nbsp;in&nbsp;Python.</span><br/>Leaf<br/><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;Node&nbsp;Leaf&nbsp;Leaf&nbsp;<span class="comment">--&nbsp;We&nbsp;represented&nbsp;this&nbsp;using&nbsp;{"Node":["Leaf",&nbsp;"Leaf"]}&nbsp;in&nbsp;Python.</span><br/>Node&nbsp;Leaf&nbsp;Leaf<br/><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;Leaf&nbsp;`Node`&nbsp;Leaf<br/>Node&nbsp;Leaf&nbsp;Leaf<br/><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;Leaf&nbsp;`Node`&nbsp;((Leaf&nbsp;`Node`&nbsp;Leaf)&nbsp;`Node`&nbsp;(Leaf&nbsp;`Node`&nbsp;Leaf))<br/>Node&nbsp;Leaf&nbsp;(Node&nbsp;(Node&nbsp;Leaf&nbsp;Leaf)&nbsp;(Node&nbsp;Leaf&nbsp;Leaf))<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">Haskell's native support for pattern matching unification makes it possible to write concise definitions for functions that are defined over trees.</span>
<div class="code"><div class="source"><br/><span class="comment">--&nbsp;Count&nbsp;the&nbsp;number&nbsp;of&nbsp;nodes&nbsp;in&nbsp;a&nbsp;tree&nbsp;that&nbsp;have&nbsp;exactly&nbsp;one&nbsp;non-leaf&nbsp;child.</span><br/><span class="comment">--&nbsp;The&nbsp;spaces&nbsp;between&nbsp;the&nbsp;(&nbsp;...&nbsp;)&nbsp;are&nbsp;just&nbsp;for&nbsp;legibility.</span><br/>nodesWithOneLeaf&nbsp;(Node&nbsp;Leaf&nbsp;Leaf)&nbsp;=&nbsp;0;<br/>nodesWithOneLeaf&nbsp;(Node&nbsp;Leaf&nbsp;t&nbsp;&nbsp;&nbsp;)&nbsp;=&nbsp;1&nbsp;+&nbsp;nodesWithOneLeaf(t);<br/>nodesWithOneLeaf&nbsp;(Node&nbsp;t&nbsp;&nbsp;&nbsp;&nbsp;Leaf)&nbsp;=&nbsp;1&nbsp;+&nbsp;nodesWithOneLeaf(t);<br/>nodesWithOneLeaf&nbsp;(Node&nbsp;t1&nbsp;&nbsp;&nbsp;t2&nbsp;&nbsp;)&nbsp;=&nbsp;nodesWithOneLeaf(t1)&nbsp;+&nbsp;nodesWithOneLeaf(t2);<br/>nodesWithOneLeaf&nbsp;(Leaf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;=&nbsp;0;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">Algebraic data types are very well-suited for represented abstract syntaxes of languages, and pattern matching unification makes it possible to define concise implementations of the operational semantics of languages (as well as any other transformations over abstract syntax trees, including optimization algorithms, static analysis algorithms, and compilation algorithms).</span>
<a name="beb651b8549a4706a411ce0af3cd0010"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#beb651b8549a4706a411ce0af3cd0010">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">Suppose we want to define an abstract syntax and simple interpreter for formulas. We can use the declarations below to do so.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">module</span>&nbsp;Formula&nbsp;<span class="keyword">where</span><br/><br/><span class="keyword">data</span>&nbsp;Formula&nbsp;=&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;T<br/>&nbsp;&nbsp;|&nbsp;F<br/>&nbsp;&nbsp;|&nbsp;Not&nbsp;Formula<br/>&nbsp;&nbsp;|&nbsp;And&nbsp;Formula&nbsp;Formula<br/>&nbsp;&nbsp;|&nbsp;Or&nbsp;Formula&nbsp;Formula<br/>&nbsp;&nbsp;<span class="keyword">deriving</span>&nbsp;Show;<br/><br/>vNot&nbsp;(T)&nbsp;=&nbsp;F;<br/>vNot&nbsp;(F)&nbsp;=&nbsp;T;<br/><br/>vAnd&nbsp;(T,&nbsp;T)&nbsp;=&nbsp;T;<br/>vAnd&nbsp;(T,&nbsp;F)&nbsp;=&nbsp;F;<br/>vAnd&nbsp;(F,&nbsp;T)&nbsp;=&nbsp;F;<br/>vAnd&nbsp;(F,&nbsp;F)&nbsp;=&nbsp;F;<br/><br/>vOr&nbsp;(T,&nbsp;T)&nbsp;=&nbsp;T;<br/>vOr&nbsp;(T,&nbsp;F)&nbsp;=&nbsp;T;<br/>vOr&nbsp;(F,&nbsp;T)&nbsp;=&nbsp;T;<br/>vOr&nbsp;(F,&nbsp;F)&nbsp;=&nbsp;F;<br/><br/>eval&nbsp;(T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;=&nbsp;T;<br/>eval&nbsp;(F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;=&nbsp;F;<br/>eval&nbsp;(Not&nbsp;f&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;=&nbsp;vNot&nbsp;(eval&nbsp;f);<br/>eval&nbsp;(And&nbsp;f1&nbsp;f2)&nbsp;=&nbsp;vAnd&nbsp;(eval&nbsp;f1,&nbsp;eval&nbsp;f2);<br/>eval&nbsp;(Or&nbsp;&nbsp;f1&nbsp;f2)&nbsp;=&nbsp;vOr&nbsp;(eval&nbsp;f1,&nbsp;eval&nbsp;f2);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">Using wildcards (written using the underscore <code>_</code>) in patterns makes it possible to write even more concise definitions.</span>
        
<div class="code"><div class="source"><br/>vAnd&nbsp;(T,&nbsp;T)&nbsp;=&nbsp;T;<br/>vAnd&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;F;<br/><br/>vOr&nbsp;(F,&nbsp;F)&nbsp;=&nbsp;F;<br/>vOr&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;T;<br/><br/>eval&nbsp;(Not&nbsp;f&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;=&nbsp;vNot&nbsp;(eval&nbsp;f);<br/>eval&nbsp;(And&nbsp;f1&nbsp;f2)&nbsp;=&nbsp;vAnd&nbsp;(eval&nbsp;f1,&nbsp;eval&nbsp;f2);<br/>eval&nbsp;(Or&nbsp;&nbsp;f1&nbsp;f2)&nbsp;=&nbsp;vOr&nbsp;(eval&nbsp;f1,&nbsp;eval&nbsp;f2);<br/>eval&nbsp;(f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;f;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">To check equality of algebraic data type instances, it is necessary to either implement or derive the equality function <code>==</code>. To have the Haskell interpreter or compiler derive it automatically, you can use <code>deriving Eq</code>. These can be combined with other <code>deriving</code> directives, such as in the example below.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">data</span>&nbsp;Formula&nbsp;=&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;T<br/>&nbsp;&nbsp;|&nbsp;F<br/>&nbsp;&nbsp;|&nbsp;Not&nbsp;Formula<br/>&nbsp;&nbsp;|&nbsp;And&nbsp;Formula&nbsp;Formula<br/>&nbsp;&nbsp;|&nbsp;Or&nbsp;Formula&nbsp;Formula<br/>&nbsp;&nbsp;<span class="keyword">deriving</span>&nbsp;(Eq,&nbsp;Show);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
      </div></div></div></div><br/><hr/><a name="7.5"></a><a name="assignment4"></a><a name="hw4"></a><div class="assignment"><h3 class="linked"><span class="link-title">[<a href="#7.5">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.5.</span> <span class="assignment_title">Assignment #4: Declarative Programming Languages</span></h3><div class="instructions">
In this assignment you will implement an interpreter using Python for a declarative language, and you will practice using the declarative programming language Haskell. You must submit three files:
<ul>
  <li><code><a href="hw4/parse.py">hw4/parse.py</a></code> (there is no need to modify this file);</li>
  <li><code><a href="hw4/interpret.py">hw4/interpret.py</a></code>;</li>
  <li><code><a href="hw4/Tree.hs">hw4/Tree.hs</a></code>.</li>
</ul>
Please follow the <a href="http://www.cs.bu.edu/teaching/hw/gsubmit/">gsubmit</a> directions and remember to put your files in the <code>hw4</code> directory.
<br/><br/>
Your solutions to each of the problem parts below will be graded on their correctness, concision, and mathematical legibility. The different problems and problem parts rely on the lecture notes and on each other; carefully consider whether you can use functions from the lecture notes, or functions you define in one part within subsequent parts.
<br/><br/>
<b style="color:green;">A testing script with several test cases is available for download: <a href="a4-tests.py"><code>a4-tests.py</code></a>. You should be able to place it in the same directory with the other assignment files and run it. Feel free to modify or extend it as you see fit.</b>
<!--
<br/><br/>
<b style="color:green;">A full solution to this assignment is now available here: <a href="hw4/solutions/"><code>/hw4/solutions</code></a>.</b>
-->
      
      </div><ol class="problems"><li class="problem">
<span class="text">In this problem you will implement helper functions for performing substitution and unification. Your solutions should be included in the file <code><a href="hw4/interpret.py">hw4/interpret.py</a></code>.</span><ol class="parts"><li class="part">
<span class="text">Implement a function <code>subst(s, a)</code> that takes two arguments: a substitution <code>s</code> (represented as a Python dictionary), and an abstract syntax tree <code>a</code>. The function should return a new abstract syntax tree in which every variable in the tree that is in the domain of <code>s</code> has been substituted according to the substitution <code>s</code>. You may assume that variables are always represented using a subtree of the form <code>{"Variable":[ ... ]}</code>, as in all previous examples and assignments.</span></li><li class="part">
<span class="text">Implement a function <code>unify(a, b)</code> that takes two arguments: two syntax trees <code>a</code> and <code>b</code>. The function should return the smallest substitution <code>s</code> that satisfies the following equation:</span>
<div class="code"><div class="source"><br/>subst(s,&nbsp;a)&nbsp;==&nbsp;subst(s,&nbsp;b)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">You should implement the <a href="#95e800c8e74e4991a2ddb48668b544e0">pattern matching unification</a> algorithm for this assignment.</span></li></ol></li><li class="problem">
<span class="text">In this problem, you will implement an interactive interpreter for a declarative language (a small, untyped version of a subset of Haskell). All the functions you define should be included in the file <code><a href="hw4/interpret.py">hw4/interpret.py</a></code>. The abstract syntax for the language is presented below; a complete parser that parses the concrete syntax for this language into the abstract syntax below can be found in <code><a href="hw4/parse.py">hw4/parse.py</a></code>. Notice that in the concrete syntax, constructor names always begin with an uppercase letter, while variable names always begin with a lowercase letter.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">declaration <i>d</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>f</i> <b>(</b> <i>p</i> <b>)</b> <b>=</b> <i>e</i> <b>;</b> <i>d</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
pattern <i>p</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>c</i> <i>p</i> <i>p</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>c</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>n</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>x</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>(</b> <i>p</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
expression <i>e</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>c</i> <i>e</i> <i>e</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>c</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>n</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>x</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>(</b> <i>e</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>e</i> <b>+</b> <i>e</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>f</i> <b>(</b> <i>e</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
number <i>n</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <code>0|[1-9][0-9]*</code> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
constructor <i>c</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <code>[A-Z][A-Za-z]*</code> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
variable <i>x</i>, <i>f</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <code>[a-z][A-Za-z]*</code>
</td></tr></table></td></tr></table>
The relevant portions of the operational semantics are provided below:</span><ol class="parts"><li class="part">
<span class="text">Implement a function <code>build(m, d)</code> that takes a finite map <code>m</code> (i.e., a Python dictionary mapping names to lists of (<i>pattern</i>, <i>expression</i>) tuples) and a <i>declaration</i> parse tree <code>d</code>. The function should return the finite map <code>m</code> that represents the module definition that is assembled according to the operational semantics presented below:</span><div class="inferences"><table class="inference"><tr><td class="title">[Declaration-Function-First]</td><td><table><tr><td class="premises">&nbsp;
                    <i>f</i> &notin; dom(<i>M</i><sub>1</sub>) 
                    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>M</i><sub>1</sub> &#8846; {<i>f</i> &#x21A6; {(<i>p</i>, <i>e</i>)}} <i>d</i> &dArr; <i>M</i><sub>2</sub>
                  &nbsp;</td></tr><tr><td class="conclusion">&nbsp;
                    <i>M</i><sub>1</sub>, <i>f</i> <b>(</b> <i>p</i> <b>)</b> <b>=</b> <i>e</i> <b>;</b> <i>d</i> &dArr; <i>M</i><sub>2</sub>
                  &nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Declaration-Function-More]</td><td><table><tr><td class="premises">&nbsp;
                    <i>f</i> <span style="font-size:12px;">&#8712;</span> dom(<i>M</i><sub>1</sub>)
                    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>M</i><sub>1</sub> &#8846; {<i>f</i> &#x21A6; (<i>M</i><sub>1</sub>(<i>f</i>) &#8846; {(<i>p</i>, <i>e</i>)})} <i>d</i> &dArr; <i>M</i><sub>2</sub>
                  &nbsp;</td></tr><tr><td class="conclusion">&nbsp;
                    <i>M</i><sub>1</sub>, <i>f</i> <b>(</b> <i>p</i> <b>)</b> <b>=</b> <i>e</i> <b>;</b> <i>d</i> &dArr; <i>M</i><sub>2</sub>
                  &nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Declaration-End]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>M</i>, <b style="color:gray;">end</b> &dArr; <i>M</i>&nbsp;</td></tr></table></td></tr></table></div></li><li class="part">
<span class="text">The abstract syntax for values is defined as follows:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">value <i>v</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>c</i> <i>v</i> <i>v</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>c</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>n</i>
</td></tr></table></td></tr></table></span>
<span class="text">Implement a function <code>evaluate(m, env, e)</code> that takes a module <code>m</code>, an environment <code>env</code>, and an <i>expression</i> abstract syntax tree <code>e</code> as its three arguments. The function should return the value that corresponds to the evaluation of the abstract syntax tree <code>e</code>, as determined by the operational semantics presented below. Note that the <span style="font-variant:small-caps;">[Expression-Apply]</span> requires using a unification algorithm to obtain a substitution &sigma; that unifies <i>p</i> and <i>v</i><sub>1</sub>.</span><div class="inferences"><table class="inference"><tr><td class="title">[Expression-Constructor-Args]</td><td><table><tr><td class="premises">&nbsp;<i>M</i>, &Sigma;, <i>e</i><sub>1</sub> &dArr; <i>v</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>M</i>, &Sigma;, <i>e</i><sub>2</sub> &dArr; <i>v</i><sub>2</sub>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>M</i>, &Sigma;, <i>c</i> <i>e</i><sub>1</sub> <i>e</i><sub>2</sub> &dArr; <i>c</i> <i>v</i><sub>1</sub> <i>v</i><sub>2</sub>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Expression-Constructor-No-Args]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>M</i>, &Sigma;, <i>c</i> &dArr; <i>c</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Expression-Number]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>M</i>, &Sigma;, <i>n</i> &dArr; <i>n</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Expression-Variable]</td><td><table><tr><td class="premises">&nbsp;&Sigma;(<i>x</i>) = <i>v</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>M</i>, &Sigma;, <i>x</i> &dArr; <i>v</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Expression-Plus]</td><td><table><tr><td class="premises">&nbsp;<i>M</i>, &Sigma;, <i>e</i><sub>1</sub> &dArr; <i>n</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>M</i>, &Sigma;, <i>e</i><sub>2</sub> &dArr; <i>n</i><sub>2</sub>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<i>M</i>, &Sigma;, <i>e</i><sub>1</sub> <b>+</b> <i>e</i><sub>2</sub> &dArr; <i>n</i><sub>1</sub> + <i>n</i><sub>2</sub>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Expression-Apply]</td><td><table><tr><td class="premises">&nbsp;
                    <i>M</i>, &Sigma;, <i>e</i><sub>1</sub> &dArr; <i>v</i><sub>1</sub>
                    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; (<i>p</i>, <i>e</i><sub>2</sub>) <span style="font-size:12px;">&#8712;</span> <i>M</i>(<i>f</i>)
                    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &sigma;(<i>p</i>) = &sigma;(<i>v</i><sub>1</sub>)
                    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>M</i>, &Sigma; &#8846; &sigma;, <i>e</i><sub>2</sub> &dArr; <i>v</i><sub>2</sub>
                  &nbsp;</td></tr><tr><td class="conclusion">&nbsp;
                    <i>M</i>, &Sigma; , <i>f</i> <b>(</b> <i>e</i><sub>1</sub> <b>)</b> &dArr; <i>v</i><sub>2</sub>
                  &nbsp;</td></tr></table></td></tr></table></div></li></ol>
<span class="text">Once <code>build()</code> and <code>evaluate()</code> are implemented, you can use the <code>interact()</code> function in <code><a href="hw4/interpret.py">hw4/interpret.py</a></code> to query modules.</span></li><li class="problem">
<span class="text">In this problem you will practice using the Haskell programming language. All your definitions should be included in the file <code><a href="hw4/Tree.hs">hw4/Tree.hs</a></code>. You will be working with the following data type definition, which has already been included in the file:</span>
<div class="code"><div class="source"><br/><span class="keyword">data</span>&nbsp;Tree&nbsp;=&nbsp;Leaf&nbsp;|&nbsp;Node&nbsp;Tree&nbsp;Tree<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">You may not import any additional modules or libraries.</span><ol class="parts"><li class="part">
<span class="text">Modify the data type definition for <code>Tree</code> in <code>Tree.hs</code> so that the functions <code>(==)</code> and <code>show</code> are automatically generated for this data type.</span></li><li class="part">
<span class="text">Implement a function <code>leaves :: Tree -> Integer</code> that returns an integer representing the total number of leaves in the input tree.</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;leaves&nbsp;(Node&nbsp;(Node&nbsp;Leaf&nbsp;Leaf)&nbsp;Leaf)<br/>3<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li><li class="part">
<span class="text">Implement a function <code>nodes :: Tree -> Integer</code> that returns an integer representing the total number of nodes in the input tree.</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;nodes&nbsp;(Node&nbsp;(Node&nbsp;Leaf&nbsp;Leaf)&nbsp;Leaf)<br/>2<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li><li class="part">
<span class="text">Implement a function <code>height :: Tree -> Integer</code> that returns an integer representing the height of the input tree. Trees consisting of a <code>Leaf</code> are defined to have height <code>1</code>.</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;height&nbsp;(Node&nbsp;(Node&nbsp;Leaf&nbsp;Leaf)&nbsp;Leaf)<br/>3<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li><li class="part">
<span class="text">A tree is <i>perfect</i> if all the leaves of the tree are at the same depth. Define a function <code>perfect :: Tree -> Bool</code> that returns <code>True</code> if the input tree is perfect and <code>False</code> otherwise.</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;perfect&nbsp;(Node&nbsp;(Node&nbsp;Leaf&nbsp;Leaf)&nbsp;Leaf)<br/>False<br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;perfect&nbsp;(Node&nbsp;(Node&nbsp;Leaf&nbsp;Leaf)&nbsp;(Node&nbsp;Leaf&nbsp;Leaf))<br/>True<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li><li class="part">
<span class="text">A tree is <i>degenerate</i> if all the nodes are part of a single path. Equivalently, a tree is degenerate if all nodes have at least one leaf child. Define a function <code>degenerate :: Tree -> Bool</code> that returns <code>True</code> if the tree supplied is degenerate, and <code>False</code> otherwise.</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;degenerate&nbsp;(Node&nbsp;(Node&nbsp;Leaf&nbsp;Leaf)&nbsp;Leaf)<br/>True<br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;degenerate&nbsp;(Node&nbsp;(Node&nbsp;Leaf&nbsp;Leaf)&nbsp;(Node&nbsp;Leaf&nbsp;Leaf))<br/>False<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li><li class="part">
<span class="text">Define a tree <code>infinite :: Tree</code> that has no leaves.</span></li></ol></li></ol>
</div><hr/><br/>
  <a name="7.6"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#7.6">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.6.</span> Type system of the typed declarative language Haskell</h3>
<span class="text">Haskell natively supports defining and using algebraic data types, tuples, lists, and functions. The Haskell type system provides a good way to organize and document these data structures, and governs how they can be combined. The abstract syntax for a portion of the Haskell type system is provided below.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">Haskell type &tau; <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <code>Bool</code> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <code>Int</code> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <code>Integer</code> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <code>Char</code> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <code>()</code> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <code>(</code> &tau; <code>,</code> &tau; <code>)</code> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <code>(</code> &tau; <code>,</code> &tau; <code>,</code> &tau; <code>)</code> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> &#8942; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <code>(</code> &tau; <code>,</code> ... <code>,</code> &tau; <code>)</code> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <code>[</code> &tau; <code>]</code> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> &tau; <code>-></code> &tau;</td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
                 <td></tr></table></td><td style="text-align:center;"> &#8942; </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
</td></tr></table></td></tr></table>
Haskell allows users to define their own algebraic data types as well as their own type synonyms. Every Haskell module has two distinct namespaces for identifiers, and these two namespaces are completely disjoint: there is a namespace for identifiers that correspond to variable, functions, and constructors, and there is a namespace for identifiers that correspond to types. The concrete syntax determines to which namespace a given variable belongs, and there is never any ambiguity in the concrete syntax in this regard. Note that this is unlike Python, where types can appear in any expression within a program. The following example illustrates the distinct namespaces for <span style="background-color:lightgreen">expressions</span> and <span style="background-color:pink">types</span>:
<div class="code"><div class="source">
<br/>module Example where
<br/>
<br/><span style="background-color:lightgreen">f</span> :: <span style="background-color:pink">Integer</span> -> <span style="background-color:pink">Integer</span>
<br/><span style="background-color:lightgreen">f</span> (<span style="background-color:lightgreen">x</span>) = <span style="background-color:lightgreen">x</span> + <span style="background-color:lightgreen">x</span>
<br/>
<br/>data <span style="background-color:pink">Tree</span> = <span style="background-color:lightgreen">Leaf</span> | <span style="background-color:lightgreen">Node</span> <span style="background-color:pink">Tree</span> <span style="background-color:pink">Tree</span>
<br/>
<br/>type <span style="background-color:pink">AnotherNameForInteger</span> = <span style="background-color:pink">Integer</span>
<br/>
<br/>type <span style="background-color:pink">AnotherNameForTree</span> = <span style="background-color:pink">Tree</span>
<br/>
<br/><span style="background-color:lightgreen">isLeaf</span> :: <span style="background-color:pink">AnotherNameForTree</span> -> <span style="background-color:pink">Bool</span>
<br/><span style="background-color:lightgreen">isLeaf</span> (<span style="background-color:lightgreen">Leaf</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;) = <span style="background-color:lightgreen">True</span>
<br/><span style="background-color:lightgreen">isLeaf</span> (<span style="background-color:lightgreen">Node</span> <span style="background-color:lightgreen">t1</span> <span style="background-color:lightgreen">t2</span>) = <span style="background-color:lightgreen">False</span>
<br/><br/></div></div></span>
<span class="text">Haskell lists have a list type in Haskell. For example, a list of integers has the type <code>[Integer]</code>.</span>
<div class="code"><div class="source"><br/>list&nbsp;::&nbsp;[Integer]<br/>list&nbsp;=&nbsp;[1,2,3]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">Haskell lists are actually represented using an algebraic data type that is similar to the <code>Tree</code> data type <a href="#7.4">that we have already seen</a>. If we were to define our own algebraic data type for lists in Haskell, for example, we could do so as follows (the terms "nil" and "cons" are commonly used in the functional language community for the empty list and for the list node constructor, respectively):</span>
<div class="code"><div class="source"><br/><span class="keyword">data</span>&nbsp;List&nbsp;=&nbsp;Nil&nbsp;|&nbsp;Cons&nbsp;Integer&nbsp;List<br/><br/>example&nbsp;::&nbsp;List<br/>example&nbsp;=&nbsp;Cons&nbsp;1&nbsp;(Cons&nbsp;2&nbsp;(Cons&nbsp;3&nbsp;Nil))<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">The built-in list type has its own special names for the two constructors: the empty list is denoted <code>[]</code>, and the list node constructor is the operator <code>(:)</code>, which can also be written as an infix operator <code>:</code>. The following three syntaxes are equivalent, and evaluate to the same list <code>[1,2,3]</code>:</span>
<div class="code"><div class="source"><br/>example1&nbsp;::&nbsp;[Integer]<br/>example1&nbsp;=&nbsp;(:)&nbsp;1&nbsp;((:)&nbsp;2&nbsp;((:)&nbsp;3&nbsp;[]))<br/><br/>example2&nbsp;::&nbsp;[Integer]<br/>example2&nbsp;=&nbsp;&nbsp;1&nbsp;:&nbsp;(2&nbsp;:&nbsp;(3&nbsp;:&nbsp;[]))<br/><br/>example3&nbsp;::&nbsp;[Integer]<br/>example3&nbsp;=&nbsp;&nbsp;[1,2,3]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">There is also a syntax for defining lists that contain ranges of integers:</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;[1..4]<br/>[1,2,3,4]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">Haskell supports user-defined type synonyms. These are simply substituted and have no restrictive effects.</span>
<div class="code"><div class="source"><br/><span class="keyword">type</span>&nbsp;Distance&nbsp;=&nbsp;Integer<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">There are some default type synonym definitions, such as <code>String</code>; strings in Haskell are just lists of characters:</span>
<div class="code"><div class="source"><br/><span class="keyword">type</span>&nbsp;String&nbsp;=&nbsp;[Char]<br/><br/>example1&nbsp;::&nbsp;String<br/>example1&nbsp;=&nbsp;<span class="literal">"abcdefg"</span><br/><br/>example2&nbsp;::&nbsp;String<br/>example2&nbsp;=&nbsp;[<span class="literal">a</span>,&nbsp;<span class="literal">b</span>,&nbsp;<span class="literal">c</span>,&nbsp;<span class="literal">d</span>,&nbsp;<span class="literal">e</span>,&nbsp;<span class="literal">f</span>,&nbsp;<span class="literal">g</span>]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">Type synonyms can be assigned any valid type, no matter how complex it may be. In the below example, the type synonym <code>GameStrategyAlgorithm</code> is equivalent to the type <code>[[(Integer, Integer)]] -> String</code> (i.e., the type for functions that take lists of lists of integer pairs and return a string):</span>
<div class="code"><div class="source"><br/><span class="keyword">type</span>&nbsp;GameState&nbsp;=&nbsp;[(Integer,&nbsp;Integer)]<br/><span class="keyword">type</span>&nbsp;Game&nbsp;=&nbsp;[GameState]<br/><span class="keyword">type</span>&nbsp;Strategy&nbsp;=&nbsp;String<br/><span class="keyword">type</span>&nbsp;GameStrategyAlgorithm&nbsp;=&nbsp;Game&nbsp;->&nbsp;Strategy<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></div>
  <a name="7.7"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#7.7">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.7.</span> Defining and working with infinite data type instances using lazy evaluation</h3>
<span class="text">Since Haskell expressions are only evaluated when a query is made, a Haskell module can safely describe recursively defined, potentially infinitely large values. For example, we can define an infinite list containing the integer <code>1</code> in every position:</span>
<div class="code"><div class="source"><br/>infinite&nbsp;::&nbsp;[Integer]<br/>infinite&nbsp;=&nbsp;[1]&nbsp;++&nbsp;infinite<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">Equivalently, we can use the <code>(:)</code> list node constructor:</span>
<div class="code"><div class="source"><br/>infinite&nbsp;::&nbsp;[Integer]<br/>infinite&nbsp;=&nbsp;1&nbsp;:&nbsp;infinite<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">Haskell also allows infinite lists containing ranges to be declared using the list range notation:</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;take&nbsp;10&nbsp;[5..]<br/>[5,6,7,8,9,10,11,12,13,14]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">The Haskell operational semantics is based on pattern matching unification, but it doesn't work exactly like the operational semantics we implemented in <a href="#assignment4">Assignment #4</a>. Haskell supports <i>lazy evaluation</i>. Intuitively, when trying to evaluate a function application of the form <i>f</i>(<i>e</i>), Haskell will only evaluate the expression <i>e</i> using substitutions until it is sufficiently deep to try all the patterns in the definition of <i>f</i> (e.g., if the patterns associated with <i>f</i> are all of depth at most 3, the expression <i>e</i> will be evaluated until the constructors up to depth 3 are known, and no further).
<br/><br/>
Haskell lazy evaluation operational semantics make it possible to perform queries on infinite values without running into an infinite recursion or infinite loop. For example, suppose we define the following function on lists, which takes only the first <code>n</code> elements of a list (note that this function is already included in the <code>Prelude</code>).</span>
<div class="code"><div class="source"><br/>take&nbsp;::&nbsp;Integer&nbsp;->&nbsp;[Integer]&nbsp;->&nbsp;[Integer]<br/>take&nbsp;0&nbsp;xs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;[]<br/>take&nbsp;n&nbsp;(x:xs)&nbsp;=&nbsp;x&nbsp;:&nbsp;take&nbsp;(n-1)&nbsp;xs<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">Querying the infinite list is not a problem if we use <code>take</code>.</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;take&nbsp;10&nbsp;infinite<br/>[1,1,1,1,1,1,1,1,1,1]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">Using pattern matching unification and lazy evaluation, it is also possible to define algorithm that can operate on infinite lists. For example, we can define a function that adds all the corresponding elements of two infinite lists. Notice that there is no case for the empty list in this definition because infinite lists are never empty.</span>
<div class="code"><div class="source"><br/>addInfiniteLists&nbsp;::&nbsp;([Integer],&nbsp;[Integer])&nbsp;->&nbsp;[Integer]<br/>addInfiniteLists&nbsp;(x:xs,&nbsp;y:ys)&nbsp;=&nbsp;(x&nbsp;+&nbsp;y)&nbsp;:&nbsp;addInfiniteLists&nbsp;(xs,&nbsp;ys)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">We can now use the <code>addInfiniteLists</code> function to add two infinite lists. Suppose we have the following definitions:</span>
<div class="code"><div class="source"><br/>ones&nbsp;=&nbsp;1&nbsp;:&nbsp;ones<br/>twos&nbsp;=&nbsp;2&nbsp;:&nbsp;twos<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">We can then define an infinite list in which all entries are <code>3</code>:</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;take&nbsp;10&nbsp;(addInfiniteLists&nbsp;(ones,&nbsp;twos))<br/>[3,3,3,3,3,3,3,3,3,3]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></div>
  <a name="7.8"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#7.8">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.8.</span> Functions and higher-order functions in a typed functional language</h3>
<span class="text">Haskell is a functional language; functional languages are distinguished by their ability to allow users to define and use <i>higher-order function</i>: functions that can take other function as arguments, and that can return functions as results. Many other languages have native support for higher-order functions, including JavaScript and Python; we say that these languages support the functional programming paradigm.
<br/><br/>
To start become familiar with the concept of a higher-order function, we can consider the following example:</span>
<div class="code"><div class="source"><br/>f&nbsp;::&nbsp;Integer&nbsp;->&nbsp;Integer<br/>f&nbsp;(x)&nbsp;=&nbsp;x&nbsp;+&nbsp;1<br/><br/>g&nbsp;::&nbsp;Integer&nbsp;->&nbsp;(Integer&nbsp;->&nbsp;Integer)<br/>g&nbsp;(y)&nbsp;=&nbsp;f<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">Notice that <code>g</code> is a function that takes an integer as an argument. It then throws this argument away and returns the function <code>f</code>. Its type reflects this. Thus, the result of evaluating an expression such as <code>g(4)</code> is a function of type <code>Integer -> Integer</code>, and this function can be applied to another argument.</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;:t&nbsp;g(1)<br/>g(1)&nbsp;::&nbsp;Integer&nbsp;->&nbsp;Integer<br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;:t&nbsp;g(1)(5)<br/>g(1)(5)&nbsp;::&nbsp;Integer<br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;g(1)(5)<br/>6<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">What if we want to define a function like <code>g</code> that can be partially applied to only some of its arguments, but that still uses all of its arguments? We can do so by listing multiple, space-separated parameters in the definition of <code>g</code>.</span>
<div class="code"><div class="source"><br/>g&nbsp;::&nbsp;Integer&nbsp;->&nbsp;(Integer&nbsp;->&nbsp;Integer)<br/>g&nbsp;(y)&nbsp;(x)&nbsp;=&nbsp;y&nbsp;+&nbsp;x<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">It is then possible to apply <code>g</code> to arguments one at a time, as before.</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;:t&nbsp;g(3)<br/>g(3)&nbsp;::&nbsp;Integer&nbsp;->&nbsp;Integer<br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;:t&nbsp;g(3)(4)<br/>g(3)(4)&nbsp;::&nbsp;Integer<br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;g(3)(4)<br/>7<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">Notice the relationship between application of functions to arguments, and the types of each intermediate result. Suppose we have the following definitions.</span>
<div class="code"><div class="source"><br/><span class="keyword">data</span>&nbsp;A&nbsp;=&nbsp;A<br/><span class="keyword">data</span>&nbsp;B&nbsp;=&nbsp;B<br/><span class="keyword">data</span>&nbsp;C&nbsp;=&nbsp;C<br/><span class="keyword">data</span>&nbsp;D&nbsp;=&nbsp;D<br/><span class="keyword">data</span>&nbsp;E&nbsp;=&nbsp;E<br/><br/>f&nbsp;::&nbsp;A&nbsp;->&nbsp;(B&nbsp;->&nbsp;(C&nbsp;->&nbsp;(D&nbsp;->&nbsp;E)))<br/>f&nbsp;a&nbsp;b&nbsp;c&nbsp;d&nbsp;=&nbsp;E<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">Then we have the following types for each of the following expressions (spacing adjusted for legibility):</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;:t&nbsp;f<br/>f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;A&nbsp;->&nbsp;(B&nbsp;->&nbsp;(C&nbsp;->&nbsp;(D&nbsp;->&nbsp;E)))<br/><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;:t&nbsp;f(A)<br/>f(A)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;B&nbsp;->&nbsp;(C&nbsp;->&nbsp;(D&nbsp;->&nbsp;E))<br/><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;:t&nbsp;f(A)(B)<br/>f(A)(B)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;C&nbsp;->&nbsp;(D&nbsp;->&nbsp;E)<br/><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;:t&nbsp;f(A)(B)(C)<br/>f(A)(B)(C)&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;D&nbsp;->&nbsp;E<br/><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;:t&nbsp;f(A)(B)(C)(D)<br/>f(A)(B)(C)(D)&nbsp;::&nbsp;E<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></div>
  <a name="7.9"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#7.9">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.9.</span> Data encapsulation using algebraic data types</h3>
<span class="text">Typed languages that support algebraic data types make it possible to implement and enforce a kind of data encapsulation. For example, suppose we want to represent distances in various units (such as Imperial and metric units) in our program. There are well-known examples of expensive software failures (such as the crash of the <a href="http://en.wikipedia.org/wiki/Mars_Climate_Orbiter">Mars Climate Orbiter</a>) that occurred because one component assumed that numerical data was in Imperial units, while another component assumed it was metric units.</span>
<div class="code"><div class="source"><br/><span class="keyword">data</span>&nbsp;Meters&nbsp;=&nbsp;Meters&nbsp;Integer<br/><span class="keyword">data</span>&nbsp;Feet&nbsp;=&nbsp;Feet&nbsp;Integer<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">Given the above, it is now possible to enforce which type of measurement is supported by a function. For example:</span>
<div class="code"><div class="source"><br/><span class="keyword">data</span>&nbsp;Action&nbsp;=&nbsp;KeepGoing&nbsp;|&nbsp;SlowDown<br/><br/>updateVelocity&nbsp;::&nbsp;Feet&nbsp;->&nbsp;Action<br/>updateVelocity&nbsp;(Feet&nbsp;n)&nbsp;=&nbsp;<span class="keyword">if</span>&nbsp;n&nbsp;<&nbsp;100&nbsp;<span class="keyword">then</span>&nbsp;SlowDown&nbsp;<span class="keyword">else</span>&nbsp;KeepGoing<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></div>
  <a name="7.10"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#7.10">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.10.</span> Adding user-defined operators and operations using Haskell type classes</h3>
<span class="text">Haskell allows programmers to define their own functions for converting algebraic data type values to strings (e.g., for displaying them in the interactive interface), and it allows programmers to provide custom definitions for numeric literals (i.e., <code>0</code>, <code>1</code>, <code>2</code>, and so on) and built-in operators (such as <code>+</code>, <code>*</code>, and so on).</span>
<div class="code"><div class="source"><br/><span class="keyword">instance</span>&nbsp;Num&nbsp;Meters&nbsp;<span class="keyword">where</span><br/>&nbsp;&nbsp;fromInteger&nbsp;n&nbsp;=&nbsp;Meters&nbsp;n<br/>&nbsp;&nbsp;(Meters&nbsp;x)&nbsp;+&nbsp;(Meters&nbsp;y)&nbsp;=&nbsp;Meters&nbsp;(x&nbsp;+&nbsp;y)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">The above definitions allow us to use the numeric liters and built-in operators to work with values of type <code>Meters</code>.</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;1&nbsp;+&nbsp;2&nbsp;+&nbsp;3&nbsp;::&nbsp;Meters<br/>Meters&nbsp;6<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">It is also possible to provide a user-defined function for converting values of type <code>Meters</code> to strings.</span>
<div class="code"><div class="source"><br/><span class="keyword">instance</span>&nbsp;Show&nbsp;Meters&nbsp;<span class="keyword">where</span><br/>&nbsp;&nbsp;show&nbsp;(Meters&nbsp;n)&nbsp;=&nbsp;show&nbsp;n&nbsp;++&nbsp;<span class="literal">"&nbsp;meters"</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">Then, we have the following behavior:</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;1&nbsp;+&nbsp;2&nbsp;+&nbsp;3&nbsp;::&nbsp;Meters<br/>6&nbsp;meters<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">The Haskell features that support algebraic data types, multiple ways to apply higher-order functions to arguments, user-defined infix operators, and user-defined definitions of built-in literals and functions can be used in concert to easily define new programming languages <i>within</i> Haskell itself. This makes it much easier to build parse trees directly within Haskell, thus obviating the need for a parser.</span>
<a name="334b004be37343b3b190ddd3fd9ca116"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#334b004be37343b3b190ddd3fd9ca116">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">Suppose we define the following algebraic data types, corresponding to an abstract syntax for an imperative programming language.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">data</span>&nbsp;Term&nbsp;=<br/>&nbsp;&nbsp;&nbsp;&nbsp;Number&nbsp;Integer<br/>&nbsp;&nbsp;|&nbsp;Plus&nbsp;Term&nbsp;Term<br/>&nbsp;&nbsp;<span class="keyword">deriving</span>&nbsp;Show<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/><span class="keyword">data</span>&nbsp;Formula&nbsp;=&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;T&nbsp;<br/>&nbsp;&nbsp;|&nbsp;F&nbsp;<br/>&nbsp;&nbsp;|&nbsp;Not&nbsp;Formula&nbsp;<br/>&nbsp;&nbsp;|&nbsp;And&nbsp;Formula&nbsp;Formula<br/>&nbsp;&nbsp;|&nbsp;Or&nbsp;Formula&nbsp;Formula<br/>&nbsp;&nbsp;|&nbsp;Equal&nbsp;Term&nbsp;Term<br/>&nbsp;&nbsp;|&nbsp;LessThan&nbsp;Term&nbsp;Term<br/>&nbsp;&nbsp;<span class="keyword">deriving</span>&nbsp;Show<br/><br/><span class="keyword">data</span>&nbsp;Statement&nbsp;=<br/>&nbsp;&nbsp;&nbsp;&nbsp;Print&nbsp;Term&nbsp;Statement<br/>&nbsp;&nbsp;|&nbsp;If&nbsp;Formula&nbsp;Statement&nbsp;Statement<br/>&nbsp;&nbsp;|&nbsp;End<br/>&nbsp;&nbsp;<span class="keyword">deriving</span>&nbsp;Show<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">We also introduce some user-defined infix operators, and add user-specified definitions for some built-in Haskell operators:</span>
        
<div class="code"><div class="source"><br/>(<<<)&nbsp;::&nbsp;Term&nbsp;->&nbsp;Term&nbsp;->&nbsp;Formula<br/>(<<<)&nbsp;t1&nbsp;t2&nbsp;=&nbsp;LessThan&nbsp;t1&nbsp;t2<br/><br/>(===)&nbsp;::&nbsp;Term&nbsp;->&nbsp;Term&nbsp;->&nbsp;Formula<br/>(===)&nbsp;t1&nbsp;t2&nbsp;=&nbsp;Equal&nbsp;t1&nbsp;t2<br/><br/>(&&&)&nbsp;::&nbsp;Formula&nbsp;->&nbsp;Formula&nbsp;->&nbsp;Formula<br/>(&&&)&nbsp;f1&nbsp;f2&nbsp;=&nbsp;And&nbsp;f1&nbsp;f2<br/><br/>(|||)&nbsp;::&nbsp;Formula&nbsp;->&nbsp;Formula&nbsp;->&nbsp;Formula<br/>(|||)&nbsp;f1&nbsp;f2&nbsp;=&nbsp;Or&nbsp;f1&nbsp;f2<br/><br/><span class="keyword">instance</span>&nbsp;Num&nbsp;Term&nbsp;<span class="keyword">where</span><br/>&nbsp;&nbsp;fromInteger&nbsp;n&nbsp;=&nbsp;Number&nbsp;n<br/>&nbsp;&nbsp;t1&nbsp;+&nbsp;t2&nbsp;=&nbsp;Plus&nbsp;t1&nbsp;t2<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">We can now use all of the above together with the <code>$</code> syntax to easily write down abstract syntax trees.</span>
        
<div class="code"><div class="source"><br/>parseTree&nbsp;=<br/>&nbsp;&nbsp;&nbsp;Print&nbsp;5&nbsp;$<br/>&nbsp;&nbsp;&nbsp;Print&nbsp;6&nbsp;$<br/>&nbsp;&nbsp;&nbsp;If&nbsp;((5&nbsp;<<<&nbsp;6)&nbsp;&&&&nbsp;(6&nbsp;<<<&nbsp;7))&nbsp;(<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Print&nbsp;6&nbsp;$<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Print&nbsp;7&nbsp;$<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;End<br/>&nbsp;&nbsp;&nbsp;)&nbsp;$<br/>&nbsp;&nbsp;&nbsp;End<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">Evaluating the definition of <code>parseTree</code> will yield the actual algebraic data type instance (i.e., a parse tree).</span>
        
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;parseTree<br/>Print&nbsp;(Number&nbsp;5)&nbsp;(Print&nbsp;(Number&nbsp;6)&nbsp;(<br/>&nbsp;&nbsp;If<br/>&nbsp;&nbsp;&nbsp;&nbsp;(And&nbsp;(LessThan&nbsp;(Number&nbsp;5)&nbsp;(Number&nbsp;6))&nbsp;(LessThan&nbsp;(Number&nbsp;6)&nbsp;(Number&nbsp;7)))&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;(Print&nbsp;(Number&nbsp;6)&nbsp;(Print&nbsp;(Number&nbsp;7)&nbsp;End))&nbsp;End)<br/>&nbsp;&nbsp;)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
      </div></div></div></div>
  <a name="7.11"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#7.11">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.11.</span> Additional useful Haskell language features and examples</h3>
<span class="text">Like Java/C/C++, Haskell provides a built-in ternary operator <code>if ... then ... else ...</code> for writing conditional expressions:</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;<span class="keyword">if</span>&nbsp;True&nbsp;<span class="keyword">then</span>&nbsp;1&nbsp;<span class="keyword">else</span>&nbsp;2<br/>1<br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;<span class="keyword">if</span>&nbsp;False&nbsp;&&&nbsp;True&nbsp;<span class="keyword">then</span>&nbsp;<span class="literal">"Yes"</span>&nbsp;<span class="keyword">else</span>&nbsp;<span class="literal">"No"</span><br/><span class="literal">"No"</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">However, this is only a convenience; a user can easily implement his or her own syntax for this purpose. The support for pattern matching unification and lazy evaluation that Haskell's operational semantics provides is sufficient. Two example implementations are provided below.</span>
<div class="code"><div class="source"><br/>if'&nbsp;::&nbsp;(Bool,&nbsp;Integer,&nbsp;Integer)&nbsp;->&nbsp;Integer<br/>if'&nbsp;(True,&nbsp;&nbsp;trueBranch,&nbsp;falseBranch)&nbsp;=&nbsp;trueBranch<br/>if'&nbsp;(False,&nbsp;trueBranch,&nbsp;falseBranch)&nbsp;=&nbsp;falseBranch<br/><br/>if''&nbsp;::&nbsp;Bool&nbsp;->&nbsp;Integer&nbsp;->&nbsp;Integer&nbsp;->&nbsp;Integer<br/>if''&nbsp;True&nbsp;&nbsp;trueBranch&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;trueBranch<br/>if''&nbsp;False&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;falseBranch&nbsp;=&nbsp;falseBranch<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">The <code>if ... then ... else ...</code> syntax (or function, as we have seen above) can be useful in certain situations.</span>
<a name="cb9d023417604b6eafe52b06e26f35fb"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#cb9d023417604b6eafe52b06e26f35fb">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">Suppose we are trying to represent an <a href="#e1a5053a93d54ad4b02da10e4981b810">environment</a> or <a href="#f7d600442fe211e38cf6ce3f5508acd9">substitution</a> using a data structure in Haskell. We might do so by using a list of tuples, where each tuple is a pair consisting of a <code>String</code> and a value (e.g., an <code>Integer</code>). For example:</span>
        
<div class="code"><div class="source"><br/>[(<span class="literal">"x"</span>,1),&nbsp;(<span class="literal">"y"</span>,&nbsp;2)]&nbsp;::&nbsp;[(String,&nbsp;Integer)]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">Then, we would need a function that can help us retrieve a value associated with a particular variable name.</span>
        
<div class="code"><div class="source"><br/>lookup'&nbsp;::&nbsp;String&nbsp;->&nbsp;[(String,&nbsp;Integer)]&nbsp;->&nbsp;Integer<br/>lookup'&nbsp;x&nbsp;((x',i)&nbsp;:&nbsp;rest)&nbsp;=&nbsp;<span class="keyword">if</span>&nbsp;x&nbsp;==&nbsp;x'&nbsp;<span class="keyword">then</span>&nbsp;i&nbsp;<span class="keyword">else</span>&nbsp;lookup'&nbsp;x&nbsp;rest<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">In fact, Haskell's <a href="http://hackage.haskell.org/package/base">base</a> library contains a similar function, <code>lookup</code>. However, since it returns a result that is wrapped in a <code>Maybe</code> constructor, we can unwrap it using, e.g.:</span>
        
<div class="code"><div class="source"><br/>unwrap&nbsp;::&nbsp;Maybe&nbsp;Integer&nbsp;->&nbsp;Integer<br/>unwrap&nbsp;(Just&nbsp;n)&nbsp;=&nbsp;n<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
      </div></div></div>
<a name="a97e8ebd22174a6bae403a96c4511c67"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#a97e8ebd22174a6bae403a96c4511c67">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">Suppose we want to represent our own totally ordered set. For example, suppose we have the following data type for representing a discrete subset of the color spectrum:</span>
        
<div class="code"><div class="source"><br/><span class="keyword">data</span>&nbsp;Color&nbsp;=&nbsp;Red&nbsp;|&nbsp;Green&nbsp;|&nbsp;Blue<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">Since <code>Red</code> has the lowest frequency and <code>Blue</code> has the highest frequency, we can define an ordering on all instances of this data type by making the <code>Color</code> type a member of the <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html"><code>Ord</code></a> type class. Note that we could use wildcards (<code>_</code>) to make the definition more concise.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">instance</span>&nbsp;Ord&nbsp;Color&nbsp;<span class="keyword">where</span><br/>&nbsp;&nbsp;Red&nbsp;&nbsp;&nbsp;<=&nbsp;Red&nbsp;&nbsp;&nbsp;=&nbsp;True<br/>&nbsp;&nbsp;Red&nbsp;&nbsp;&nbsp;<=&nbsp;Green&nbsp;=&nbsp;True<br/>&nbsp;&nbsp;Red&nbsp;&nbsp;&nbsp;<=&nbsp;Blue&nbsp;&nbsp;=&nbsp;True<br/>&nbsp;&nbsp;Green&nbsp;<=&nbsp;Green&nbsp;=&nbsp;True<br/>&nbsp;&nbsp;Green&nbsp;<=&nbsp;Blue&nbsp;&nbsp;=&nbsp;True<br/>&nbsp;&nbsp;Blue&nbsp;&nbsp;<=&nbsp;Blue&nbsp;&nbsp;=&nbsp;True<br/>&nbsp;&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<=&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;False<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">It is now possible to use the built-in operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> to compare colors, as well as library functions such as <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#v:max"><code>max :: Color -> Color -> Color</code></a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#v:min"><code>min :: Color -> Color -> Color</code></a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#v:maximum"><code>maximum :: [Color] -> Color</code></a>, and <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#v:minimum"><code>minimum :: [Color] -> Color</code></a>.</span>
      </div></div></div>
<a name="21ae535d73b54e0283c6bec5cecb8565"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#21ae535d73b54e0283c6bec5cecb8565">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">Suppose we have a data type that allows us to build trees that contain integer constants in their leaves.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">data</span>&nbsp;IntegerTree&nbsp;=&nbsp;Node&nbsp;IntegerTree&nbsp;IntegerTree&nbsp;|&nbsp;Leaf&nbsp;Integer<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">We can define a recursive function that assembles all the integers in the leaves in a single list.</span>
        
<div class="code"><div class="source"><br/>ints&nbsp;::&nbsp;IntegerTree&nbsp;->&nbsp;[Integer]<br/>ints&nbsp;(Node&nbsp;t1&nbsp;t2)&nbsp;=&nbsp;ints&nbsp;t1&nbsp;++&nbsp;ints&nbsp;t2<br/>ints&nbsp;(Leaf&nbsp;n&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;=&nbsp;[n]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
      </div></div></div>
<a name="35e16e3052bf4683856ee61eda628366"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#35e16e3052bf4683856ee61eda628366">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">Suppose we want to write a function that composes two functions on integers. We might define a type synonym for such functions:</span>
        
<div class="code"><div class="source"><br/>type&nbsp;Function&nbsp;=&nbsp;Integer&nbsp;->&nbsp;Integer<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">We then know that one possible type for a composition function might be as follows (it takes two function arguments, and returns a new composed function as a result):</span>
        
<div class="code"><div class="source"><br/>compose&nbsp;::&nbsp;Function&nbsp;->&nbsp;Function&nbsp;->&nbsp;Function<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">However, how do we actually implement <code>compose</code>?</span>
        
<div class="code"><div class="source"><br/>compose&nbsp;f&nbsp;g&nbsp;=&nbsp;?<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">To understand how we can do so, we must first expand the type of <code>compose</code>; let's substitute one the right-most <code>Function</code> synonym with its definition:</span>
        
<div class="code"><div class="source"><br/>compose&nbsp;::&nbsp;Function&nbsp;->&nbsp;Function&nbsp;->&nbsp;(Integer&nbsp;->&nbsp;Integer)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">Now recall that the <code>-&gt;</code> type operator is right-associative; this means we can remove the right-most set of parentheses without changing the meaning of the type:</span>
        
<div class="code"><div class="source"><br/>compose&nbsp;::&nbsp;Function&nbsp;->&nbsp;Function&nbsp;->&nbsp;Integer&nbsp;->&nbsp;Integer<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">It is now clear how to implement <code>compose</code>: it takes two <code>Function</code> arguments, and one <code>Integer</code> argument:</span>
        
<div class="code"><div class="source"><br/>compose&nbsp;::&nbsp;Function&nbsp;->&nbsp;Function&nbsp;->&nbsp;Integer&nbsp;->&nbsp;Integer<br/>compose&nbsp;f&nbsp;g&nbsp;x&nbsp;=&nbsp;f(g(x))<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">Note that this function is already available in the Haskell <a href="http://hackage.haskell.org/package/base">base</a> library, and it is called <code>(.)</code>. So we could also have defined <code>compose</code> as follows:</span>
        
<div class="code"><div class="source"><br/>compose&nbsp;::&nbsp;Function&nbsp;->&nbsp;Function&nbsp;->&nbsp;Function<br/>compose&nbsp;f&nbsp;g&nbsp;=&nbsp;f&nbsp;.&nbsp;g<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">The above is an example of <a href="http://en.wikipedia.org/wiki/Tacit_programming"><i>point-free</i></a> programming, because we never explicitly gave names to the individual inputs (i.e., "points") on which the functions operate.</span>
      </div></div></div></div>
  <a name="7.12"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#7.12">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.12.</span> Modeling and exploring state spaces in a typed declarative/functional language</h3>
<span class="text">In many artificial intelligence and optimization problems, the collection of possible actions an algorithm, agent, or player can take can be modelled as a state space tree or graph (also sometimes called a decision tree or decision graph) which may or may not be infinite, depending on the length of the process or game being modeled. Algebraic data types and lazy evaluation make it easy to model such graphs.</span>
<a name="472f945cb582464b91a86bd814acade5"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#472f945cb582464b91a86bd814acade5">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">Suppose we want to model a <a href="http://en.wikipedia.org/wiki/Tic-tac-toe">Tic-tac-toe</a> game, with the eventual goal of writing an AI algorithm that can play the game well. We can first settle on a representation for the board.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">data</span>&nbsp;Cell&nbsp;=&nbsp;E&nbsp;|&nbsp;X&nbsp;|&nbsp;O&nbsp;<span class="keyword">deriving</span>&nbsp;(Eq,&nbsp;Show)<br/><span class="keyword">type</span>&nbsp;Pos&nbsp;=&nbsp;(Integer,&nbsp;Integer)<br/><span class="keyword">data</span>&nbsp;Board&nbsp;=&nbsp;Board&nbsp;[(Pos,&nbsp;Cell)]&nbsp;<span class="keyword">deriving</span>&nbsp;Eq<br/><br/><span class="keyword">instance</span>&nbsp;Show&nbsp;Board&nbsp;<span class="keyword">where</span><br/>&nbsp;&nbsp;show&nbsp;(Board&nbsp;pcs)&nbsp;=&nbsp;show&nbsp;[c&nbsp;|&nbsp;(p,c)&nbsp;<-&nbsp;pcs]<br/><br/>start&nbsp;::&nbsp;Board<br/>start&nbsp;=&nbsp;Board&nbsp;[((r,c),E)&nbsp;|&nbsp;r&nbsp;<-&nbsp;[1..3],&nbsp;c&nbsp;<-&nbsp;[1..3]]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">Notice that the starting board consists of all empty cells.</span>
        
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;start<br/>[E,E,E,E,E,E,E,E,E]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">When a player moves, they place an <code>X</code> or <code>O</code> somewhere on the board. We can model this using a function that, given a move, transforms one board into another board. We use a list comprehension that updates only the cell with the corresponding position.</span>
        
<div class="code"><div class="source"><br/>move&nbsp;::&nbsp;((Pos,&nbsp;Cell),&nbsp;Board)&nbsp;->&nbsp;Board<br/>move&nbsp;((pos',&nbsp;cell'),&nbsp;Board&nbsp;pcs)&nbsp;=&nbsp;Board&nbsp;[(pos,&nbsp;<span class="keyword">if</span>&nbsp;pos'&nbsp;==&nbsp;pos&nbsp;<span class="keyword">then</span>&nbsp;cell'&nbsp;<span class="keyword">else</span>&nbsp;cell)&nbsp;|&nbsp;(pos,&nbsp;cell)&nbsp;<-&nbsp;pcs]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">Suppose we want to make a state space graph that captures all possible paths a Tic-tac-toe game can take from a given starting position, and given a player's current turn. Let us assume that turns can be modelled using an infinite list. For example, here is an infinite list for game in which the <code>X</code> and <code>O</code> players take alternating turns.</span>
        
<div class="code"><div class="source"><br/>turns&nbsp;::&nbsp;[Cell]<br/>turns&nbsp;=&nbsp;X:O:turns<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">We first define a data structure for representing the possible paths a game can take. The data structure is a tree graph in which each node represents a game state (i.e., a <code>Board</code>), and can have any number of child trees (including zero).</span>
        
<div class="code"><div class="source"><br/><span class="keyword">data</span>&nbsp;DecisionTree&nbsp;=&nbsp;Move&nbsp;Board&nbsp;[DecisionTree]&nbsp;<span class="keyword">deriving</span>&nbsp;(Eq,&nbsp;Show)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div> 
        
<span class="text">Now, we can define a function that builds a decision tree given a starting game state and the player turn sequence. Notice that <code>nextMoves</code> takes a <code>Board</code> and a <code>Cell</code> (to indicate which player is taking a turn), and uses a list comprehension to choose only the board cells that are empty. For each empty cell, it adds a new board state to the list in which that position is filled with the specified player's symbol.</span>
        
<div class="code"><div class="source"><br/>nextMoves&nbsp;::&nbsp;(Board,&nbsp;Cell)&nbsp;->&nbsp;[Board]<br/>nextMoves&nbsp;(Board&nbsp;pcs,&nbsp;cell)&nbsp;=&nbsp;[move&nbsp;((p,&nbsp;cell),&nbsp;Board&nbsp;pcs)&nbsp;|&nbsp;(p,&nbsp;E)&nbsp;<-&nbsp;pcs]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div> 
        
<span class="text">Given a starting board and turn sequence, we can now build the tree of state spaces for the entire game.</span>
        
<div class="code"><div class="source"><br/>tree&nbsp;::&nbsp;Board&nbsp;->&nbsp;[Cell]&nbsp;->&nbsp;DecisionTree<br/>tree&nbsp;b&nbsp;(turn:turns)&nbsp;=&nbsp;Move&nbsp;b&nbsp;[tree&nbsp;b'&nbsp;turns&nbsp;|&nbsp;b'&nbsp;<-&nbsp;nextMoves&nbsp;(b,&nbsp;turn)]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">Suppose we have a function <code>win :: Cell -> Board -> Bool</code> that checks if a given board is already a win for a particular player. We can then add an <code>Ord</code> instance to compare boards from player <code>X</code>'s perspective: a board is "greater" (or "better") than another board if either the board is a win for <code>X</code>, or the other board is a loss for <code>O</code>.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">instance</span>&nbsp;Ord&nbsp;Board&nbsp;<span class="keyword">where</span><br/>&nbsp;&nbsp;b&nbsp;<=&nbsp;b'&nbsp;=&nbsp;win&nbsp;b'&nbsp;X&nbsp;||&nbsp;win&nbsp;b&nbsp;O<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">It is now possible to use the built-in operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> to compare boards, as well as library functions such as <code>max :: Board -> Board -> Board</code> and <code>maximum :: [Board] -> Board</code> to choose the "best" boards.</span>
      </div></div></div></div><br/><hr/><a name="7.13"></a><a name="assignment5"></a><a name="hw5"></a><div class="assignment"><h3 class="linked"><span class="link-title">[<a href="#7.13">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.13.</span> <span class="assignment_title">Assignment #5: Applications of Declarative and Functional Programming</span></h3><div class="instructions">
In this assignment you will practice using the declarative and functional programming language Haskell by implementing a small interpreter, and by implementing a library of algorithms for solving a particular optimization problem. You must submit two files:
<ul>
  <li><code><a href="hw5/Interpreter.hs">hw5/Interpreter.hs</a></code>;</li>
  <li><code><a href="hw5/Allocation.hs">hw5/Allocation.hs</a></code>.</li>
</ul>
Please follow the <a href="http://www.cs.bu.edu/teaching/hw/gsubmit/">gsubmit</a> directions and remember to put your files in the <code>hw5</code> directory.
<br/><br/>
Your solutions to each of the problem parts below will be graded on their correctness, concision, and mathematical legibility. The different problems and problem parts rely on the lecture notes and on each other; carefully consider whether you can use functions from the lecture notes, or functions you define in one part within subsequent parts.
<br/><br/>
<b style="color:green;">A testing script with several test cases is available for download: <a href="a5-tests.hs"><code>a5-tests.hs</code></a>. You should be able to place it in the same directory with the other assignment files and load it. Feel free to modify or extend it as you see fit.</b>
<!--<br/><br/>
<b style="color:green;">A full solution to this assignment is now available here: <a href="hw5/solutions/"><code>/hw5/solutions</code></a>.</b>
-->
      
      </div><ol class="problems"><li class="problem">
<span class="text">In this problem you will implement an interpreter for a small programming language. Your solutions should be included in the file <code><a href="hw5/Interpreter.hs">hw5/Interpreter.hs</a></code>.</span><ol class="parts"><li class="part">
<span class="text">Implement a function <code>eval :: ([(String, Value)], Exp) -> Value</code> that takes two arguments: an environment data structure of type <code>[(String, Value)]</code> and an expression abstract syntax tree of type <code>Exp</code>. It should return the value that is the result of evaluating the expression abstract syntax tree according to the following operational semantics:</span><div class="inferences"><table class="inference"><tr><td class="title">[Exp-Value]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <i>v</i> &dArr; <i>v</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Exp-Variable]</td><td><table><tr><td class="premises">&nbsp;&Sigma;(<i>x</i>) = <i>v</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <i>x</i> &dArr; <i>v</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Exp-Plus]</td><td><table><tr><td class="premises">&nbsp;&Sigma;, <i>e</i><sub>1</sub> &dArr; <i>n</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;, <i>e</i><sub>2</sub> &dArr; <i>n</i><sub>2</sub>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <b>Plus</b> <i>e</i><sub>1</sub> <i>e</i><sub>2</sub> &dArr; <i>n</i><sub>1</sub> + <i>n</i><sub>2</sub>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Exp-Not]</td><td><table><tr><td class="premises">&nbsp;&Sigma;, <i>e</i> &dArr; <i>v</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <b>Not</b> <i>e</i> &dArr; &not; <i>v</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Exp-And]</td><td><table><tr><td class="premises">&nbsp;&Sigma;, <i>e</i><sub>1</sub> &dArr; <i>v</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;, <i>e</i><sub>2</sub> &dArr; <i>v</i><sub>2</sub>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <b>And</b> <i>e</i><sub>1</sub> <i>e</i><sub>2</sub> &dArr; <i>v</i><sub>1</sub> &and; <i>v</i><sub>2</sub>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Exp-Or]</td><td><table><tr><td class="premises">&nbsp;&Sigma;, <i>e</i><sub>1</sub> &dArr; <i>v</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;, <i>e</i><sub>2</sub> &dArr; <i>v</i><sub>2</sub>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <b>Or</b> <i>e</i><sub>1</sub> <i>e</i><sub>2</sub> &dArr; <i>v</i><sub>1</sub> &or; <i>v</i><sub>2</sub>&nbsp;</td></tr></table></td></tr></table></div>
<span class="text">A few example queries are provided below.</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;eval&nbsp;([],&nbsp;Plus&nbsp;(Value&nbsp;(Number&nbsp;1))&nbsp;(Value&nbsp;(Number&nbsp;2)))<br/>Number&nbsp;3<br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;eval&nbsp;([(<span class="literal">"x"</span>,T),(<span class="literal">"y"</span>,F)],&nbsp;And&nbsp;(Var&nbsp;<span class="literal">"x"</span>)&nbsp;(Or&nbsp;(Value&nbsp;T)&nbsp;(Var&nbsp;<span class="literal">"y"</span>)))<br/>T<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li><li class="part">
<span class="text">Implement a function <code>exec :: ([(String, Value)], Stmt) -> Output</code> that takes two arguments: an environment data structure of type <code>[(String, Value)]</code> and a statement abstract syntax tree of type <code>Stmt</code>. It should return the output that is the result of executing the statement abstract syntax tree according to the following operational semantics:</span><div class="inferences"><table class="inference"><tr><td class="title">[Statement-Assign]</td><td><table><tr><td class="premises">&nbsp;&Sigma; &#8846; {<i>x</i> &#x21A6; <i>v</i>}, <i>p</i> &dArr; <i>o</i> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;, <i>e</i> &dArr; <i>v</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <b>Assign</b> <i>x</i> <i>e</i> <i>p</i> &dArr; <i>o</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-Print]</td><td><table><tr><td class="premises">&nbsp;&Sigma;, <i>p</i> &dArr; <i>o</i> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &Sigma;, <i>e</i> &dArr; <i>v</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <b>Print</b> <i>e</i> <i>p</i> &dArr; <i>v</i>;<i>o</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Statement-End]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&Sigma;, <b>End</b> &dArr; <i>o</i><sub>0</sub>&nbsp;</td></tr></table></td></tr></table></div></li><li class="part">
<span class="text">To make it easier to define abstract syntax trees for this language within Haskell, add instance declarations so that it is possible to build expressions of type <code>Exp</code> by using the built-in Haskell infix operator <code>+</code> instead of the constructor <code>Plus</code>, and by using numeric literals such as <code>123</code> instead of <code>Number 123</code>.</span></li></ol></li><li class="problem">
<span class="text">In this problem, you will implement a small library for representing and working with a state space graph for an optimization problem. All the functions you define should be included in the file <code><a href="hw5/Allocation.hs">hw5/Allocation.hs</a></code>.
<br/><br/>
The optimization problem we are addressing is defined as follows: given a list of items, each of a certain integer size, put each item into one of two bins so that once all items have been allocated, the sum of the sizes of the items in the first bin is as close as possible to the sum of the items in the second bin (note that this optimization problem is NP-complete and is equivalent to the <a href="http://en.wikipedia.org/wiki/Subset_sum_problem">subset sum problem</a>, so no efficient solution for the problem is believed to exist).</span><ol class="parts"><li class="part">
<span class="text">We will represent an allocation of items (either in the midst of running an optimization algorithm or within a final result) using the data type <code>Alloc</code>:</span>
<div class="code"><div class="source"><br/><span class="keyword">data</span>&nbsp;Alloc&nbsp;=&nbsp;Alloc&nbsp;Bin&nbsp;Bin&nbsp;<span class="keyword">deriving</span>&nbsp;(Eq,&nbsp;Show)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">We will represent the graph of possible states that an algorithm can traverse given a starting allocation and a list of tasks using the <code>Graph</code> data type:</span>
<div class="code"><div class="source"><br/><span class="keyword">data</span>&nbsp;Graph&nbsp;=<br/>&nbsp;&nbsp;&nbsp;&nbsp;Branch&nbsp;Alloc&nbsp;Graph&nbsp;Graph&nbsp;<br/>&nbsp;&nbsp;|&nbsp;Finish&nbsp;Alloc<br/>&nbsp;&nbsp;<span class="keyword">deriving</span>&nbsp;(Eq,&nbsp;Show)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">Define a function <code>graph :: Alloc -> [Item] -> Graph</code> that takes a starting allocation and a list of items, and returns the full graph of all possible state space traversals available to an algorithm given the list of items. An example is provided below (spacing has been adjusted for legibility):</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;graph&nbsp;(Alloc&nbsp;0&nbsp;0)&nbsp;[1,2]<br/>Branch&nbsp;(Alloc&nbsp;0&nbsp;0)&nbsp;<br/>&nbsp;&nbsp;(Branch&nbsp;(Alloc&nbsp;1&nbsp;0)&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;(Finish&nbsp;(Alloc&nbsp;3&nbsp;0))&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;(Finish&nbsp;(Alloc&nbsp;1&nbsp;2))<br/>&nbsp;&nbsp;)<br/>&nbsp;&nbsp;(Branch&nbsp;(Alloc&nbsp;0&nbsp;1)&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;(Finish&nbsp;(Alloc&nbsp;2&nbsp;1))&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;(Finish&nbsp;(Alloc&nbsp;0&nbsp;3))<br/>&nbsp;&nbsp;)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">The definition must work even if the supplied list of items is infinite.</span></li><li class="part">
<span class="text">Define a function <code>alloc :: Graph -> Alloc</code> that makes it easy to retrieve the allocation within the root node of a particular graph of type <code>Graph</code>.</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;alloc&nbsp;(Finish&nbsp;(Alloc&nbsp;0&nbsp;0))<br/>Alloc&nbsp;0&nbsp;0<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li><li class="part">
<span class="text">One allocation <code>a :: Alloc</code> is <i>better</i> than another allocation <code>b :: Alloc</code> if the difference between the two bin totals in <code>a</code> is less than the difference between the two bin totals in <code>b</code>. Add an instance declaration for the <code>Alloc</code> type so that it is possible to use the built-in Haskell infix operators <code>&lt;</code> and <code>&lt;=</code> to compare two allocations according to their differences. You may use the Haskell library function <code>abs :: Integer -> Integer</code> to compute the absolute value of an integer. <b style="color:green;">If you're getting a stack overflow when testing <code>&lt;</code>, make sure you also define <code>&lt;=</code> explicitly.</b></span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;(Alloc&nbsp;1&nbsp;4)&nbsp;<&nbsp;(Alloc&nbsp;5&nbsp;10)<br/>True<br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;(Alloc&nbsp;10&nbsp;4)&nbsp;<&nbsp;(Alloc&nbsp;1&nbsp;3)<br/>False<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li><li class="part">
<span class="text">One graph <code>g :: Graph</code> is <i>better</i> than another graph <code>g' :: Graph</code> if the difference between the two bin totals in the root node of <code>g</code> is less than the difference between the two bin totals in the root node of <code>g'</code>. Add an instance declaration for the <code>Graph</code> type so that it is possible to use the built-in Haskell infix operator <code>&lt;</code> to compare two graphs.</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;(Finish&nbsp;(Alloc&nbsp;1&nbsp;4))&nbsp;<&nbsp;(Finish&nbsp;(Alloc&nbsp;5&nbsp;10))<br/>True<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li><li class="part">
<span class="text">Define a function <code>final :: Graph -> [Alloc]</code> that returns an aggregate list of the allocations within <i>all</i> the leaf nodes of the supplied state space graph.</span></li><li class="part">
<span class="text">Define a function <code>depth :: Integer -> Graph -> [Alloc]</code> that returns the allocations within the state space graph nodes that are at depth exactly <code>n</code> within the state space graph (the root node is at depth <code>0</code>).</span></li></ol></li><li class="problem">
<span class="text">In this problem, you will implement a small library of algorithms for solving the optimization problem we defined above. All the functions you define should be included in the file <code><a href="hw5/Allocation.hs">hw5/Allocation.hs</a></code>.
<br/><br/>
A <i>strategy</i> is an algorithm that can traverse the state space graph; given an existing graph, it chooses some descendant node in the graph and returns the subgraph for which that descendant node is the root.</span>
<div class="code"><div class="source"><br/><span class="keyword">type</span>&nbsp;Strategy&nbsp;=&nbsp;Graph&nbsp;->&nbsp;Graph<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div><ol class="parts"><li class="part">
<span class="text">Define a strategy <code>greedy :: Strategy</code> that takes a graph as an input. It should choose and return the <i>better</i> child of the two children of the root of the graph.</span></li><li class="part">
<span class="text">Define a strategy <code>patient :: Integer -> Strategy</code> that takes an integer argument <code>n</code> and a graph as its two inputs, and chooses and returns the <i>best</i> descendant of the supplied graph that can be found at depth <code>n</code> (an allocation is <i>best</i> if it is better than all others at that depth). If <code>n</code> is <code>0</code>, the function should simply return the graph supplied to it as an input.</span></li><li class="part">
<span class="text">Define a strategy <code>optimal :: Strategy</code> that takes a state space graph, and returns the leaf node in the state space graph that has the <i>best</i> allocation. <b>Hint:</b> you can define this function in two lines; look carefully over the functions already available to you, and think recursively.</span></li><li class="part">
<span class="text">Define a metastrategy <code>metaCompose :: Strategy -> Strategy -> Strategy</code> that takes two strategies as arguments. It should apply the first strategy to obtain a new subgraph, and then it should apply the second strategy to that subgraph and return the result.</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;(metaCompose&nbsp;greedy&nbsp;greedy)&nbsp;(graph&nbsp;(Alloc&nbsp;0&nbsp;0)&nbsp;[1,2,3])<br/>Branch&nbsp;(Alloc&nbsp;2&nbsp;1)&nbsp;(Finish&nbsp;(Alloc&nbsp;5&nbsp;1))&nbsp;(Finish&nbsp;(Alloc&nbsp;2&nbsp;4))<br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;(metaCompose&nbsp;(patient&nbsp;2)&nbsp;greedy)&nbsp;(graph&nbsp;(Alloc&nbsp;0&nbsp;0)&nbsp;[1,2,3,4])<br/>Branch&nbsp;(Alloc&nbsp;2&nbsp;4)&nbsp;(Finish&nbsp;(Alloc&nbsp;6&nbsp;4))&nbsp;(Finish&nbsp;(Alloc&nbsp;2&nbsp;8))<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li><li class="part">
<span class="text">Define a metastrategy <code>metaRepeat :: Integer -> Strategy -> Strategy</code> that repeats a given strategy a specified number of times. Your definition of <code>metaRepeat</code> should take an <code>Integer</code> and a <code>Graph</code> argument. If the integer is <code>0</code>, it should simply return the graph unchanged. If the integer is positive, it should apply the strategy the specified number of times to the graph and then return the result.</span></li><li class="part">
<span class="text">Define a metastrategy <code>metaGreedy :: Strategy -> Strategy -> Strategy</code> that takes two strategies as its inputs. It should apply the two strategies to its input graph and should return the <i>better</i> of the two results that it obtains.</span></li><li class="part">
<span class="text">Consider the following strategy:</span>
<div class="code"><div class="source"><br/>impatient&nbsp;::&nbsp;Integer&nbsp;->&nbsp;Strategy<br/>impatient&nbsp;n&nbsp;g&nbsp;=&nbsp;(metaRepeat&nbsp;n&nbsp;greedy)&nbsp;g<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">Describe one way in which <code>impatient</code> is superior to <code>patient</code>, and one way in which it is inferior.</span></li></ol></li><li class="problem">
<span class="text"><b>Extra credit:</b> Define a metastrategy <code>fit :: Graph -> [Strategy] -> Strategy</code> that takes a graph and a list of strategies as inputs; this metastrategy should choose the strategy in the list of strategies that has the best performance on the given graph, and return it. <b>Hint:</b> define a way to compare strategies and use <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-List.html#v:minimumBy"><code>minimumBy</code></a>.</span></li></ol>
</div><hr/><br/>
  <a name="7.14"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#7.14">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.14.</span> Ad Hoc and Parametric Polymorphism</h3>
<a name="7065360f071a42b1b02e4cb7b73caee8"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#7065360f071a42b1b02e4cb7b73caee8">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="definition_required"><b>Definition:</b> 
A language supports <i>ad hoc polymorphism</i> if it allows programmers to specify multiple definitions for the same constant or variable (which could be a literal, an operator symbol, a function name, a type, and so on). An interpreter or compiler then choose the appropriate definition to use based on the context (usually, the types of the argument expressions and/or the surrounding expressions and statements in the abstract syntax tree). Ad hoc polymorphism usually allows programmers
<br/><br/>
Common examples of language features that support ad hoc polymorphism include operator overloading in C++, C#, and Python (operator overloading is not supported in Java), method overloading in Java subclasses, Java interfaces, and type classes in Haskell.
      </div></div></div>
<a name="e9497e2275f347cbbc569f810cb58c2d"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#e9497e2275f347cbbc569f810cb58c2d">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="definition_required"><b>Definition:</b> 
A language supports <i>parametric polymorphism</i> if it allows programmers to specify a single definition for a function or procedure that can then be applied to values of multiple types (typically, a large range of types, or even all types). Typically, the function or procedure will operate on a container type, or some other parameterized or generic type. Thus, languages that support parametric polymorphism usually allow programmers to define data structures that can be parameterized by other data structures. 
<br/><br/>
Common examples of language features that support parametric polymorphism include Java generics and the Haskell type system (the latter uses an extension of the <a href="http://en.wikipedia.org/wiki/Hindley-Milner_type_system">Hindley-Milner type inference algorithm</a> that is also used by the programming language <a href="http://en.wikipedia.org/wiki/ML_(programming_language)">ML</a>).
      </div></div></div>
<span class="text">Note an important distinction between ad hoc polymorphism and parametric polymorphism: ad hoc polymorphism allows programmers to continue adding new definitions for a given variable or constant within the same scope, while parametric polymorphism only permits a single, albeit generic, definition for a function or procedure within any given scope.</span>
<a name="b8adf3fedafc40648a90e89dcce10f8c"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#b8adf3fedafc40648a90e89dcce10f8c">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">We can define a <code>Set</code> data structure for holding sets of <code>Integer</code> values that has an underlying list implementation.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">module</span>&nbsp;IntegerSet&nbsp;<span class="keyword">where</span><br/>&nbsp;&nbsp;<br/><span class="keyword">data</span>&nbsp;Set&nbsp;=<br/>&nbsp;&nbsp;&nbsp;&nbsp;Empty<br/>&nbsp;&nbsp;|&nbsp;Set&nbsp;[Integer]<br/>&nbsp;&nbsp;<span class="keyword">deriving</span>&nbsp;Show&nbsp;&nbsp;&nbsp;<br/>&nbsp;<br/>insert&nbsp;::&nbsp;Set&nbsp;->&nbsp;Integer&nbsp;->&nbsp;Set<br/>insert&nbsp;(Set&nbsp;l)&nbsp;x&nbsp;=&nbsp;Set&nbsp;(x:l)<br/>insert&nbsp;(Empty)&nbsp;x&nbsp;=&nbsp;Set&nbsp;[x]<br/><br/>contains&nbsp;::&nbsp;Integer&nbsp;->&nbsp;Set&nbsp;->&nbsp;Bool<br/>contains&nbsp;x&nbsp;(Empty)&nbsp;=&nbsp;False<br/>contains&nbsp;x&nbsp;(Set&nbsp;l)&nbsp;=&nbsp;x&nbsp;`elem`&nbsp;l<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">However, what if we also want user to have the option of using a data structure for sets that uses an underlying binary search tree implementation? We can first define a class for set data structures that specifies the signatures of the functions that a set data structure must support. We can even define new functions that rely only on the signature.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">module</span>&nbsp;SetClass&nbsp;<span class="keyword">where</span><br/><br/><span class="keyword">class</span>&nbsp;IsSet&nbsp;s&nbsp;<span class="keyword">where</span><br/>&nbsp;&nbsp;empty&nbsp;::&nbsp;s<br/>&nbsp;&nbsp;insert&nbsp;::&nbsp;s&nbsp;->&nbsp;Integer&nbsp;->&nbsp;s<br/>&nbsp;&nbsp;contains&nbsp;::&nbsp;Integer&nbsp;->&nbsp;s&nbsp;->&nbsp;Bool<br/>&nbsp;&nbsp;<br/>&nbsp;&nbsp;inserts&nbsp;::&nbsp;s&nbsp;->&nbsp;[Integer]&nbsp;->&nbsp;s<br/>&nbsp;&nbsp;inserts&nbsp;s&nbsp;(x:xs)&nbsp;=&nbsp;inserts&nbsp;(insert&nbsp;s&nbsp;x)&nbsp;xs<br/>&nbsp;&nbsp;inserts&nbsp;s&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;s<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">This makes it possible to provide two different implementations that are both members of this class.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">module</span>&nbsp;IntegerSetList&nbsp;<span class="keyword">where</span><br/><br/><span class="keyword">import</span>&nbsp;SetClass<br/>&nbsp;&nbsp;<br/><span class="keyword">data</span>&nbsp;IntegerSetList&nbsp;=<br/>&nbsp;&nbsp;&nbsp;&nbsp;Empty<br/>&nbsp;&nbsp;|&nbsp;Set&nbsp;[Integer]<br/>&nbsp;&nbsp;<span class="keyword">deriving</span>&nbsp;Show&nbsp;&nbsp;&nbsp;<br/><br/><span class="keyword">instance</span>&nbsp;IsSet&nbsp;IntegerSetList&nbsp;<span class="keyword">where</span><br/>&nbsp;&nbsp;empty&nbsp;=&nbsp;Empty<br/><br/>&nbsp;&nbsp;insert&nbsp;(Set&nbsp;l)&nbsp;x&nbsp;=&nbsp;Set&nbsp;(x:l)<br/>&nbsp;&nbsp;insert&nbsp;(Empty)&nbsp;x&nbsp;=&nbsp;Set&nbsp;[x]<br/><br/>&nbsp;&nbsp;contains&nbsp;x&nbsp;(Empty)&nbsp;=&nbsp;False<br/>&nbsp;&nbsp;contains&nbsp;x&nbsp;(Set&nbsp;l)&nbsp;=&nbsp;x&nbsp;`elem`&nbsp;l<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<div class="code"><div class="source"><br/><span class="keyword">module</span>&nbsp;IntegerSetTree&nbsp;<span class="keyword">where</span><br/><br/><span class="keyword">import</span>&nbsp;SetClass<br/><br/><span class="keyword">data</span>&nbsp;IntegerSetTree&nbsp;=<br/>&nbsp;&nbsp;&nbsp;&nbsp;Leaf<br/>&nbsp;&nbsp;|&nbsp;Node&nbsp;Integer&nbsp;IntegerSetTree&nbsp;IntegerSetTree<br/>&nbsp;&nbsp;<span class="keyword">deriving</span>&nbsp;Show&nbsp;&nbsp;&nbsp;<br/><br/><span class="keyword">instance</span>&nbsp;IsSet&nbsp;IntegerSetTree&nbsp;<span class="keyword">where</span><br/>&nbsp;&nbsp;empty&nbsp;=&nbsp;Leaf<br/><br/>&nbsp;&nbsp;insert&nbsp;(Leaf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;x&nbsp;=&nbsp;Node&nbsp;x&nbsp;Leaf&nbsp;Leaf<br/>&nbsp;&nbsp;insert&nbsp;(Node&nbsp;y&nbsp;s&nbsp;s')&nbsp;x&nbsp;=<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;x&nbsp;<&nbsp;y&nbsp;<span class="keyword">then</span>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&nbsp;y&nbsp;(insert&nbsp;s&nbsp;x)&nbsp;s'&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&nbsp;y&nbsp;s&nbsp;(insert&nbsp;s'&nbsp;x)<br/><br/>&nbsp;&nbsp;contains&nbsp;x&nbsp;(Leaf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;=&nbsp;False<br/>&nbsp;&nbsp;contains&nbsp;x&nbsp;(Node&nbsp;y&nbsp;s&nbsp;s')&nbsp;=<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;y&nbsp;==&nbsp;x&nbsp;<span class="keyword">then</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;True<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;<span class="keyword">if</span>&nbsp;x&nbsp;<&nbsp;y&nbsp;<span class="keyword">then</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contains&nbsp;x&nbsp;s<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contains&nbsp;x&nbsp;s'<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
      </div></div></div>
<span class="text">Haskell type classes need not contain types; they can also contain type constructors (i.e., functions in the type system that can be used to construct a type given a type, i.e., type constructors with kind <code>Type -> Type</code>, and so on).</span>
<a name="1dade7b3338943cebc188d3b4b9890ba"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#1dade7b3338943cebc188d3b4b9890ba">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">We can define a <code>Set</code> data structure for holding sets of values of any type <code>a</code>.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">module</span>&nbsp;Set&nbsp;<span class="keyword">where</span><br/>&nbsp;&nbsp;<br/><span class="keyword">data</span>&nbsp;Set&nbsp;a&nbsp;=<br/>&nbsp;&nbsp;&nbsp;&nbsp;Empty<br/>&nbsp;&nbsp;|&nbsp;Set&nbsp;[a]<br/>&nbsp;&nbsp;<span class="keyword">deriving</span>&nbsp;Show&nbsp;&nbsp;&nbsp;<br/>&nbsp;<br/>insert&nbsp;::&nbsp;Set&nbsp;a&nbsp;->&nbsp;a&nbsp;->&nbsp;Set&nbsp;a<br/>insert&nbsp;(Set&nbsp;l)&nbsp;x&nbsp;=&nbsp;Set&nbsp;(x:l)<br/>insert&nbsp;(Empty)&nbsp;x&nbsp;=&nbsp;Set&nbsp;[x]<br/><br/>contains&nbsp;::&nbsp;Eq&nbsp;a&nbsp;=>&nbsp;a&nbsp;->&nbsp;Set&nbsp;a&nbsp;->&nbsp;Bool<br/>contains&nbsp;x&nbsp;(Empty)&nbsp;=&nbsp;False<br/>contains&nbsp;x&nbsp;(Set&nbsp;l)&nbsp;=&nbsp;x&nbsp;`elem`&nbsp;l<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">However, what if we also want user to have the option of using a data structure for sets that uses an underlying binary search tree implementation? We can first define a class for set data structures that specifies the signatures of the functions that a set data structure must support. We can even define new functions that rely only on the signature.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">module</span>&nbsp;SetClass&nbsp;<span class="keyword">where</span><br/><br/><span class="keyword">class</span>&nbsp;IsSet&nbsp;s&nbsp;<span class="keyword">where</span><br/>&nbsp;&nbsp;empty&nbsp;::&nbsp;s&nbsp;a<br/>&nbsp;&nbsp;insert&nbsp;::&nbsp;s&nbsp;a&nbsp;->&nbsp;a&nbsp;->&nbsp;s&nbsp;a<br/>&nbsp;&nbsp;contains&nbsp;::&nbsp;Eq&nbsp;a&nbsp;=>&nbsp;a&nbsp;->&nbsp;s&nbsp;a&nbsp;->&nbsp;Bool<br/>&nbsp;&nbsp;<br/>&nbsp;&nbsp;inserts&nbsp;::&nbsp;s&nbsp;a&nbsp;->&nbsp;[a]&nbsp;->&nbsp;s&nbsp;a<br/>&nbsp;&nbsp;inserts&nbsp;s&nbsp;(x:xs)&nbsp;=&nbsp;inserts&nbsp;(insert&nbsp;s&nbsp;x)&nbsp;xs<br/>&nbsp;&nbsp;inserts&nbsp;s&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;s<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">This makes it possible to provide two different implementations of polymorphic set data structures that are both members of this class.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">module</span>&nbsp;SetList&nbsp;<span class="keyword">where</span><br/><br/><span class="keyword">import</span>&nbsp;SetClass<br/>&nbsp;&nbsp;<br/><span class="keyword">data</span>&nbsp;SetList&nbsp;a&nbsp;=<br/>&nbsp;&nbsp;&nbsp;&nbsp;Empty<br/>&nbsp;&nbsp;|&nbsp;Set&nbsp;[a]<br/>&nbsp;&nbsp;<span class="keyword">deriving</span>&nbsp;Show&nbsp;&nbsp;&nbsp;<br/><br/><span class="keyword">instance</span>&nbsp;IsSet&nbsp;SetList&nbsp;<span class="keyword">where</span><br/>&nbsp;&nbsp;empty&nbsp;=&nbsp;Empty<br/><br/>&nbsp;&nbsp;insert&nbsp;(Set&nbsp;l)&nbsp;x&nbsp;=&nbsp;Set&nbsp;(x:l)<br/>&nbsp;&nbsp;insert&nbsp;(Empty)&nbsp;x&nbsp;=&nbsp;Set&nbsp;[x]<br/><br/>&nbsp;&nbsp;contains&nbsp;x&nbsp;(Empty)&nbsp;=&nbsp;False<br/>&nbsp;&nbsp;contains&nbsp;x&nbsp;(Set&nbsp;l)&nbsp;=&nbsp;x&nbsp;`elem`&nbsp;l<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<div class="code"><div class="source"><br/><span class="keyword">module</span>&nbsp;SetTree&nbsp;<span class="keyword">where</span><br/><br/><span class="keyword">import</span>&nbsp;SetClass<br/><br/><span class="keyword">data</span>&nbsp;SetTree&nbsp;a&nbsp;=<br/>&nbsp;&nbsp;&nbsp;&nbsp;Leaf<br/>&nbsp;&nbsp;|&nbsp;Node&nbsp;Integer&nbsp;(SetTree&nbsp;a)&nbsp;(SetTree&nbsp;a)<br/>&nbsp;&nbsp;<span class="keyword">deriving</span>&nbsp;Show&nbsp;&nbsp;&nbsp;<br/><br/><span class="keyword">instance</span>&nbsp;IsSet&nbsp;SetTree&nbsp;<span class="keyword">where</span><br/>&nbsp;&nbsp;empty&nbsp;=&nbsp;Leaf<br/><br/>&nbsp;&nbsp;insert&nbsp;(Leaf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;x&nbsp;=&nbsp;Node&nbsp;x&nbsp;Leaf&nbsp;Leaf<br/>&nbsp;&nbsp;insert&nbsp;(Node&nbsp;y&nbsp;s&nbsp;s')&nbsp;x&nbsp;=<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;x&nbsp;<&nbsp;y&nbsp;<span class="keyword">then</span>&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&nbsp;y&nbsp;(insert&nbsp;s&nbsp;x)&nbsp;s'&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node&nbsp;y&nbsp;s&nbsp;(insert&nbsp;s'&nbsp;x)<br/><br/>&nbsp;&nbsp;contains&nbsp;x&nbsp;(Leaf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;=&nbsp;False<br/>&nbsp;&nbsp;contains&nbsp;x&nbsp;(Node&nbsp;y&nbsp;s&nbsp;s')&nbsp;=<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;y&nbsp;==&nbsp;x&nbsp;<span class="keyword">then</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;True<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>&nbsp;<span class="keyword">if</span>&nbsp;x&nbsp;<&nbsp;y&nbsp;<span class="keyword">then</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contains&nbsp;x&nbsp;s<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contains&nbsp;x&nbsp;s'<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
      </div></div></div>
<a name="a881f643ee054befa199c31d8d46390a"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#a881f643ee054befa199c31d8d46390a">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">Suppose we have a <code>Set</code> data structure for holding sets of values of any type <code>a</code> that has a corresponding <code>size :: Set a -> Int</code> function.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">module</span>&nbsp;Set&nbsp;<span class="keyword">where</span><br/>&nbsp;&nbsp;<br/><span class="keyword">data</span>&nbsp;Set&nbsp;a&nbsp;=<br/>&nbsp;&nbsp;&nbsp;&nbsp;Empty<br/>&nbsp;&nbsp;|&nbsp;Set&nbsp;[a]<br/>&nbsp;&nbsp;<span class="keyword">deriving</span>&nbsp;(Eq,&nbsp;Show)&nbsp;&nbsp;&nbsp;<br/>&nbsp;<br/>size&nbsp;::&nbsp;Set&nbsp;a&nbsp;->&nbsp;Int<br/>size&nbsp;(Set&nbsp;l)&nbsp;=&nbsp;length&nbsp;l<br/>size&nbsp;(Empty)&nbsp;=&nbsp;0<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">We can make it possible to order sets by their size using the <code>&lt;</code> operator by making the type <code>Set a</code> (for any possible <code>a</code>) a member of the <code>Ord</code> type class.</span>
        
<div class="code"><div class="source"><br/><span class="keyword">instance</span>&nbsp;Eq&nbsp;a&nbsp;=>&nbsp;Ord&nbsp;(Set&nbsp;a)&nbsp;<span class="keyword">where</span><br/>&nbsp;&nbsp;s&nbsp;<&nbsp;s'&nbsp;=&nbsp;size&nbsp;s&nbsp;<&nbsp;size&nbsp;s'<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">Note that the instance declaration is prepended with the condition that the type <code>a</code> must be in the <code>Eq</code> type class. This is because the definition of <code>Set a</code> contains a <code>deriving Eq</code> clause, which means that a type <code>Set a</code> can only be used in a module if the parameter type <code>a</code> is a member of the <code>Eq</code> type class (otherwise, Haskell would not be able to compare two sets for equality using the automatically derived definition of <code>(==)</code> generated by the <code>deriving Eq</code> clause).</span>
      </div></div></div></div>
  <a name="7.15"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#7.15">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.15.</span> Folds, Unfolds, and Algebraic Properties of Functional Programs</h3>
<span class="text">We have seen that the operational semantics of declarative and functional languages support an approach to problem solving that involves first defining a model of some system, and then querying that model to answer questions about that system or explore its properties. We can define this approach to programming with more consistency and mathematical rigor by identifying the mathematical transformations that are typically employed and composed when using this approach. In particular, most component operations fall into two categories:
<ul>
  <li><i><b>unfold</b></i> (or <i>anamorphism</i>) operations are used to define or construct a data value;</li>
  <li><i><b>fold</b></i> (or <i>catamorphism</i>) operations are used to reduce, simplify, break down, or transform a data value.</li>
</ul></span>
<span class="text">A few special cases of the composition of a <b>fold</b> followed by an <b>unfold</b> are commonly used, as well (these are commonly implemented using comprehensions when the data value being transformed is a set or list):</span>
<span class="text"><ul>
  <li><i><b>map</b></i> (sometimes known as <i>metamorphism</i>) operations are used to modify all the components of a data value using a single, often local transformation that is applied to all the components across the entire data value;</li>
  <li><i><b>filter</b></i> operations are used to remove (or select) only some of the components of a data value.</li>
</ul>
<br/>
The ability to describe an algorithm using a composition of <b>unfold</b>, <b>fold</b>, <b>map</b>, and <b>filter</b> operations imposes fewer restrictions on how that computation can be carried out (when compared to a description of the same algorithm using a sequential list of operations). A description using <b>fold</b>, <b>map</b>, and so on may still impose some <i>hierarchical</i> dependencies on the computation, but the operational semantics of such a description allows an implementation (or a compiled version) of the algorithm to perform operations in parallel <i>unless</i> such parallelization is explicitly forbidden by the algorithm itself through explicit sequential dependencies introduced by the programmer. In other words, <b>the default interpretation of such an algorithm definition is inherently parallelizable</b>.
<br/><br/>
Defining the above operations on algebraic data types (including polymorphic algebraic data types) is often a straightforward process (in fact, it can often be automated). The Haskell <a href="http://hackage.haskell.org/package/base">base</a> library provides functions for all of the above operations on Haskell lists, and many library functions are implemented using these functions; the Haskell compiler is optimized to compile these functions into efficient machine code. Most of the above functions are also supported by languages such as Python.</span>
<a name="e99b09b7d7054dcd8603ae063fae8fb7"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#e99b09b7d7054dcd8603ae063fae8fb7">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">We can begin by implementing a <b>fold</b> operation on Haskell <code>Integer</code> lists that does nothing.</span>
        
<div class="code"><div class="source"><br/>fold&nbsp;::&nbsp;[Integer]&nbsp;->&nbsp;[Integer]<br/>fold&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;[]<br/>fold&nbsp;(x:xs)&nbsp;=&nbsp;x&nbsp;:&nbsp;fold&nbsp;xs<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">We can modify the above to replace the two list constructors (i.e., <code>(:)</code> and <code>[]</code>) in the input list with a binary operator and a base case (in this case, <code>(+)</code> and <code>0</code>). This way, the <code>fold</code> function now computes the sum of the elements in the list.</span>
        
<div class="code"><div class="source"><br/>fold&nbsp;::&nbsp;[Integer]&nbsp;->&nbsp;Integer<br/>fold&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;0<br/>fold&nbsp;(x:xs)&nbsp;=&nbsp;x&nbsp;+&nbsp;fold&nbsp;xs<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">We can further generalize the above so that it takes the two replacement functions as arguments. The two functions are a replacement for <code>(:)</code>, so it must be of type <code>Integer -> Integer -> Integer</code>, and a replacement for <code>[]</code>, which must be of type <code>Integer</code>.</span>
        
<div class="code"><div class="source"><br/>fold&nbsp;::&nbsp;(Integer&nbsp;->&nbsp;Integer&nbsp;->&nbsp;Integer)&nbsp;->&nbsp;Integer&nbsp;->&nbsp;[Integer]&nbsp;->&nbsp;Integer<br/>fold&nbsp;f&nbsp;b&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;b<br/>fold&nbsp;f&nbsp;b&nbsp;(x:xs)&nbsp;=&nbsp;f&nbsp;x&nbsp;(fold&nbsp;f&nbsp;b&nbsp;xs)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">We can now use the above <code>fold</code> implementation to define many common functions on lists of integers.</span>
        
<div class="code"><div class="source"><br/>sum&nbsp;::&nbsp;[Integer]&nbsp;->&nbsp;Integer<br/>sum&nbsp;=&nbsp;fold&nbsp;(+)&nbsp;0<br/><br/>product&nbsp;::&nbsp;[Integer]&nbsp;->&nbsp;Integer<br/>product&nbsp;=&nbsp;fold&nbsp;(*)&nbsp;1<br/><br/>maximum&nbsp;::&nbsp;[Integer]&nbsp;->&nbsp;Integer<br/>maximum&nbsp;=&nbsp;fold&nbsp;max&nbsp;0&nbsp;<span class="comment">--&nbsp;Assumes&nbsp;non-negative&nbsp;integers.</span><br/><br/>minimum&nbsp;::&nbsp;[Integer]&nbsp;->&nbsp;Integer<br/>minimum&nbsp;l&nbsp;=&nbsp;fold&nbsp;min&nbsp;(fold&nbsp;max&nbsp;l)&nbsp;l<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
      </div></div></div>
<a name="173d61a62368428bb5f7bfc393d45ab8"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#173d61a62368428bb5f7bfc393d45ab8">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">The fold function for the default right-associative list implementation supported by Haskell (i.e., with the built-in constructors <code>(:)</code> and <code>[]</code>) is called <code>foldr</code>.</span>
        
<div class="code"><div class="source"><br/>foldr&nbsp;::&nbsp;(a&nbsp;->&nbsp;b&nbsp;->&nbsp;b)&nbsp;->&nbsp;b&nbsp;->&nbsp;[a]&nbsp;->&nbsp;b<br/>foldr&nbsp;f&nbsp;base&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;base<br/>foldr&nbsp;f&nbsp;base&nbsp;(x:xs)&nbsp;=&nbsp;f&nbsp;x&nbsp;(foldr&nbsp;f&nbsp;base&nbsp;xs)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">The <code>foldr</code> function can be used to implement many of the usual library functions one might find useful when working with lists, and this is what is done in the Haskell libraries. Below are some examples (some of these are simplified versions of what is actually found in the libraries).</span>
        
<div class="code"><div class="source"><br/>sum&nbsp;::&nbsp;Num&nbsp;a&nbsp;->&nbsp;[a]&nbsp;->&nbsp;a<br/>sum&nbsp;xs&nbsp;=&nbsp;foldr&nbsp;(+)&nbsp;0&nbsp;xs<br/><br/>max&nbsp;::&nbsp;Ord&nbsp;a&nbsp;=>&nbsp;a&nbsp;->&nbsp;a&nbsp;->&nbsp;a<br/>max&nbsp;x&nbsp;y&nbsp;=&nbsp;if&nbsp;x&nbsp;>&nbsp;y&nbsp;then&nbsp;x&nbsp;else&nbsp;y<br/><br/>maximum&nbsp;::&nbsp;Ord&nbsp;a&nbsp;=>&nbsp;[a]&nbsp;->&nbsp;a<br/>maximum&nbsp;xs&nbsp;=&nbsp;foldr&nbsp;max&nbsp;0&nbsp;xs<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
      </div></div></div>
<a name="cc555577086f4c8bae8ba7fae4d62c8b"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#cc555577086f4c8bae8ba7fae4d62c8b">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">We can implement any <b>map</b> operation as a fold. Suppose we want to add the constant <code>1</code> to every element in an <code>Integer</code> list. For example, we want to achieve the following using a call to <code>foldr</code>:</span>
        
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;[x&nbsp;+&nbsp;1&nbsp;|&nbsp;x&nbsp;<-&nbsp;[1,2,3,4,5]]<br/>[2,3,4,5,6]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">We can accomplish this by defining a modified list node constructor function that adds <code>1</code> to its first argument, then builds the list node:</span>
        
<div class="code"><div class="source"><br/>addOneThenCons&nbsp;::&nbsp;Integer&nbsp;->&nbsp;[Integer]&nbsp;->&nbsp;[Integer]<br/>addOneThenCons&nbsp;x&nbsp;xs&nbsp;=&nbsp;(x&nbsp;+&nbsp;1)&nbsp;:&nbsp;xs<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">We can now use the above together with <code>foldr</code>:</span>
        
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;foldr&nbsp;addOneThenCons&nbsp;[]&nbsp;[1,2,3,4,5]<br/>[2,3,4,5,6]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">Using &lambda; abstractions, we can avoid having to explicitly define <code>addOneThenCons</code>:</span>
        
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;foldr&nbsp;(\x&nbsp;xs&nbsp;->&nbsp;(x+1)&nbsp;:&nbsp;xs)&nbsp;[]&nbsp;[1,2,3,4,5]<br/>[2,3,4,5,6]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
      </div></div></div>
<a name="7e489ac9ffdb41c7b295ea16c0255ebc"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#7e489ac9ffdb41c7b295ea16c0255ebc">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">We can implement any <b>filter</b> operation as a fold. For example, suppose we want to only keep positive integers from an integer list:</span>
        
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;[x&nbsp;|&nbsp;x&nbsp;<-&nbsp;[-3,-2,-1,0,1,2,3],&nbsp;x&nbsp;>&nbsp;0]<br/>[1,2,3]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">We can accomplish this by defining a modified list node constructor function that only adds a new list node if the data inside it is a positive integer:</span>
        
<div class="code"><div class="source"><br/>consIfPositive&nbsp;::&nbsp;Integer&nbsp;->&nbsp;[Integer]&nbsp;->&nbsp;[Integer]<br/>consIfPositive&nbsp;x&nbsp;xs&nbsp;=&nbsp;<span class="keyword">if</span>&nbsp;x&nbsp;>&nbsp;0&nbsp;<span class="keyword">then</span>&nbsp;x&nbsp;:&nbsp;xs&nbsp;<span class="keyword">else</span>&nbsp;xs<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">We can now use the above together with <code>foldr</code>:</span>
        
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;foldr&nbsp;consIfPositive&nbsp;[]&nbsp;[-3,-2,-1,0,1,2,3]<br/>[1,2,3]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">Using &lambda; abstractions, we can avoid having to explicitly define <code>consIfPositive</code>:</span>
        
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;foldr&nbsp;(\x&nbsp;xs&nbsp;->&nbsp;<span class="keyword">if</span>&nbsp;x&nbsp;>&nbsp;0&nbsp;<span class="keyword">then</span>&nbsp;x&nbsp;:&nbsp;xs&nbsp;<span class="keyword">else</span>&nbsp;xs)&nbsp;[]&nbsp;[-3,-2,-1,0,1,2,3]<br/>[1,2,3]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
      </div></div></div>
<a name="cec4b16ab14e4db49fb478aef9bd846b"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#cec4b16ab14e4db49fb478aef9bd846b">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">We can implement an easily parallelizable version of quicksort using <b>filter</b> operations:</span>
        
<div class="code"><div class="source"><br/>qsort&nbsp;::&nbsp;[Integer]&nbsp;->&nbsp;[Integer]<br/>qsort&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;[]<br/>qsort&nbsp;(x:xs)&nbsp;=&nbsp;qsort&nbsp;[y&nbsp;|&nbsp;y&nbsp;<-&nbsp;xs,&nbsp;y&nbsp;<&nbsp;x]&nbsp;++&nbsp;[x]&nbsp;++&nbsp;qsort&nbsp;[y&nbsp;|&nbsp;y&nbsp;<-&nbsp;xs,&nbsp;y&nbsp;>=&nbsp;x]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
      </div></div></div>
<a name="2cc51f6d51e54601a95b14a30fe459a3"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#2cc51f6d51e54601a95b14a30fe459a3">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example:</b> 
        
<span class="text">We can implement a <b>fold</b> operation that works for associative binary operators that recursively splits the problem into two parts over and over until a base case is reached.</span>
        
<div class="code"><div class="source"><br/>fold&nbsp;::&nbsp;(a&nbsp;->&nbsp;a&nbsp;->&nbsp;a)&nbsp;->&nbsp;a&nbsp;->&nbsp;[a]&nbsp;->&nbsp;a<br/>fold&nbsp;f&nbsp;b&nbsp;[]&nbsp;&nbsp;=&nbsp;b<br/>fold&nbsp;f&nbsp;b&nbsp;[x]&nbsp;=&nbsp;x<br/>fold&nbsp;f&nbsp;b&nbsp;xs&nbsp;&nbsp;=<br/>&nbsp;&nbsp;fold&nbsp;f&nbsp;b&nbsp;(take&nbsp;(length&nbsp;xs&nbsp;`div`&nbsp;2)&nbsp;xs)<br/>&nbsp;&nbsp;&nbsp;&nbsp;`f`&nbsp;<br/>&nbsp;&nbsp;fold&nbsp;f&nbsp;b&nbsp;(drop&nbsp;(length&nbsp;xs&nbsp;`div`&nbsp;2)&nbsp;xs)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">If each recursive invocation were run on a separate thread, processor, server, and so on, this would maximum the amount of parallelization that can be achieved in performing this <b>fold</b> operation.</span>
      </div></div></div>
<a name="7e489ac9ffdb41c7b295ea16c0255ebc"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#7e489ac9ffdb41c7b295ea16c0255ebc">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example (filter, map, and fold operations in SQL-like languages):</b> 
        
<span class="text">SQL-like languages (as well as the <a href="http://en.wikipedia.org/wiki/Relational_algebra">relational algebra</a> on which they are based) can be viewed as supporting fold, map, and filter operations (and compositions thereof) on a particular data structure: a table. This allows databases to be distributed across multiple storage devices, and it makes it possible to simultaneously query different portions of a database, stored on different devices, using multiple computational devices (processors, virtual machines, servers, and so on) running in parallel.
<br/><br/>
For example, suppose an SQL table consists of some number of rows, and each row has an entry of the form <code>(Name, Age)</code>:</span>
        
<div class="code"><div class="source"><br/>+<span class="comment">---------------+</span><br/>|&nbsp;&nbsp;&nbsp;&nbsp;People&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br/>+<span class="comment">---------------+</span><br/>|&nbsp;Name&nbsp;&nbsp;|&nbsp;&nbsp;Age&nbsp;&nbsp;|<br/>+<span class="comment">-------+-------+</span><br/>|&nbsp;Alice&nbsp;|&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;|<br/>|&nbsp;Bob&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;17&nbsp;&nbsp;&nbsp;|<br/>|&nbsp;Carl&nbsp;&nbsp;|&nbsp;&nbsp;23&nbsp;&nbsp;&nbsp;|<br/>+<span class="comment">-------+-------+</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">The following SQL query allows a user to retrieve only the <code>Name</code> entries in the table; this query amounts to a <b>map</b> operation:</span>
        
<div class="code"><div class="source"><br/>>&nbsp;<span class="keyword">SELECT</span>&nbsp;Name&nbsp;<span class="keyword">FROM</span>&nbsp;People<br/><br/>+<span class="comment">-------+</span><br/>|&nbsp;Name&nbsp;&nbsp;|<br/>+<span class="comment">-------+</span><br/>|&nbsp;Alice&nbsp;|<br/>|&nbsp;Bob&nbsp;&nbsp;&nbsp;|<br/>|&nbsp;Carl&nbsp;&nbsp;|<br/>+<span class="comment">-------+</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">The following SQL query allows a user to retrieve only the entries within a certain <code>Age</code> range; this query amounts to a <b>filter</b> operation:</span>
        
<div class="code"><div class="source"><br/>>&nbsp;<span class="keyword">SELECT</span>&nbsp;*&nbsp;<span class="keyword">FROM</span>&nbsp;People&nbsp;<span class="keyword">WHERE</span>&nbsp;Age&nbsp;>=&nbsp;18<br/><br/>+<span class="comment">---------------+</span><br/>|&nbsp;Name&nbsp;&nbsp;|&nbsp;&nbsp;Age&nbsp;&nbsp;|<br/>+<span class="comment">-------+-------+</span><br/>|&nbsp;Alice&nbsp;|&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;|<br/>|&nbsp;Carl&nbsp;&nbsp;|&nbsp;&nbsp;23&nbsp;&nbsp;&nbsp;|<br/>+<span class="comment">-------+-------+</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">The following SQL query allows a user to retrieve the sum of the <code>Age</code> fields of all the entries; this query amounts to <b>fold</b> operation (it is often called an aggregation operation):</span>
        
<div class="code"><div class="source"><br/>>&nbsp;<span class="keyword">SELECT</span>&nbsp;<span class="builtin">SUM</span>(Age)&nbsp;<span class="keyword">FROM</span>&nbsp;People<br/><br/>+<span class="comment">-------+</span><br/>|&nbsp;&nbsp;Age&nbsp;&nbsp;|<br/>+<span class="comment">-------+</span><br/>|&nbsp;&nbsp;60&nbsp;&nbsp;&nbsp;|<br/>+<span class="comment">-------+</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">We can easily simulate all of the above capabilities using another language that supports the declarative and functional programming paradigms, such as Haskell. Suppose we have the following definitions:</span>
        
<div class="code"><div class="source"><br/><span class="keyword">type</span>&nbsp;Name&nbsp;=&nbsp;String<br/><span class="keyword">type</span>&nbsp;Age&nbsp;=&nbsp;Integer<br/><span class="keyword">data</span>&nbsp;Table&nbsp;=&nbsp;[(Name,&nbsp;Age)]<br/><br/>people&nbsp;=&nbsp;[(<span class="literal">"Alice"</span>,&nbsp;20),&nbsp;(<span class="literal">"Bob"</span>,&nbsp;17),&nbsp;(<span class="literal">"Carl"</span>,&nbsp;23)]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">We can then perform the following queries:</span>
        
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;[name&nbsp;|&nbsp;(name,&nbsp;age)&nbsp;<-&nbsp;people]<br/>[<span class="literal">"Alice"</span>,&nbsp;<span class="literal">"Bob"</span>,&nbsp;<span class="literal">"Carl"</span>]<br/><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;[(name,&nbsp;age)&nbsp;|&nbsp;(name,&nbsp;age)&nbsp;<-&nbsp;people,&nbsp;age&nbsp;>=&nbsp;18]<br/>[(<span class="literal">"Alice"</span>,&nbsp;20),&nbsp;(<span class="literal">"Carl"</span>,&nbsp;23)]<br/><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;foldr&nbsp;(+)&nbsp;0&nbsp;[age&nbsp;|&nbsp;(name,&nbsp;age)&nbsp;<-&nbsp;people]<br/>60<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">Equivalently, we can use <code>map</code>, <code>filter</code>, <code>foldr</code>, and &lambda; abstractions instead of list comprehensions (the Haskell compiler simply converts list comprehensions into some combination of these during compilation):</span>
        
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;map&nbsp;(\(name,&nbsp;age)&nbsp;->&nbsp;name)&nbsp;people<br/>[<span class="literal">"Alice"</span>,&nbsp;<span class="literal">"Bob"</span>,&nbsp;<span class="literal">"Carl"</span>]<br/><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;map&nbsp;fst&nbsp;people<br/>[<span class="literal">"Alice"</span>,&nbsp;<span class="literal">"Bob"</span>,&nbsp;<span class="literal">"Carl"</span>]<br/><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;filter&nbsp;(\(name,&nbsp;age)&nbsp;->&nbsp;age&nbsp;>=&nbsp;18)&nbsp;people]<br/>[(<span class="literal">"Alice"</span>,&nbsp;20),&nbsp;(<span class="literal">"Carl"</span>,&nbsp;23)]<br/><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;foldr&nbsp;(+)&nbsp;0&nbsp;(map&nbsp;fst&nbsp;people)<br/>60<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">All of the above can also be done using Python list comprehensions:</span>
        
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;People&nbsp;=&nbsp;[(<span class="literal">"Alice"</span>,&nbsp;20),&nbsp;(<span class="literal">"Bob"</span>,&nbsp;17),&nbsp;(<span class="literal">"Carl"</span>,&nbsp;23)]<br/><br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;[name&nbsp;<span class="keyword">for</span>&nbsp;(name,&nbsp;age)&nbsp;<span class="keyword">in</span>&nbsp;People]<br/>[<span class="literal">"Alice"</span>,&nbsp;<span class="literal">"Bob"</span>,&nbsp;<span class="literal">"Carl"</span>]<br/><br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;[(name,&nbsp;age)&nbsp;<span class="keyword">for</span>&nbsp;(name,&nbsp;age)&nbsp;<span class="keyword">in</span>&nbsp;People&nbsp;<span class="keyword">if</span>&nbsp;age&nbsp;>=&nbsp;18]<br/>[(<span class="literal">'Alice'</span>,&nbsp;20),&nbsp;(<span class="literal">'Carl'</span>,&nbsp;23)]<br/><br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;<span class="builtin">sum</span>([age&nbsp;<span class="keyword">for</span>&nbsp;(name,&nbsp;age)&nbsp;<span class="keyword">in</span>&nbsp;People])<br/>60<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">Python also supports <code>map</code>, <code>filter</code>, <code>reduce</code> (similar to Haskell's <code>foldr</code>), and lambda abstractions:</span>
        
<div class="code"><div class="source"><br/><br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;<span class="builtin">list</span>(<span class="builtin">map</span>((<span class="keyword">lambda</span>&nbsp;person:&nbsp;person[0]),&nbsp;People))<br/>[<span class="literal">'Alice'</span>,&nbsp;<span class="literal">'Bob'</span>,&nbsp;<span class="literal">'Carl'</span>]<br/><br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;<span class="builtin">list</span>(<span class="builtin">filter</span>((<span class="keyword">lambda</span>&nbsp;person:&nbsp;person[1]&nbsp;>=&nbsp;18),&nbsp;People))<br/>[(<span class="literal">'Alice'</span>,&nbsp;20),&nbsp;(<span class="literal">'Carl'</span>,&nbsp;23)]<br/><br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;<span class="keyword">from</span>&nbsp;functools&nbsp;<span class="keyword">import</span>&nbsp;reduce<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;reduce(<span class="keyword">lambda</span>&nbsp;x,y:&nbsp;x&nbsp;+&nbsp;y,&nbsp;[age&nbsp;<span class="keyword">for</span>&nbsp;(name,&nbsp;age)&nbsp;<span class="keyword">in</span>&nbsp;People])<br/>60<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
      </div></div></div>
<a name="6235f5ed98124301bb2a7cac0f08cd03"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#6235f5ed98124301bb2a7cac0f08cd03">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="example_required"><b>Example (filter and map operations in JavaScript libraries):</b> 
        
<span class="text">Many JavaScript libraries, such as <a href="http://jquery.com/">jQuery</a>/<a href="http://jqueryui.com/">jQuery UI</a>, <a href="http://nodejs.org/">node.js</a>, <a href="http://d3js.org/">d3</a>, and others support an abstraction for manipulating web documents (which are often used as application components on the web today) that is organized around <b>filter</b> and <b>map</b> operations.
<br/><br/>
In jQuery, it is possible to select all the elements with a certain tag in an HTML document and then to specify a function that will be applied to each element selected. This corresponds to the composition of a <b>filter</b> and <b>map</b> operation.
<br/><br/>
For example, the following code selects all the <code>li</code> elements and updates the text content of each to indicate the item number corresponding to that element. Notice that the <code>.text()</code> function takes a function as an argument (the function supplied as an argument takes an index as an input and returns a string):</span>
        
<div class="code"><div class="source"><br/>$(<span class="literal">"ul&nbsp;li"</span>).text(<br/>&nbsp;&nbsp;<span class="keyword">function</span>(&nbsp;index&nbsp;)&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="literal">"item&nbsp;number&nbsp;"</span>&nbsp;+&nbsp;(&nbsp;index&nbsp;+&nbsp;1&nbsp;);<br/>&nbsp;&nbsp;}<br/>);<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
        
<span class="text">More generally, it's possible to update individual document elements using the <a href="http://api.jquery.com/each/"><code>.each()</code></a> function.</span>
      </div></div></div></div><br/><hr/><a name="7.16"></a><a name="assignment6"></a><a name="hw6"></a><div class="assignment"><h3 class="linked"><span class="link-title">[<a href="#7.16">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">7.16.</span> <span class="assignment_title">Assignment #6: Exploiting Polymorphism, Catamorphisms, and Algebraic Properties</span></h3><div class="instructions">
In this assignment you will take advantage of polymorphism, catamorphisms, and algebraic properties of programs while implementing a compiler for a simple programming language for a distributed computational infrastructure. You must submit four files:
<ul>
  <li><code><a href="hw6/Tree.hs">hw6/Tree.hs</a></code>;</li>
  <li><code><a href="hw6/Metaql.hs">hw6/Metaql.hs</a></code>;</li>
  <li><code><a href="hw6/Protoql.hs">hw6/Protoql.hs</a></code>;</li>
  <li><code><a href="hw6/Compile.hs">hw6/Compile.hs</a></code>.</li>
</ul>
Please follow the <a href="http://www.cs.bu.edu/teaching/hw/gsubmit/">gsubmit</a> directions and remember to put your files in the <code>hw6</code> directory.
<br/><br/>
Your solutions to each of the problem parts below will be graded on their correctness, concision, and mathematical legibility. The different problems and problem parts rely on the lecture notes and on each other; carefully consider whether you can use functions from the lecture notes, or functions you define in one part within subsequent parts.
<br/><br/>
<b style="color:green;">A testing script with several test cases is available for download: <a href="a6-tests.hs"><code>a6-tests.hs</code></a>. You should be able to place it in the same directory with the other assignment files and load it. Feel free to modify or extend it as you see fit.</b>
<!--<br/><br/>
<b style="color:green;">A full solution to this assignment is now available here: <a href="hw6/solutions/"><code>/hw5/solutions</code></a>.</b>
-->
      
      </div><ol class="problems"><li class="problem">
<span class="text">In this problem you will implement a small library for a polymorphic tree data structure. Your solutions should be included in the file <code><a href="hw6/Tree.hs">hw6/Tree.hs</a></code>.</span><ol class="parts"><li class="part">
<span class="text">Implement a polymorphic function <code>leaves :: Tree a -> Integer</code> that takes a tree and returns the total number of leaves in the tree. An <code>Empty</code> tree contains no leaves.</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;leaves&nbsp;(Node&nbsp;(Node&nbsp;(Leaf&nbsp;4)&nbsp;(Leaf&nbsp;5))&nbsp;(Leaf&nbsp;7))<br/>3<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li><li class="part">
<span class="text">Implement a polymorphic function <code>insert :: a -> Tree a -> Tree a</code> that takes an argument of any type <code>a</code> and another argument of type <code>Tree a</code> and inserts the new item of type <code>a</code> into the tree so that the height of the resulting tree is minimized. In other words, the definition should be recursive:
<ul>
  <li>if the tree is empty, after the item is inserted, it should contain a single leaf;</li>
  <li>if the tree is a single leaf, it should become a node with two leaf children;</li>
  <li>if the tree has two subtrees, the item should be <b>inserted into the subtree that has fewer leaves</b>.</li>
</ul></span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;insert&nbsp;True&nbsp;(Node&nbsp;(Node&nbsp;(Leaf&nbsp;False)&nbsp;(Leaf&nbsp;False))&nbsp;(Leaf&nbsp;False))<br/>Node&nbsp;(Node&nbsp;(Leaf&nbsp;False)&nbsp;(Leaf&nbsp;False))&nbsp;(Node&nbsp;(Leaf&nbsp;True)&nbsp;(Leaf&nbsp;False))<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li><li class="part">
<span class="text">Implement a polymorphic function <code>fold :: (a -> a -> a) -> Tree a -> a</code> that takes a function of type <code>a -> a -> a</code> and a tree of type <code>Tree a</code>, and performs a fold over the tree using the function of type <code>a -> a -> a</code> in order to return a single result of type <code>a</code>. You may assume that the input tree is always non-empty.</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;fold&nbsp;(+)&nbsp;(Node&nbsp;(Node&nbsp;(Leaf&nbsp;4)&nbsp;(Leaf&nbsp;5))&nbsp;(Leaf&nbsp;7))<br/>16<br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;fold&nbsp;(++)&nbsp;(Node&nbsp;(Node&nbsp;(Leaf&nbsp;<span class="literal">"A"</span>)&nbsp;(Leaf&nbsp;<span class="literal">"B"</span>))&nbsp;(Node&nbsp;(Leaf&nbsp;<span class="literal">"C"</span>)&nbsp;(Leaf&nbsp;<span class="literal">"D"</span>)))<br/><span class="literal">"ABCD"</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li></ol></li><li class="problem">
<span class="text">In this problem you will implement a module for working with abstract syntax data structures for the small programming language <i>Metaql</i>. Your solutions should be included in the file <code><a href="hw6/Metaql.hs">hw6/Metaql.hs</a></code>. The abstract syntaxes for statements, expressions, and types for this programming language are defined below.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">statement <i>s</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>Print</b> <i>e</i> <i>s</i> | <b>End</b></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
expression <i>e</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>N</b> <i>any valid integer</i> | <b>S</b> <i>any string</i> | <b>Plus</b> <i>e</i> <i>e</i> | <b>Conc</b> <i>e</i> <i>e</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
type &tau; <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>TyInt</b> | <b>TyStr</b> | <b>TyVoid</b>
</td></tr></table></td></tr></table>
The type system for this programming language is defined by the following collection of type inference rules:</span><div class="inferences"><table class="inference"><tr><td class="title">[Exp-Integer]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&#8866; <b>N</b> <i>n</i>: <b>TyInt</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Exp-String]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&#8866; <b>S</b> <i>s</i>: <b>TyStr</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Exp-Plus]</td><td><table><tr><td class="premises">&nbsp;&#8866; <i>e</i><sub>1</sub>: <b>TyInt</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &#8866; <i>e</i><sub>2</sub>: <b>TyInt</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&#8866; <b>Plus</b> <i>e</i><sub>1</sub> <i>e</i><sub>2</sub>: <b>TyInt</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Exp-Conc]</td><td><table><tr><td class="premises">&nbsp;&#8866; <i>e</i><sub>1</sub>: <b>TyStr</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &#8866; <i>e</i><sub>2</sub>: <b>TyStr</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&#8866; <b>Conc</b> <i>e</i><sub>1</sub> <i>e</i><sub>2</sub>: <b>TyStr</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Stmt-Print]</td><td><table><tr><td class="premises">&nbsp;&#8866; <i>s</i>: <b>TyVoid</b> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &#8866; <i>e</i>: <b>&tau;</b>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&#8866; <b>Print</b> <i>e</i> <i>s</i> : <b>TyVoid</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Stmt-End]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;&#8866; <b>End</b>: <b>TyVoid</b>&nbsp;</td></tr></table></td></tr></table></div><ol class="parts"><li class="part">
<span class="text">Modify the <code>instance Num Exp</code> declaration so that it is possible to use <code>(*) :: Exp -> Exp -> Exp</code> to build abstract syntax trees representing string concatenation operations.</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;S&nbsp;<span class="literal">"ABC"</span>&nbsp;*&nbsp;S&nbsp;<span class="literal">"DEF"</span><br/>Conc&nbsp;(S&nbsp;<span class="literal">"ABC"</span>)&nbsp;(S&nbsp;<span class="literal">"DEF"</span>)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li><li class="part">
<span class="text">Implement a function <code>tyExp :: Exp -> Maybe Type</code> that takes an <code>Exp</code> abstrax syntax tree and, if it conforms to the type inference rules, returns its type (wrapped using the <code>Just</code> constructor). If the expression has no valid type according to the type inference rules, <code>tyExp</code> should return <code>Nothing</code>.</span></li><li class="part">
<span class="text">Implement a function <code>tyStmt :: Stmt -> Maybe Type</code> that takes a <code>Stmt</code> abstrax syntax tree and, if it conforms to the type inference rules, returns its type (wrapped using the <code>Just</code> constructor). If the statement has no valid type according to the type inference rules, <code>tyStmt</code> should return <code>Nothing</code>.</span></li><li class="part">
<span class="text">Implement a function <code>flat :: Exp -> [Exp]</code> that takes an <code>Exp</code> abstract syntax tree and returns a list that contains all the leaf nodes (i.e., integers and strings) in the original tree (in the order obtained via an in-order traversal of the tree).</span></li><li class="part">
<span class="text">Implement a function <code>size :: Exp -> Int</code> that takes an <code>Exp</code> abstract syntax tree and returns the number of leaf nodes (i.e., integers and strings) in the tree.</span></li></ol></li><li class="problem">
<span class="text">In this problem you will define optimization and refactoring functions for Metaql abstract syntax trees that take advantage of the algebraic properties of addition and string concatenation. Your solutions should be included in the file <code><a href="hw6/Metaql.hs">hw6/Metaql.hs</a></code>.
<b style="color:green;">You should not evaluate the expressions for this problem. The number of nodes and leaves in the abstract syntax tree must remain the same after refactoring has occurred. Solutions that do not conform to this requirement will receive no credit.</b></span><ol class="parts"><li class="part">
<span class="text">Implement a function <code>refactorInt :: Exp -> Exp</code> that takes an <code>Exp</code> abstrax syntax tree as its argument. If the tree has Metaql type <code>TyInt</code>, the function should take advantage of the associative and commutative properties of addition by returning a tree with an equivalent meaning (i.e., the result of evaluating the tree should not change) that is of the least possible height. If the tree is not of Metaql type <code>TyInt</code>, no changes should be made. <b>Hint:</b> flatten the tree, use <code>foldr</code> and <code>insert</code> to build a tree of type <code>Tree Exp</code>, and then use <code>fold</code> over the tree to rebuild the expression using the binary operator that corresponds to the tree's original type.</span></li><li class="part">
<span class="text">Implement a function <code>refactorStr :: Exp -> Exp</code> that takes an <code>Exp</code> abstrax syntax tree as its argument. If the tree has Metaql type <code>TyStr</code>, the function should take advantage of the associative property of string concatenation by returning a <b>degenerate</b> tree with an equivalent meaning (i.e., the result of evaluating the tree should not change) in which only right-associative concatenation occurs. If the tree is not of Metaql type <code>TyStr</code>, no changes should be made. <b>Hint:</b> flatten the tree and use <code>foldr</code> together with other standard list functions to rebuild the tree.</span></li><li class="part">
<span class="text">Implement a function <code>refactor :: Stmt -> Stmt</code> that refactors all the <code>Exp</code> subtrees so that all subtrees of Metaql type <code>TyInt</code> have the minimum height possible, and so that all subtrees of Metaql type <code>TyStr</code> only contain right-associated applications of concatenation.</span></li></ol></li><li class="problem">
<span class="text">In this problem you will implement a module that compiles Metaql programs into <i>Protoql</i>, a small programming language for defining workflows for distributed computational infrastructures. Your solutions should be included in the file <code><a href="hw6/Compile.hs">hw6/Compile.hs</a></code>. The abstract syntaxes for statements in Protoql are defined below; the file <code><a href="hw6/Protoql.hs">hw6/Protoql.hs</a></code> contains a Haskell implementation of an abstract syntax data structure for Protoql.
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">program <i>p</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>q</i><sub>1</sub> <b>;</b> ... <b>;</b> <i>q</i><sub><i>n</i></sub> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
query <i>q</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>Output(</b> <i>i</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>Query(</b> <i>i</i> <b>,</b> <i>s</i> <b>, </b> <i>a</i> <b>,</b> <i>o</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>Input(</b> <i>c</i> <b>,</b> <i>o</i> <b>)</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
constant <i>c</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>"</b><i>any valid string</i><b>"</b> | <b>"</b><i>any valid integer</i><b>"</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
operation <i>a</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>"Add"</b> | <b>"Concatenate"</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
server <i>s</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>"zero.protoql.org"</b> | <b>"one.protoql.org"</b> | <b>"two.protoql.org"</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
input link label <i>i</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid integer</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
output link label <i>o</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>any valid integer</i>
</td></tr></table></td></tr></table>
Protoql is a parallel language in which queries that do not depend on each other can execute in parallel. For example, all <b>Input()</b> queries execute simultaneously at time <i>t</i> = 0. Let <i>a</i> <i>c</i><sub>1</sub> <i>c</i><sub>2</sub> represent the result of applying operation <i>a</i> to the two inputs <i>c</i><sub>1</sub> and <i>c</i><sub>2</sub>, with the arguments exactly in that order, and let time values <i>t</i> be measured in seconds from the beginning of the computation at <i>t</i> = 0. The operational semantics for Protoql can be described using the following inference rules.</span><div class="inferences"><table class="inference"><tr><td class="title">[Input]</td><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>Input(</b><i>c</i><b>,</b> <i>o</i><b>)</b> instantly sends <i>c</i> to <i>o</i> at time 0&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Query-Left]</td><td><table><tr><td class="premises">&nbsp;<i>q</i> sends <i>c</i><sub>1</sub> to <i>i</i> at time <i>t</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>q</i> sends <i>c</i><sub>2</sub> to <i>i</i> at time <i>t</i><sub>2</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>t</i><sub>1</sub> &le; <i>t</i><sub>2</sub>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>Query(</b> <i>i</i> <b>,</b> <i>s</i> <b>, </b> <i>a</i> <b>,</b> <i>o</i> <b>)</b> sends <i>a</i> <i>c</i><sub>1</sub> <i>c</i><sub>2</sub> to <i>o</i> at time <i>t</i><sub>2</sub> + 1 or later&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Query-Right]</td><td><table><tr><td class="premises">&nbsp;<i>q</i> sends <i>c</i><sub>1</sub> to <i>i</i> at time <i>t</i><sub>1</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>q</i> sends <i>c</i><sub>2</sub> to <i>i</i> at time <i>t</i><sub>2</sub> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <i>t</i><sub>1</sub> > <i>t</i><sub>2</sub>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>Query(</b> <i>i</i> <b>,</b> <i>s</i> <b>, </b> <i>a</i> <b>,</b> <i>o</i> <b>)</b> sends <i>a</i> <i>c</i><sub>2</sub> <i>c</i><sub>1</sub> to <i>o</i> at time <i>t</i><sub>1</sub> + 1 or later&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td class="title">[Output]</td><td><table><tr><td class="premises">&nbsp;<i>q</i> sends <i>c</i> to <i>i</i> at time <i>t</i>&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>Output(</b> <i>i</i> <b>)</b> instantly outputs <i>c</i> at time <i>t</i>&nbsp;</td></tr></table></td></tr></table></div>
<span class="text"><b>You can test your Protoql programs on an actual web infrastructure using <a href="protoql.php">this interface</a>.</b></span><ol class="parts"><li class="part">
<span class="text">Implement a function <code>compExp :: [InLabel] -> OutLabel -> Exp -> [Query]</code> that takes a list of unused input labels, a target output label, and an <code>Exp</code> abstract syntax tree. The function should return a list of Protoql queries that corresponds to a valid Protoql program that computes the result of the expression:
<ul>
  <li>if the <code>Exp</code> tree is a base case, emit an appropriate <b>Input()</b> Protoql instruction and specify its destination using the <code>OutLabel</code> argument;</li>
  <li>if the <code>Exp</code> tree is a binary operator, obtain the Protoql instructions for each subtree (use <code>size</code> together with <code>take</code> and <code>drop</code> to ensure that the input label lists for the two recursive calls do not overlap), then return a list containing all the instructions for the two subtrees, and one additional <b>Query()</b> instruction corresponding to the binary operation that must be performed.</li>
</ul></span></li><li class="part">
<span class="text">Implement a function <code>compStmt :: [InLabel] -> Stmt -> [Query]</code> that takes a list of unused input labels, and a Metaql <code>Stmt</code> abstract syntax tree. The function should return a list of Protoql queries that corresponds to a valid Protoql program that computes the results of all the <b>Print</b> statements in the Metaql <code>Stmt</code> tree. Each result should be sent to a new <b>Output()</b> query with its own unique input label.</span></li><li class="part">
<span class="text">Implement a function <code>compile :: Stmt -> Maybe Program</code> that takes a Metaql <code>Stmt</code> abstrax syntax tree, ensures that the tree conforms to the Metaql type inference rules, and if so, optimizes the tree, and compiles it into a valid Protoql program. If the <code>Stmt</code> tree does not conform to the type system, the function should not attempt to optimize or compile the tree; it should return <code>Nothing</code>.</span></li><li class="part">
<span class="text">Implement a function <code>time :: Stmt -> Maybe Integer</code> that takes a Metaql <code>Stmt</code> abstrax syntax tree and computes the minimum running time in seconds of the fastest valid Protoql program into which it can be compiled (i.e., running the Protoql program should yield a correct result under all circumstances).</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;time&nbsp;(Print&nbsp;(1&nbsp;+&nbsp;2&nbsp;+&nbsp;3&nbsp;+&nbsp;4&nbsp;+&nbsp;5&nbsp;+&nbsp;6&nbsp;+&nbsp;7&nbsp;+&nbsp;8)&nbsp;$&nbsp;End)<br/>Just&nbsp;3<br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;time&nbsp;(Print&nbsp;5&nbsp;$&nbsp;Print&nbsp;(((1&nbsp;+&nbsp;2)&nbsp;+&nbsp;3)&nbsp;+&nbsp;4)&nbsp;$&nbsp;End)<br/>Just&nbsp;2<br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;time&nbsp;(Print&nbsp;(((1&nbsp;+&nbsp;2)&nbsp;+&nbsp;3)&nbsp;+&nbsp;4)&nbsp;$&nbsp;Print&nbsp;(S&nbsp;<span class="literal">"A"</span>&nbsp;*&nbsp;S&nbsp;<span class="literal">"BC"</span>&nbsp;*&nbsp;S&nbsp;<span class="literal">"D"</span>&nbsp;*&nbsp;S&nbsp;<span class="literal">"EF"</span>&nbsp;*&nbsp;S&nbsp;<span class="literal">"G"</span>&nbsp;*&nbsp;S&nbsp;<span class="literal">"H"</span>)&nbsp;$&nbsp;End)<br/>Just&nbsp;5<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li></ol></li><li class="problem">
<span class="text">Suppose the operational semantics of Protoql were modified so that a server can only perform one query at a time, and suppose that the number of available servers is unlimited but each server has a fixed cost to reserve.</span><ol class="parts"><li class="part">
<span class="text"><b>Extra credit:</b> Implement a function <code>servers :: [Exp] -> Integer</code> that computes the <b>minimum</b> number of servers that is required to run all the queries in the input list in parallel in the fastest time possible (as determined by a correct implementation of <code>time</code>).
<ul>
  <li>you may assume all the expressions have already been refactored using the function in <b>Problem #3</b>;</li>
  <li>this will <b>not</b> simply be the number leaves in the expression trees, and it may be a much smaller quantity than number of leaves in many cases;</li>
  <li>split the problem up into two cases: (1) the expression that will take longest to compute is of type <b>TyInt</b>, and (2) the expression that will take longest to compute is of type <b>TyStr</b>;</li>
  <li>take advantage of list comprehensions, <code>maximum</code> and/or <code>minimum</code>, <code>foldr</code>, <code>zip</code>, <code>sum</code>, and other list functions to implement a very concise solution.</li>
</ul></span></li><li class="part">
<span class="text"><b>Extra extra credit:</b> Implement a function <code>reassign :: [Query] -> [Query]</code> that updates the server entries in all the queries with new server names so that the running time of the query under the new semantics will conform to the output of <code>time</code>. You may assume the servers <code>0.protoql.org</code>, <code>1.protoql.org</code>, <code>2.protoql.org</code>, and so on are all available.</span></li></ol></li></ol>
</div><hr/><br/>
</div><a name="R.1"></a><div class="review"><hr style="margin-bottom:120px;"/><h2 class="linked"><span class="link-title">[<a href="#R.1">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">Review #1.</span> Programming Language Concepts</h2>
<span class="text">This section contains a comprehensive collection of review problems going over all the course material. Many of these problems are an accurate representation of the kinds of problems you may see on an exam.
<br/><br/>
Below is a breakdown of what concepts you should udnerstand and small-scale problems you should be able to solve at the end of this course (and of what you may be tested on in an exam).
<ul>
  <li>mathematical definitions involved in the definition of a programming language
    <ul>
      <li>strings</li>
      <li>token sequences</li>
      <li>concrete syntax
        <ul>
          <li>BNF notation
            <ul>
              <li>terminals</li>
              <li>non-terminals</li>
              <li>cases</li>
              <li>productions</li>
              <li>non-recursive, recursive, left-recursive</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>abstract syntax
        <ul>
          <li>variables</li>
          <li>expressions</li>
          <li>values/constants</li>
          <li>statements</li>
          <li>outputs/output sequences</li>
        </ul>
      </li>
      <li>type system
        <ul>
          <li>type inference rules
            <ul>
              <li>typical type inference rule for function application</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>operational semantics
        <ul>
          <li>inference rules</li>
        </ul>
      </li>
      <li>abstract interpretation (i.e., restricted/abstract operational semantics measuring some dimensions of interest, often used in static analysis)
        <ul>
          <li>cost</li>
          <li>memory</li>
          <li>running time</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>software components (data structures, and algorithms) involved in an implementation of a programming language
    <ul>
      <li>data structure
        <ul>
          <li>string</li>
          <li>token sequence</li>
          <li>abstract syntax tree</li>
          <li>intermediate representation abstrac syntax tree</li>
          <li>machine language instruction sequence</li>
          <li>bytecode instruction sequence</li>
          <li>heap</li>
          <li>stack</li>
          <li>environment/context</li>
          <li>substitution</li>
        </ul>
      </li>
      <li>algorithms and software components
        <ul>
          <li>tokenizer</li>
          <li>parser
            <ul>
              <li>predictive recursive descent parser</li>
              <li>backtracking recursive descent parser</li>
            </ul>
          </li>
          <li>static analysis algorithms (always terminate)
            <ul>        
              <li>abstract interpreter (cost, size, memory, time, etc.)</li>
              <li>type checker</li>
            </ul>
          </li>
          <li>optimization algorithms
            <ul>
              <li>constant folding (i.e., evaluation of subexpressions with no variables)</li>
              <li>loop unrolling</li>
            </ul>
          </li>
          <li>interpreter
            <ul>
              <li>evaluation algorithm</li>
              <li>execution algorithm</li>
            </ul>
          </li>
          <li>unification
            <ul>
              <li>substitution algorithm</li>
              <li>pattern matching unification algorithm</li>
            </ul>
          </li>
          <li>compiler (always terminates)</li>
          <li>run-time system/virtual machine</li>
          <li>garbage collector</li>
          <li>testing/validation
            <ul>
              <li>bounded exhaustive testing input generator</li>
              <li>validation algorithm (checks that two components have the same input-output behavior)</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>imperative and procedural programming langauge concepts
    <ul>
      <li>control flow</li>
      <li>procedures
        <ul>
          <li>how these are implemented by an interpreter</li>
          <li>how these are supported by a compiler to a machine language (stack)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>declarative and functional programming language concepts and techniques
    <ul>
      <li>how to solve equations involving data values using pattern matching unification</li>
      <li>models/modules and queries</li>
      <li>how can pattern matching unification...
        <ul>
          <li>support matching of function argument patterns and input values</li>
          <li>support parametric polymorphism in a type system</li>
        </ul>
      </li>
      <li>algebraic data types
        <ul>
          <li>constructors (base cases and inductive constructors with child trees)</li>
          <li>defining non-recursive and recursive functions that operate on algebraic data types</li>
        </ul>
      </li>
      <li>kinds of polymorphism
        <ul>
          <li>ad hoc polymorphism</li>
          <li>parametric polymorphism</li>
        </ul>
      </li>
      <li>higher order functions
        <ul>
          <li>types of higher-order functions</li>
          <li>how to define and apply higher-order functions</li>
          <li>how to compose functions</li>
        </ul>
      </li>
      <li>infinite data structures and applications
        <ul>
          <li>infinite lists, trees, decision trees, state space graphs</li>
          <li>traversing/searching a state space graph</li>
        </ul>
      </li>
      <li>folds, maps, and filters
        <ul>
          <li>using list comprehensions</li>
          <li>folds and maps on lists and trees</li>
          <li>defining fold and map functions</li>
          <li>using folds to perform common computations</li>
          <li>using functions with no names (lambda abstrctions) in folds, maps, and filters</li>
          <li>exploiting folds and maps to define parallel/distributed computations</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>miscellaneous tasks
    <ul>
      <li>does a parser implement a BNF definition of a grammar?</li>
      <li>does an interpreter implementation conform to an operational semantics?</li>
      <li>does a type checker implementation conform to a type system definition?</li>
      <li>apply an operational semantics or run an interpreter on a given program</li>
      <li>apply type inference rules or run a type checker on a given program</li>
      <li>explain the purpose of a definition or algorithm, or how multiple definitions and algorithms can fit together</li>
      <li>define or use a fold function</li>
      <li>define a state space graph or search algorithm on a state space graph</li>
    </ul>
  </li>
</ul></span>
<a name="0335e909e5f740219e0837f1a4664b4e"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#0335e909e5f740219e0837f1a4664b4e">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="exercise_required"><b>Exercise:</b> 
      
<span class="text">Suppose you are given the following definitions:</span>
      
<div class="code"><div class="source"><br/><span class="keyword">data</span>&nbsp;Graph&nbsp;=&nbsp;End&nbsp;|&nbsp;Branch&nbsp;[Graph]<br/><br/>fold&nbsp;::&nbsp;([a]&nbsp;->&nbsp;a)&nbsp;->&nbsp;a&nbsp;->&nbsp;Graph&nbsp;->&nbsp;a<br/>fold&nbsp;f&nbsp;b&nbsp;(End&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;=&nbsp;b<br/>fold&nbsp;f&nbsp;b&nbsp;(Branch&nbsp;gs)&nbsp;=&nbsp;f&nbsp;[fold&nbsp;f&nbsp;b&nbsp;g&nbsp;|&nbsp;g&nbsp;<-&nbsp;gs]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
      <ol style="list-style-type:lower-alpha"><li>
<span class="text">Define a one-line function <code>height :: Graph -> Integer</code> that computes the height of a <code>Graph</code>.</span>
<div class="solution_container"><div class="solution">
            
<div class="code"><div class="source"><br/>height&nbsp;::&nbsp;Graph&nbsp;->&nbsp;Integer<br/>height&nbsp;g&nbsp;=&nbsp;fold&nbsp;(\hs&nbsp;->&nbsp;1&nbsp;+&nbsp;maximum&nbsp;hs)&nbsp;1&nbsp;g<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
          </div></div></li><li>
<span class="text">Define a one-line function <code>width :: Graph -> Integer</code> that computes the width of a <code>Graph</code>.</span>
<div class="solution_container"><div class="solution">
            
<div class="code"><div class="source"><br/>width&nbsp;::&nbsp;Graph&nbsp;->&nbsp;Integer<br/>width&nbsp;t&nbsp;=&nbsp;fold&nbsp;(\ws&nbsp;->&nbsp;sum&nbsp;ws)&nbsp;1&nbsp;t<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
          </div></div></li></ol>
    </div></div></div>
<a name="d31915c941d848449c7fc5f7e6618355"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#d31915c941d848449c7fc5f7e6618355">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="exercise_required"><b>Exercise:</b> 
      
<span class="text">Suppose you are given the following type definitions for representing simple English sentences:</span>
      
<div class="code"><div class="source"><br/><span class="keyword">type</span>&nbsp;Noun&nbsp;=&nbsp;String<br/><span class="keyword">type</span>&nbsp;Adjective&nbsp;=&nbsp;String<br/><span class="keyword">type</span>&nbsp;Verb&nbsp;=&nbsp;String<br/><span class="keyword">type</span>&nbsp;Adverb&nbsp;=&nbsp;String<br/><br/><span class="keyword">data</span>&nbsp;NounPhrase&nbsp;=&nbsp;AN&nbsp;Adjective&nbsp;NounPhrase&nbsp;|&nbsp;N&nbsp;Noun<br/><span class="keyword">data</span>&nbsp;VerbPhrase&nbsp;=&nbsp;AV&nbsp;Adverb&nbsp;VerbPhrase&nbsp;|&nbsp;V&nbsp;Verb<br/><span class="keyword">data</span>&nbsp;Sentence&nbsp;=&nbsp;S&nbsp;NounPhrase&nbsp;VerbPhrase<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
      <ol style="list-style-type:lower-alpha"><li>
<span class="text">Determine the minimal substitution that solves the following equation under pattern-matching unification, or explain why no solution can exist (by demonstrating what base case causes an issue):
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><code>S (AN a (N "cat")) (V b)</code> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <code>S (AN "yellow" (N "cat")) (V "runs")</code>
</td></tr></table></td></tr></table></span>
<div class="solution_container"><div class="solution">
The minimal substitution is:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">{<code>a</code> &#x21A6; <code>"yellow"</code>, <code>b</code> &#x21A6; <code>"runs"</code>}
</td></tr></table></td></tr></table>
          </div></div></li><li>
<span class="text">Determine the minimal substitution that solves the following equation under pattern-matching unification, or explain why no solution can exist (by demonstrating what base case causes an issue):
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><code>S (AN a (AN b (N "cat"))) (V c)</code> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <code>S (AN "yellow" (N "cat")) (V "runs")</code>
</td></tr></table></td></tr></table></span>
<div class="solution_container"><div class="solution">
There is no substitution because once unification reaches a recursive invocation for the following equation, it will fail:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><code>AN b (N "cat")</code> <td></tr></table></td><td style="text-align:center;"> = </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <code>N "cat"</code>
</td></tr></table></td></tr></table>
Since the constructor <code>AN</code> can never be unified with the constructor <code>N</code>, there is no substitution that can be applied to both sides of the original equation to make both sides equivalent.
          </div></div></li><li>
<span class="text">Given the above data type definition, is it possible to write a single Haskell function pattern that will match any sentence in which <code>"cat"</code> is the subject?</span>
<div class="solution_container"><div class="solution">
No, this is impossible because the pattern would need to match a tree of arbitrary depth, since the <code>N</code> leaf constructor can only occur at the botton of a <code>NounPhrase</code> tree. In other words, the pattern would need to look something like the following:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;"><code>f (AN _ (AN _ ( ... (AN _ (N "cat"))))) = ...</code>
</td></tr></table></td></tr></table>
Nothing like the above is supported by Haskell.
          </div></div></li></ol>
    </div></div></div>
<a name="2f9c5a17c5044724bfa04089a3f97d3d"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#2f9c5a17c5044724bfa04089a3f97d3d">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="exercise_required"><b>Exercise:</b> 
      
<span class="text">Adjust the following grammar definition so that it accepts exactly the same set of token sequences, but is not left-recursive:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">number <i>n</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>0</b> | <b>1</b> | ... | <b>9</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>&#8722;</b> <i>n</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>n</i> <b>*</b> <i>n</i>
</td></tr></table></td></tr></table></span>
      
<div class="solution_container"><div class="solution">
We introduce a new production, and we nove to it all the cases in the production for <i>n</i> that begin with a terminal. We then replace all those cases in the production for <i>n</i> with a single case corresponding to the non-terminal for the new production, and we replace all the left-recursive non-terminals with the new non-terminal. 
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">number <i>n</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>l</i> <b>*</b> <i>n</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <i>l</i> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
left <i>l</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>0</b> | <b>1</b> | ... | <b>9</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
             <td></tr></table></td><td style="text-align:center;"> | </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>&#8722;</b> <i>n</i>
</td></tr></table></td></tr></table>
      </div></div>
    </div></div></div>
<a name="2a357ccdb6414725b96f52e71d55f40e"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#2a357ccdb6414725b96f52e71d55f40e">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="exercise_required"><b>Exercise:</b> 
      
<span class="text">Suppose you are given the following grammar definition and operational semantics:
<table style="padding-left:20px; margin:4px 0px 4px 0px;"><tr><td style="text-align:right; white-space:nowrap;"><table style="width:100%;"><tr><td style="text-align:right;">actor <i>r</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>foo</b> 
            |  <b>bar</b> </td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
action <i>a</i> <td></tr></table></td><td style="text-align:center;"> ::= </td><td><table style="white-space:nowrap;"><tr><td style="white-space:nowrap;"> <b>change</b> <i>r</i> | <b>is</b> <i>r</i></td></tr></table></td></tr><tr><td style="text-align:right;"><table style="width:100%;"><tr><td style="text-align:right;">
</td></tr></table></td></tr></table></span>
      <div class="inferences"><table class="inference"><tr><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>is</b> <i>r</i> &dArr; <b>is</b> <i>r</i>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>change</b> <b>foo</b> &dArr; <b>is</b> <b>bar</b>&nbsp;</td></tr></table></td></tr></table><table class="inference"><tr><td><table><tr><td class="premises">&nbsp;&nbsp;</td></tr><tr><td class="conclusion">&nbsp;<b>change</b> <b>bar</b> &dArr; <b>is</b> <b>foo</b>&nbsp;</td></tr></table></td></tr></table></div>
      
<span class="text">According to the above operational semantics, to what should <b>change foo</b> evaluate?</span>
      
<div class="solution_container"><div class="solution">
        
<span class="text">According to the second inference rule, <b>change foo</b> should evaluate to <b>is bar</b>. Notice that the above inference rules could be implemented as an evaluation algorithm, e.g. in Haskell:</span>
        
<div class="code"><div class="source"><br/><span class="keyword">data</span>&nbsp;Actor&nbsp;=&nbsp;Foo&nbsp;|&nbsp;Bar<br/><span class="keyword">data</span>&nbsp;Action&nbsp;=&nbsp;Change&nbsp;Actor&nbsp;|&nbsp;Is&nbsp;Actor<br/><br/>eval&nbsp;(Is&nbsp;r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;=&nbsp;Is&nbsp;r<br/>eval&nbsp;(Change&nbsp;Foo)&nbsp;=&nbsp;Is&nbsp;Bar<br/>eval&nbsp;(Change&nbsp;Bar)&nbsp;=&nbsp;Is&nbsp;Foo<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
      </div></div>
    </div></div></div>
<a name="e8146595d4df4e1fbc19b0f001af8dc8"></a><div class="linked block" style="white-space:nowrap;"><div style=" display:inline; vertical-align:middle;" class="link-block">[<a href="#e8146595d4df4e1fbc19b0f001af8dc8">link</a>]&nbsp;&nbsp;</div><div style=" width:100%; display:inline-block;"><div style="width:auto;" class="exercise_required"><b>Exercise:</b> 
      
<span class="text">Answer the following questions by drawing diagrams (your diagrams may need to incorporate self-loops).</span>
      <ol style="list-style-type:lower-alpha"><li>
<span class="text">Determine which of the following terms refer to <b>data structures</b>, and which terms refer to <b>algorithms</b>. Draw a flow chart incorporating all of the above components that demonstrates how they might interact in an actual implementation (there may be more than one correct answer, but the way they interact must be reasonable):
<ul>
  <li>input file;</li>
  <li>abstract syntax trees;</li>
  <li>parser;</li>
  <li>compiler;</li>
  <li>type checker;</li>
  <li>error message;</li>
  <li>loop unroller;</li>
  <li>machine instruction sequences.</li>
</ul></span>
<div class="solution_container"><div class="solution">
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">input<br/>file</td>
    <td></td>
    <td class="box" style="background-color:lightyellow;">loop<br/>unroller</td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td class="box" style="background-color:powderblue;">machine<br/>instruction<br/>sequences</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td></td>
    <td><span style="font-size:20px;">&uArr; &dArr;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td><span style="font-size:20px;">&uArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">parser</td>
    <td><span style="font-size:20px;">&rArr;</span></td>
    <td class="box" style="background-color:powderblue;">abstract<br/>syntax<br/>trees</td>
    <td><span style="font-size:20px;">&rArr;</span></td>
    <td class="box" style="background-color:lightyellow;">type<br/>checker</td>
    <td><span style="font-size:20px;">&rArr;</span></td>
    <td class="box" style="background-color:powderblue;">abstract<br/>syntax<br/>trees</td>
    <td><span style="font-size:20px;">&rArr;</span></td>
    <td class="box" style="background-color:lightyellow;">compiler</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td class="box" style="background-color:powderblue;">error<br/>messages</td>
    <td></td>
    <td></td>
    <td></td>
    <td class="box" style="background-color:powderblue;">error<br/>messages</td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
</table>
</div>
          </div></div></li><li>
<span class="text">Draw a flow chart incorporating all of the below components that demonstrates how they might interact in an actual implementation:
<ul>
  <li>exhaustive case generator;</li>
  <li>abstract syntax trees;</li>
  <li>compiler;</li>
  <li>interpreter;</li>
  <li>machine instruction sequences;</li>
  <li>simulator;</li>
  <li>outputs;</li>
  <li>output comparison function.</li>
</ul></span>
<div class="solution_container"><div class="solution">
<div class="diagram">
<table class="container">
  <tr>
    <td colspan="3" class="box" style="background-color:lightyellow;">exhaustive<br/>case<br/>generator</td>
    <td colspan="2"></td>
  </tr>
  <tr>
    <td colspan="3"><span style="font-size:20px;">&dArr;</span></td>
    <td colspan="2"></td>
  </tr>
  <tr>
    <td colspan="3" class="box" style="background-color:powderblue;">abstract<br/>syntax<br/>trees</td>
    <td colspan="2"></td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td></td>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td colspan="2"></td>
  </tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">interpreter</td>
    <td></td>
    <td class="box" style="background-color:lightyellow;">compiler</td>
    <td><span style="font-size:20px;">&rArr;</span></td>
    <td class="box" style="background-color:powderblue;">machine<br/>instruction<br/>sequences</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:powderblue;">outputs</td>
    <td></td>
    <td class="box" style="background-color:powderblue;">outputs</td>
    <td><span style="font-size:20px;">&lArr;</span></td>
    <td class="box" style="background-color:lightyellow;">simulator</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td></td>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td colspan="3" class="box" style="background-color:lightyellow;">output<br/>comparison<br/>function</td>
    <td></td>
    <td></td>
  </tr>
</table>
</div>
          </div></div></li></ol>
    </div></div></div>
</div><a name="F.1"></a><div class="final"><hr style="margin-bottom:120px;"/><h2 class="linked"><span class="link-title">[<a href="#F.1">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">Final.</span> Programming Language Concepts</h2><div class="instructions">
      
<span class="text"><i>This material is no longer available.</i></span>
    </div>
</div><a name="A"></a><div class="appendix"><hr style="margin-bottom:120px;"/><h2 class="linked"><span class="link-title">[<a href="#A">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">Appendix A.</span> Python</h2>
<span class="text">The Python programming language will be among the languages we use in this course. This language supports the object-oriented, imperative, and functional programming paradigms, has automatic memory managememt, and natively supports common high-level data structures such as lists and sets. Python is often used as an interpreted language, but it can also be compiled.</span><a name="A.1"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#A.1">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">A.1.</span> Obtaining Python</h3>
<span class="text">The latest version of Python 3 can be downloaded at: <b><a href="http://www.python.org/getit/">http://www.python.org/getit/</a></b>. In this course, we will require the use if <b>Python 3</b>, which has been installed on all the <a href="http://www.bu.edu/cs/resources/laboratories/undergraduate-lab/">CS Department's undergraduate computing lab</a> machines, as well as on <code>csa2/csa3</code>.</span></div><a name="A.2"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#A.2">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">A.2.</span> Common data structures (i.e., Python expressions)</h3>
<span class="text">Python provides native support for several data structures that we will use throughout this course: integers, strings, lists, tuples, sets, and dictionaries (also known as finite maps). In this subsection, we present how instances of these data structures are represented in Python, as well as the most common operations and functions that can be applied to these data structure instances.</span><ul><li>
<span class="text"><b>Booleans</b> consist of two constants: <code>True</code> and <code>False</code>.</span><ul><li>The usual logical operations are available using the operators <code>and</code>, <code>or</code>, and <code>not</code>.</li></ul>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;True&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;A&nbsp;boolean&nbsp;constant.</span><br/>True<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;False&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;A&nbsp;boolean&nbsp;constant.</span><br/>False<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;True&nbsp;<span class="keyword">and</span>&nbsp;False&nbsp;<span class="keyword">or</span>&nbsp;True&nbsp;<span class="keyword">and</span>&nbsp;(<span class="keyword">not</span>&nbsp;False)&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;A&nbsp;boolean&nbsp;expression.</span><br/>True<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li><li>
<span class="text"><b>Integers</b> are written as in most other programming languages (i.e., as a sequence of digits).</span><ul><li>The usual arithmetic operations are available using the operators <code>+</code>, <code>*</code>, <code>-</code>, and <code>/</code>. The infix operator <code>//</code> represents integer division, and the infix operators <code>**</code> represents exponentiation. Negative integers are prefixed with the negation operator <code>-</code>.</li><li>The usual relational operators <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> are available.</li><li>The <code>int()</code> function can convert a string that looks like an integer into an integer.</li></ul>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;123&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;An&nbsp;integer&nbsp;constant.</span><br/>123<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;1&nbsp;*&nbsp;(2&nbsp;+&nbsp;3)&nbsp;//&nbsp;4&nbsp;-&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;An&nbsp;integer&nbsp;expression.</span><br/>-4<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;4&nbsp;*&nbsp;5&nbsp;>=&nbsp;19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;A&nbsp;boolean&nbsp;expression&nbsp;involving&nbsp;integers.</span><br/>True<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;int(<span class="literal">"123"</span>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;A&nbsp;string&nbsp;being&nbsp;converted&nbsp;into&nbsp;an&nbsp;integer</span><br/>123<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li><li>
<span class="text"><b>Strings</b> are delimited by either <code>'</code> or <code>"</code> characters. Strings can be treated as lists of single-character strings. Another way to look at this is that there is no distinction between a character and a string: all characters are just strings of length 1. Multiline strings can be delimited using <code>"""</code> or <code>'''</code> (i.e., three quotation mark characters at the beginning and end of the string literal).</span><ul><li>The empty string is denoted using <code>''</code> or <code>""</code>.</li><li>Two strings can be concatenated using <code>+</code>.</li><li>The function <code>len()</code> returns the length of a string.</li><li>Individual characters in a string can be accessed using the bracketed index notation (e.g., <code>s[i]</code>). These characters are also strings themselves.</li></ul>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;<span class="literal">'Example.'</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;A&nbsp;string.</span><br/><span class="literal">'Example.'</span><br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;<span class="literal">"Example."</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Alternate&nbsp;notation&nbsp;for&nbsp;a&nbsp;string.</span><br/><span class="literal">'Example.'</span><br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;len(<span class="literal">"ABCD"</span>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;String&nbsp;length.</span><br/>4<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;<span class="literal">"ABCD"</span>&nbsp;+&nbsp;<span class="literal">"EFG"</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;String&nbsp;concatenation.</span><br/><span class="literal">'ABCDEFG'</span><br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;<span class="literal">"ABCD"</span>[2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Third&nbsp;character&nbsp;in&nbsp;the&nbsp;string.</span><br/><span class="literal">'C'</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li><li>
<span class="text"><b>Lists</b> are similar to arrays: they are ordered sequences of objects and/or values. The entries of a list can be of a mixture of different types, and lists containing one or more objects are delimited using <code>[</code> and <code>]</code>, with the individual list entries separated by commas. Lists cannot be members of sets.</span><ul><li>The empty list is denoted using <code>[]</code>.</li><li>Two lists can be concatenated using <code>+</code>.</li><li>The function <code>len()</code> returns the length of a list.</li><li>Individual entries in a list can be accessed using the bracketed index notation (e.g., <code>a[i]</code>).</li><li>To check if a value is in a list, use the <code>in</code> relational operator.</li></ul>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;[1,2,<span class="literal">"A"</span>,<span class="literal">"B"</span>]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;A&nbsp;list.</span><br/>[1,&nbsp;2,&nbsp;<span class="literal">'A'</span>,&nbsp;<span class="literal">'B'</span>]<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;[1,&nbsp;2]&nbsp;+&nbsp;[<span class="literal">'A'</span>,<span class="literal">'B'</span>]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Concatenating&nbsp;lists.</span><br/>[1,&nbsp;2,&nbsp;<span class="literal">'A'</span>,&nbsp;<span class="literal">'B'</span>]<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;len([1,2,<span class="literal">"A"</span>,<span class="literal">"B"</span>]&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;List&nbsp;length.</span><br/>4<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;[1,2,<span class="literal">"A"</span>,<span class="literal">"B"</span>][0]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;First&nbsp;entry&nbsp;in&nbsp;the&nbsp;list.</span><br/>1<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;1&nbsp;in&nbsp;[1,&nbsp;2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;List&nbsp;containment&nbsp;check.</span><br/>True<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li><li>
<span class="text"><b>Tuples</b> are similar to lists (they are ordered, and can contain objects of different types), except they are delimited by parentheses <code>(</code> and <code>)</code>, with entries separated by commas. The main distinction between lists and tuples is that tuples are hashable (i.e., they can be members of sets).</span><ul><li>The empty tuple is denoted using <code>()</code>.</li><li>A tuple containing a single object <code>x</code> is denoted using <code>(x, )</code>.</li><li>Two tuples can be concatenated using <code>+</code>.</li><li>A tuple can be turned into a list using the <code>list()</code> function.</li><li>A list can be turned into a tuple using the <code>tuple()</code> function.</li><li>The function <code>len()</code> returns the length of a tuple.</li><li>Individual entries in a tuple can be accessed using the bracketed index notation (e.g., <code>t[i]</code>).</li><li>To check if a value is in a tuple, use the <code>in</code> relational operator.</li></ul>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;(1,2,<span class="literal">"A"</span>,<span class="literal">"B"</span>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;A&nbsp;tuple.</span><br/>(1,&nbsp;2,&nbsp;<span class="literal">'A'</span>,&nbsp;<span class="literal">'B'</span>)<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;(1,)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Another&nbsp;tuple.</span><br/>(1,)<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;(1,&nbsp;2)&nbsp;+&nbsp;(<span class="literal">'A'</span>,<span class="literal">'B'</span>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Concatenating&nbsp;tuples.</span><br/>(1,&nbsp;2,&nbsp;<span class="literal">'A'</span>,&nbsp;<span class="literal">'B'</span>)<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;list((1,&nbsp;2,&nbsp;<span class="literal">'A'</span>,<span class="literal">'B'</span>))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;A&nbsp;tuple&nbsp;being&nbsp;converted&nbsp;into&nbsp;a&nbsp;list.</span><br/>[1,&nbsp;2,&nbsp;<span class="literal">'A'</span>,&nbsp;<span class="literal">'B'</span>]<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;tuple([1,&nbsp;2,&nbsp;<span class="literal">'A'</span>,<span class="literal">'B'</span>])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;A&nbsp;list&nbsp;being&nbsp;converted&nbsp;into&nbsp;a&nbsp;tuple.</span><br/>(1,&nbsp;2,&nbsp;<span class="literal">'A'</span>,&nbsp;<span class="literal">'B'</span>)<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;len((1,2,<span class="literal">"A"</span>,<span class="literal">"B"</span>))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Tuple&nbsp;length.</span><br/>4<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;(1,2,<span class="literal">"A"</span>,<span class="literal">"B"</span>)[0]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;First&nbsp;entry&nbsp;in&nbsp;the&nbsp;tuple.</span><br/>1<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;1&nbsp;in&nbsp;(1,&nbsp;2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Tuple&nbsp;containment&nbsp;check.</span><br/>True<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li><li>
<span class="text"><b>Sets</b> are unordered sequences that cannot contain duplicates. They are a close approximation of mathematical sets. Sets cannot be members of sets.</span><ul><li>The empty set is denoted using <code>set()</code>.</li><li>The methods <code>.union()</code> and <code>.intersect</code> correspond to the standard set operations.</li><li>A list or tuple can be turned into a set using the <code>set()</code> function.</li><li>A set can be turned into a list or tuple using the <code>list()</code> or <code>list()</code> function, respectively.</li><li>The function <code>len()</code> returns the size of a set.</li><li>To access individual entries in a set, it is necessary to turn the set into a list or tuple.</li><li>To check if a value is in a set, use the <code>in</code> relational operator.</li></ul>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;{1,2,<span class="literal">"A"</span>,<span class="literal">"B"</span>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;A&nbsp;set.</span><br/>{1,&nbsp;2,&nbsp;<span class="literal">'A'</span>,&nbsp;<span class="literal">'B'</span>}<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;({1,2}.union({3,4})).intersection({4,5})&nbsp;&nbsp;<span class="comment">#&nbsp;Set&nbsp;operations.</span><br/>{4}<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;set([1,&nbsp;2]).union(set((<span class="literal">'A'</span>,<span class="literal">'B'</span>)))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Converting&nbsp;a&nbsp;list&nbsp;and&nbsp;a&nbsp;tuple&nbsp;to&nbsp;sets.</span><br/>{<span class="literal">'A'</span>,&nbsp;1,&nbsp;2,&nbsp;<span class="literal">'B'</span>}<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;len({1,2,<span class="literal">"A"</span>,<span class="literal">"B"</span>})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Set&nbsp;size.</span><br/>4<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;1&nbsp;in&nbsp;{1,2,<span class="literal">"A"</span>,<span class="literal">"B"</span>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Tuple&nbsp;containment&nbsp;check.</span><br/>True<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li><li>
<span class="text"><b>Frozen sets</b> are like sets, except they can be members of other sets. A set can be turned into a frozen set using the <code>frozenset()</code> function.</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;frozenset({1,2,3})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;A&nbsp;frozen&nbsp;set.</span><br/>frozenset({1,&nbsp;2,&nbsp;3})<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;{frozenset({1,2}),&nbsp;frozenset({3,4})}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Set&nbsp;of&nbsp;frozen&nbsp;sets.</span><br/>{frozenset({3,&nbsp;4}),&nbsp;frozenset({1,&nbsp;2})}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li><li>
<span class="text"><b>Dictionaries</b> are unordered collections of associations between some set of keys and some set of values. Dictionaries are also known as finite maps.</span><ul><li>The empty dictionary is denoted using <code>{}</code>.</li><li>The list of keys that the dictionary associates with values can be obtained using <code>list(d.keys())</code>.</li><li>The list of values that the dictionary contains can be obtained using <code>list(d.values())</code>.</li><li>The function <code>len()</code> returns the number of entries in the dictionary.</li><li>Individual entries in a dictionary can be accessed using the bracketed index notation (e.g., <code>d[key]</code>).</li></ul>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;{<span class="literal">"A"</span>:1,&nbsp;<span class="literal">"B"</span>:2}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;A&nbsp;dictionary.</span><br/>{<span class="literal">'A'</span>:&nbsp;1,&nbsp;<span class="literal">'B'</span>:&nbsp;2}<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;list({<span class="literal">"A"</span>:1,&nbsp;<span class="literal">"B"</span>:2}.keys())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Dictionary&nbsp;keys.</span><br/>[<span class="literal">'A'</span>,&nbsp;<span class="literal">'B'</span>]<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;list({<span class="literal">"A"</span>:1,&nbsp;<span class="literal">"B"</span>:2}.values())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Dictionary&nbsp;values.</span><br/>[1,&nbsp;2]<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;len({<span class="literal">"A"</span>:1,&nbsp;<span class="literal">"B"</span>:2})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Dictionary&nbsp;size.</span><br/>2<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;{<span class="literal">"A"</span>:1,&nbsp;<span class="literal">"B"</span>:2}[<span class="literal">"A"</span>]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Obtain&nbsp;a&nbsp;dictionary&nbsp;value&nbsp;using&nbsp;a&nbsp;key.</span><br/>1<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li></ul></div><a name="A.3"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#A.3">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">A.3.</span> Other Python expressions</h3>
<span class="text">Python provides concise notations for defining data structures and performing logical computations. In particular, it support a comprehension notation that can be used to build lists, tuples, sets, and dictionaries.</span><ul><li>
<span class="text"><b>List comprehensions</b> make it possible to construct a list by iterating over one or more other data structure instances (such as a list, tuple, set, or dictionary) and performing some operation on each element or combination of elements. The resulting list will contain the result of evaluating the body for every combination.</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;[&nbsp;x&nbsp;for&nbsp;x&nbsp;in&nbsp;[1,2,3]&nbsp;]<br/>[1,&nbsp;2,&nbsp;3]<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;[&nbsp;2&nbsp;*&nbsp;x&nbsp;for&nbsp;x&nbsp;in&nbsp;{1,2,3}&nbsp;]<br/>[2,&nbsp;4,&nbsp;6]<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;[&nbsp;x&nbsp;+&nbsp;y&nbsp;for&nbsp;x&nbsp;in&nbsp;{1,2,3}&nbsp;for&nbsp;y&nbsp;in&nbsp;(1,2,3)&nbsp;]<br/>[2,&nbsp;3,&nbsp;4,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;4,&nbsp;5,&nbsp;6]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">It is also possible to add conditions anywhere after the first <code>for</code> clause. This will filter which combinations are actually used to add a value to the resulting list.</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;[&nbsp;x&nbsp;for&nbsp;x&nbsp;in&nbsp;{1,2,3}&nbsp;if&nbsp;x&nbsp;<&nbsp;3&nbsp;]<br/>[1,&nbsp;2]<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;[&nbsp;x&nbsp;+&nbsp;y&nbsp;for&nbsp;x&nbsp;in&nbsp;{1,2,3}&nbsp;for&nbsp;y&nbsp;in&nbsp;(1,2,3)&nbsp;if&nbsp;x&nbsp;>&nbsp;2&nbsp;and&nbsp;y&nbsp;>&nbsp;1&nbsp;]<br/>[5,&nbsp;6]<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li><li>
<span class="text"><b>Set comprehensions</b> make it possible to construct a set by iterating over one or more other data structure instances (such as a list, tuple, set, or dictionary) and performing some operation on each element or combination of elements. The resulting list will contain the result of evaluating the body for every combination. Notice that the result will contain no duplicates because the result is a set.</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;{&nbsp;x&nbsp;for&nbsp;x&nbsp;in&nbsp;[1,2,3,1,2,3]&nbsp;}<br/>{1,&nbsp;2,&nbsp;3}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li><li>
<span class="text"><b>Dictionary comprehensions</b> make it possible to construct a dictionary by iterating over one or more other data structure instances (such as a list, tuple, set, or dictionary) and performing some operation on each element or combination of elements. The resulting dictionary will contain the result of evaluating the body for every combination.</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;{&nbsp;key&nbsp;:&nbsp;2&nbsp;for&nbsp;key&nbsp;in&nbsp;[<span class="literal">"A"</span>,<span class="literal">"B"</span>,<span class="literal">"C"</span>]&nbsp;}<br/>{<span class="literal">'A'</span>:&nbsp;2,&nbsp;<span class="literal">'C'</span>:&nbsp;2,&nbsp;<span class="literal">'B'</span>:&nbsp;2}<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li></ul></div><a name="A.4"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#A.4">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">A.4.</span> Other useful built-in functions</h3>
<span class="text">The built-in function <code>type()</code> can be used to determine the type of a value. Below, we provide examples of how to check whether a given expression has one of the common Python types:</span>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;type(True)&nbsp;==&nbsp;bool<br/>True<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;type(123)&nbsp;==&nbsp;int<br/>True<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;type(<span class="literal">"ABC"</span>)&nbsp;==&nbsp;str<br/>True<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;type([1,2,3])&nbsp;==&nbsp;list<br/>True<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;type((<span class="literal">"A"</span>,1,{1,2}))&nbsp;==&nbsp;tuple<br/>True<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;type({1,2,3})&nbsp;==&nbsp;set<br/>True<br/><span style="color:#ABABAB;">&gt;&gt;&gt;</span>&nbsp;type({<span class="literal">"A"</span>:1,&nbsp;<span class="literal">"B"</span>:2})&nbsp;==&nbsp;dict<br/>True<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></div><a name="A.5"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#A.5">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">A.5.</span> Common Python definition and control constructs (i.e., Python statements)</h3>
<span class="text">A Python program is a sequence of Python statements. Each statement is either a function definition, a variable assignment, a conditional statement (i.e., <code>if</code>, <code>else</code>, and/or <code>elif</code>), an iteration construct (i.e., a <code>for</code> or <code>while</code> loop), a <code>return</code> statement, or a <code>break</code> or <code>continue</code> statement.</span><ul><li>
<span class="text"><b>Variable assignments</b> make it possible to assign a value or object to a variable.</span>
<div class="code"><div class="source"><br/>x&nbsp;=&nbsp;10<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">It is also possible to assign a tuple (or any computation that produces a tuple) to another tuple:</span>
<div class="code"><div class="source"><br/>(x,&nbsp;y)&nbsp;=&nbsp;(1,&nbsp;2)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li><li>
<span class="text"><b>Function and procedure definitions</b> consist of the <code>def</code> keyword, followed by the name of the function or procedure, and then by one or more arguments (delimited by parentheses and separated by commas).</span>
<div class="code"><div class="source"><br/><span class="keyword">def</span>&nbsp;example(a,&nbsp;b,&nbsp;c):<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;a&nbsp;+&nbsp;b&nbsp;+&nbsp;c<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li><li>
<span class="text"><b>Conditional statements</b> consist of one or more branches, each with its own boolean expression as the condition (with the exception of <code>else</code>). The body of each branch is an indented sequence of statements.</span>
<div class="code"><div class="source"><br/><span class="keyword">def</span>&nbsp;fibonacci(n):<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Computes&nbsp;the&nbsp;nth&nbsp;Fibonacci&nbsp;number.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;n&nbsp;&lt;=&nbsp;0:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;0<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">elif</span>&nbsp;n&nbsp;&lt;=&nbsp;2:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;1<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;fibonacci(n-1)&nbsp;+&nbsp;fibonacci(n-2)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li><li>
<span class="text"><b>Iteration constructs</b> make it possible to repeat a sequence of statements over and over. The body of an iteration construct is an indented sequence of statements.</span><ul><li>
<span class="text">The <b>while</b> construct has a boolean expression as its condition (much like <code>if</code>). The body is executed over and over until the expression in the condition evaluates to <code>False</code>, or a <code>break</code> statement is encountered.</span>
<div class="code"><div class="source"><br/><span class="keyword">def</span>&nbsp;example1(n):<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Takes&nbsp;an&nbsp;integer&nbsp;n&nbsp;and&nbsp;returns&nbsp;the&nbsp;sum&nbsp;of</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;the&nbsp;integers&nbsp;from&nbsp;1&nbsp;to&nbsp;n-1.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;0<br/>&nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;=&nbsp;0<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;i&nbsp;<&nbsp;n:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;=&nbsp;sum&nbsp;+&nbsp;i<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;i&nbsp;+&nbsp;1<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;sum<br/><br/><span class="keyword">def</span>&nbsp;example2(n):<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Takes&nbsp;an&nbsp;integer&nbsp;n&nbsp;and&nbsp;returns&nbsp;the&nbsp;sum&nbsp;of</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;the&nbsp;integers&nbsp;from&nbsp;1&nbsp;to&nbsp;n-1.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;0<br/>&nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;=&nbsp;0<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>&nbsp;True:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;=&nbsp;sum&nbsp;+&nbsp;i<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;i&nbsp;+&nbsp;1<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;i&nbsp;==&nbsp;n:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">break</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;sum<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li><li>
<span class="text">The <b>for</b> construct makes it possible to repeat a sequence of statements once for every object in a list, tuple, or set, or once for every key in a dictionary.</span>
<div class="code"><div class="source"><br/><span class="keyword">def</span>&nbsp;example3(n):<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Takes&nbsp;an&nbsp;integer&nbsp;n&nbsp;and&nbsp;returns&nbsp;the&nbsp;sum&nbsp;of</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;the&nbsp;integers&nbsp;from&nbsp;1&nbsp;to&nbsp;n-1.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;=&nbsp;0<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;in&nbsp;range(0,n):<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;=&nbsp;sum&nbsp;+&nbsp;i<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;sum<br/><br/><span class="keyword">def</span>&nbsp;example4(d):<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;Takes&nbsp;a&nbsp;dictionary&nbsp;d&nbsp;that&nbsp;maps&nbsp;keys&nbsp;to</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">#&nbsp;integers&nbsp;and&nbsp;returns&nbsp;the&nbsp;sum&nbsp;of&nbsp;the&nbsp;integers.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;=&nbsp;0<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;key&nbsp;in&nbsp;d:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;=&nbsp;sum&nbsp;+&nbsp;d[key]<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;sum<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li></ul></li></ul></div></div><a name="B"></a><div class="appendix"><hr style="margin-bottom:120px;"/><h2 class="linked"><span class="link-title">[<a href="#B">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">Appendix B.</span> Haskell</h2>
<span class="text">The Haskell programming language will be among the languages we use in this course. This language supports the functional programming paradigm, has automatic memory managememt, and natively supports algebraic data types. Haskell is both an interpreted and compiled language.</span><a name="B.1"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#B.1">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">B.1.</span> Obtaining Haskell</h3>
<span class="text">The latest version of Haskell can be downloaded with the Haskell Platform: <b><a href="http://www.haskell.org/platform/">http://www.haskell.org/platform/</a></b>. The Haskell Platform has been installed on all the <a href="http://www.bu.edu/cs/resources/laboratories/undergraduate-lab/">CS Department's undergraduate computing lab</a> machines, as well as on <code>csa2/csa3</code>.</span></div><a name="B.2"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#B.2">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">B.2.</span> Haskell modules and declarations</h3>
<span class="text">Haskell code is organized into <i>modules</i>. There is one named module per Haskell file, and the file name should match the module name (e.g., the file <code>Example.hs</code> should contain the <code>Example</code> module definition). The module body consists of a series of declarations, which can appear in any order; the only exception is that if there are multiple declarations for a function, they must all be grouped together.</span>
<div class="code"><div class="source"><br/><span class="keyword">module</span>&nbsp;Example&nbsp;<span class="keyword">where</span><br/><br/>g&nbsp;(x)&nbsp;=&nbsp;f(x)&nbsp;+&nbsp;f(x);<br/><br/>f&nbsp;(0)&nbsp;=&nbsp;0;<br/>f&nbsp;(x)&nbsp;=&nbsp;f(x&nbsp;-&nbsp;1)&nbsp;+&nbsp;1;<br/><br/><span class="comment">--&nbsp;This&nbsp;is&nbsp;a&nbsp;comment.</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div>
<span class="text">Each declaration in a Haskell module falls into one of two categories: an expression-level declaration, or a type-level declaration. Any declaration that defines variables or functions is an expression-level declaration; any declaration that defines a type is a type-level declaration.</span>
<div class="code"><div class="source"><br/><span class="comment">--&nbsp;Expression-level&nbsp;declaration&nbsp;(defines&nbsp;a&nbsp;new&nbsp;function&nbsp;called&nbsp;"f").</span><br/>f(x)&nbsp;=&nbsp;2&nbsp;*&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/><br/><span class="comment">--&nbsp;Type-level&nbsp;declaration&nbsp;(defines&nbsp;a&nbsp;new&nbsp;data&nbsp;type&nbsp;called&nbsp;"Tree".</span><br/><span class="keyword">data</span>&nbsp;Tree&nbsp;=&nbsp;Leaf&nbsp;|&nbsp;Node&nbsp;Tree&nbsp;Tree&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></div><a name="B.3"></a><div class="subsection"><h3 class="linked"><span class="link-title">[<a href="#B.3">link</a>]&nbsp;&nbsp;</span><span class="header_numeral">B.3.</span> Common data structures (i.e., Haskell expressions)</h3>
<span class="text">The Haskell <a href="http://hackage.haskell.org/package/base">base</a> library (sometimes also called the "Prelude", and imported implicitly and automatically into every module) has a large number of standard and conventional data type and function declarations. These declarations provide native support for a variety of data structures and operations that we will use throughout this course: integers, strings, lists, and tuples, among others. In this subsection, we present how instances of these data structures are represented in Haskell, as well as the most common operations and functions that can be applied to these data structure instances.</span><ul><li>
<span class="text">The <b>Bool</b> data type supports two constructors: <code>True</code> and <code>False</code>.</span><ul><li>The usual logical operations are available using the operators <code>&&</code>, <code>||</code>, and <code>not</code>.</li><li>The built-in syntax <code>if ... then ... else ...</code> is also available (similar to Python's <code>... if ... else ...</code> and C/C++/Java's ternary operator <code> ... ? ... : ...</code>.</li></ul>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;True<br/>True<br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;False<br/>False<br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;True&nbsp;||&nbsp;False&nbsp;&&&nbsp;True&nbsp;&&&nbsp;(not&nbsp;False)<br/>True<br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;<span class="keyword">if</span>&nbsp;True&nbsp;<span class="keyword">then</span>&nbsp;<span class="literal">"Yes"</span>&nbsp;<span class="keyword">else</span>&nbsp;<span class="literal">"No"</span><br/><span class="literal">"Yes"</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li><li>
<span class="text"><b>Integers</b> are written as in most other programming languages (i.e., as a sequence of digits). Haskell supports a bounded-size type <code>Int</code> and an unbounded-size type <code>Integer</code>.</span><ul><li>The usual arithmetic operations are available using the operators <code>+</code>, <code>*</code>, <code>-</code>, <code>/</code>, and <code>^</code>. The <code>Prelude</code> function <code>div</code> represents integer division. The <code>Prelude</code> functions <code>min</code> and <code>max</code> make it possible to compute the minimum and maximum of two integers, respectively, and the function <code>minimum</code> and <code>maximum</code> make it possible to compute the minimum and maximum of a list of integers. Negative integers are prefixed with the negation operator <code>-</code>.</li><li>The usual relational operators <code>==</code>, <code>/=</code> (not equal), <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> are available.</li></ul>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;123<br/>123<br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;1&nbsp;*&nbsp;(2&nbsp;+&nbsp;3)&nbsp;`div`&nbsp;4&nbsp;-&nbsp;5<br/>-4<br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;4&nbsp;*&nbsp;5&nbsp;>=&nbsp;19<br/>True<br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;max&nbsp;10&nbsp;20<br/>20<br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;minimum&nbsp;[1,2,3]<br/>1<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li><li>
<span class="text"><b>Strings</b> are delimited by <code>"</code> characters (individual characters are always delimited using <code>'</code>). Strings can be treated as lists of characters.</span><ul><li>The empty string is denoted using <code>""</code>.</li><li>Two strings can be concatenated using <code>++</code>.</li><li>The <code>Prelude</code>function <code>length</code> returns the length of a string.</li></ul>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;<span class="literal">"Example."</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">--&nbsp;A&nbsp;string.</span><br/><span class="literal">"Example."</span><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;length&nbsp;<span class="literal">"ABCD"</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">--&nbsp;String&nbsp;length.</span><br/>4<br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;<span class="literal">"ABCD"</span>&nbsp;++&nbsp;<span class="literal">"EFG"</span>&nbsp;&nbsp;&nbsp;<span class="comment">--&nbsp;String&nbsp;concatenation.</span><br/><span class="literal">"ABCDEFG"</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li><li>
<span class="text"><b>Lists</b> are ordered sequences of expressions. The entries of a list must all be of the same type. Lists are delimited using <code>[</code> and <code>]</code>, with the individual list entries separated by commas.</span><ul><li>The empty list is denoted using <code>[]</code>.</li><li>Elements can be added to the front of a list using <code>:</code>.</li><li>Two lists can be concatenated using <code>++</code>.</li><li>The <code>Prelude</code> function <code>length</code> returns the length of a list.</li><li>To check if a value is in a list, use the <code>Prelude</code> function <code>elem</code> (note that this relies on the <code>==</code> operation being defined on the type of the elements in the list).</li></ul>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;[1,2,3]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">--&nbsp;A&nbsp;list.</span><br/>[1,2,3]<br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;1&nbsp;:&nbsp;[2,3]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">--&nbsp;Adding&nbsp;an&nbsp;element&nbsp;to&nbsp;the&nbsp;front.</span><br/>[1,2,3]<br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;[1,2,3]&nbsp;++&nbsp;[4,5]&nbsp;&nbsp;&nbsp;<span class="comment">--&nbsp;Concatenating&nbsp;lists.</span><br/>[1,2,3,4,5]<br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;length&nbsp;[1,2,3,4]&nbsp;&nbsp;&nbsp;<span class="comment">--&nbsp;List&nbsp;length.</span><br/>4<br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;1&nbsp;`elem`&nbsp;[1,&nbsp;2]&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">--&nbsp;List&nbsp;containment&nbsp;check.</span><br/>True<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li><li>
<span class="text"><b>Tuples</b> are ordered, and can contain expressions of different types. They are delimited by parentheses <code>(</code> and <code>)</code>, with entries separated by commas.</span><ul><li>The empty tuple is denoted using <code>()</code>.</li><li>There are no tuples containing a single element; <code>(e)</code> is equivalent to <code>e</code> for any Haskell expression <code>e</code>.</li></ul>
<div class="code"><div class="source"><br/><span style="color:#ABABAB;">*&gt;</span>&nbsp;(1,2,3)&nbsp;&nbsp;<span class="comment">--&nbsp;A&nbsp;tuple.</span><br/>(1,2,3)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div></div></li></ul></div></div>
</div></body>
</html>
<!--eof-->
