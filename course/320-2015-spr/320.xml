<sheaf title="BU CAS CS 320 Spring 2015">
  <section title="Introduction, Background, and Motivation">
    <subsection title="Overview">
      <text>
A large variety of modern technology, from mobile devices and personal computers to datacenters and entire infrastructures, are programmable. These entities are controlled, operated, maintained, and monitored using a variety of interfaces and languages, which might take the form of graphical user interfaces, libraries, APIs, embedded languages, domain-specific languages, and general-purpose programming languages.
      </text>
      <text>
Many of these interfaces and languages are defined and designed according to principles and conventions that have been developed over the last several decades.
      </text>
      <text>
There are three major themes around which this course is organized. Each of the concepts, examples, and problems discussed in this course will relate to one or more of these themes:
      </text>
      <orderedlist>
        <item title="Defining and working with programming languages">
We will define and become familiar with the basic concepts that underlie the definition and design of common programming languages, and we will learn to identify and implement the common components found in static analysis tools, interpreters, and compilers.
        </item>
        <item title="Programming paradigms">
You should now be familiar with the imperative and object-oriented programming paradigms. In this course, we will provide a high-level picture of the landscape of different programming paradigms, and will focus in particular on the declarative and functional programming paradigms. We will learn to identify problems that can be solved more efficiently, more concisely, and with greater generality using programming languages that support the functional and declarative paradigms. This includes gaining experience taking advantage of features such as comprehensions, algebraic data types, static type checking, and higher-order functions, and techniques such as recursion.
        </item>
        <item title="Languages as solutions">
The purpose of a programming language is to provide a data representation and storage format, a communication protocol, or a control interface that can be used across time and space, between different humans and/or devices. Thus, as with any language, any programming language can be viewed as a solution to a representation, communication, or control problem. We will learn to identify when a programming language may be an appropriate solution for a problem, what trade-offs should be considered when deciding whether to design a point solution or a language, and what are some of the appropriate mathematical concepts and software tools for doing so.
        </item>
      </orderedlist>
      <text><![CDATA[
Throughout this course, we use formal mathematical conventions and notations developed by the community of computer scientists and mathematicians to communicate with one another about the definitions and implementations of programming languages. Some of these notations are used throughout mathematics and computer science, while others are more obscure and are used primarily by the community of programming language theorists. Throughout your career, you will be required to learn a variety of new notations for a variety of new technologies. This course provides an opportunity to <i>practice learning new notations</i> quickly. This is a valuable skill to possess even if your area of expertise lies or will lie outside the topics covered in this course.
      ]]></text>
    </subsection>
    <subsection title="Background and prerequisites">
      <paragraph title="Basic logic" hooks="math"><![CDATA[
It is expected that the reader is familiar with the basic concepts of mathematical logic, including formulas, predicates, relational operators, and terms.
      ]]></paragraph>
      <paragraph title="Basic set theory" hooks="math"><![CDATA[
It is expected that the reader is familiar with the notion of a set (both finite and infinite), set size, and the set comprehension notation, e.g.,
\begin{eqnarray}
  {1,2,3,4} is a set
\end{eqnarray}
\begin{eqnarray}
  { %x | %x \in \Z, %x > 0 } & = & {1, 2, 3, ...}
\end{eqnarray}
and the membership and subset relations between elements and sets, e.g.,
\begin{eqnarray}
  1 & \in & { 1, 2, 3 } \\
  {2, 3} & \subset & { 1, 2, 3 }
\end{eqnarray}
      ]]></paragraph>
      <paragraph title="Programming using imperative and object-oriented language"><![CDATA[
It is expected that the reader is familiar with at least one imperative, object-oriented language, such as Java, C++, or Python.
      ]]></paragraph>
    </subsection>
  </section>
  <section title="Defining Programming Languages">
    <text><![CDATA[
In order to define and reason about programming languages, and in order to write automated tools and algorithms that can operate on programs written using programming languagues, we must be able to define formally (i.e., mathematically) what is a programming language and what is a program.
    ]]></text>
    <subsection title="Sets of character strings">
      <text><![CDATA[
In computer science, one common way to mathematically model a formal language is to introduce a finite set of symbols (an <i>alphabet</i>). A <i>language</i> is then any subset of the set of all strings consisting of symbols from that alphabet.
      ]]></text>
      <definition required="true" hooks="math" id="95e72ad05e66427281549720c9ed975f"><![CDATA[
An <i>alphabet</i> is a finite set %A. We will call elements %a \in %A of the set <i>characters</i>. The typical alphabet we will use in this course is the set of 128 <a href="http://en.wikipedia.org/wiki/Ascii">ASCII</a> characters. However, any finite set can be an alphabet.
      ]]></definition>
      <definition required="true" hooks="math" id="3822c49489b942f59671177f1ada70ca"><![CDATA[
Given an alphabet %A, a <i>character string</i> or <i>string</i> is any ordered finite sequence of characters from that alphabet. We will denote the empty string (containing no characters) using the symbol \varepsilon, and we will denote the length of a string %s using the notation |%s|.
      ]]></definition>
      <example required="true" hooks="math" id="daa30c4fc2be458baf5bff14cd632cd9"><![CDATA[
The set %A = {@A,@B,@C} is an alphabet. @A@A@A, @A@B, @B, @C@B@A, and \varepsilon are all examples of strings built using the alphabet %A.
      ]]></example>
      <definition required="true" hooks="math" id="d1e9fd2dc4724ef58c57cd881340e32d"><![CDATA[
Given an alphabet %A, let %U be the set of all finite strings that can be built using characters from %A (including the empty string, which we will call \varepsilon). In other words, we can say:
\begin{eqnarray}
  %U & = & { %s | %s is a finite string of characters from alphabet %A }
\end{eqnarray}
Any subset %L \subset %U is a <i>language</i>. That is, any set of character strings (whether the set is finite or infinite) is a language.
      ]]></definition>
      <example required="true" hooks="math" id="a32c619802234e94a307d71f676e3186"><![CDATA[
The set %A = {@X, @Y, @Z} is an alphabet. The set of strings { \varepsilon, @X, @Y, @Z } is one example of a language. The infinite set of strings { \varepsilon, @X, @X@X, @X@X@X, @X@X@X@X, ... } is also a language. The infinite set of strings { @Y@Z, @Y@Z@Y@Z, @Y@Z@Y@Z@Y@Z, ... } is also a language.
      ]]></example>
      <example required="true" hooks="math" id="fc5990b5b76040539c931b1ca279e222"><![CDATA[
The set %A = {@0, @1, @2, @3, @4, @5, @6, @7, @8, @9} is an alphabet. The following set of strings can be a language for representing positive integers between 1 and 9999 (inclusive):
\begin{eqnarray}
  %L & = & { %s | %s is a string of characters from %A, %s does not begin with @0, 1 \leq |%s| \leq 4 }
\end{eqnarray}
      ]]></example>
    </subsection>
    <subsection title="Regular expressions">
      <text hooks="math"><![CDATA[
If languages are merely subsets of the set of all finite character strings that can be built using the characters in an alphabet, then we can always specify any finite subset (and thus language) by simply writing down every string in the language. However, what if we want to write down the definition of that subset using a shorter representation, or we want to specify an infinitely large subset of character strings (e.g., all strings consisting of one or more copies of the character <b>a</b>: {@a, @a@a, @a@a@a, ...})?
      ]]></text>
      <paragraph><![CDATA[
Regular expressions are a notation for precisely and concisely defining certain sets of character strings.
      ]]></paragraph>
      <definition required="true" hooks="math" id="06defac822974dd688904a07cf4f6f18">
        <text><![CDATA[
Given an alphabet %A, a regular expression over %A can contain any of the characters in %A as well as any number of the following special characters:
        ]]></text>
        <unorderedlist>
          <item><![CDATA[the "or" symbol <b>|</b> consisting of single vertical bar;]]></item>
          <item><![CDATA[the grouping symbols <b>(</b> and <b>)</b>, which must always be balanced the same way that parentheses must be balanced in arithmetic expressions;]]></item>
          <item><![CDATA[the <b>+</b> and <b>*</b> symbols.]]></item>
        </unorderedlist>
        <text><![CDATA[
The subset of character strings that a regular expression defines can be determined in the following way:
        ]]></text>
        <unorderedlist>
          <item><![CDATA[a regular expression %r that contains no special characters defines a set of strings containin just one string: {%r};]]></item>
          <item><![CDATA[if a regular expression %r_1 defines a set %S_1 and a regular expression %r_2 defines a set %S_2, then the regular expression %r_1 <b>|</b> %r_2 defines the set of character strings %S_1 \cup %S_2;]]></item>
          <item><![CDATA[if a regular expression %r defines a set %S, then the regular expression <b>(</b>%r<b>)</b> defines the set of character strings %S (i.e., there is no difference);]]></item>
          <item><![CDATA[if a regular expression %r defines a set %S, then the regular expression %r<b>+</b> defines the set of character strings %S' that consists of all possible concatenations of any of the strings in %S;]]></item>
          <item><![CDATA[if a regular expression %r defines a set %S, then the regular expression %r<b>*</b> defines the set of character strings %S' that consists of all possible concatenations of any of the strings in %S, as well as the empty string.]]></item>
        </unorderedlist>
      </definition>
      <example required="true" hooks="math" id="1deeccf7a0e5426db9bd875b3b727e49">
        <text><![CDATA[
Assume that our alphabet consists of all alphanumeric characters. For each of the following regular expressions, describe verbally what set of character strings they define:
        ]]></text>
        <unorderedlist>
          <item><![CDATA[@a@b@c@d]]></item>
          <item><![CDATA[<b>(</b>@a@b@c@d<b>)</b>+]]></item>
          <item><![CDATA[<b>red | green | blue</b>]]></item>
          <item><![CDATA[<b>(</b><b>red | green | blue</b><b>)</b>+]]></item>
          <item><![CDATA[<b>(0+) | (1+)</b>]]></item>
          <item><![CDATA[<b>(0 | 1)</b>+]]></item>
        </unorderedlist>
      </example>
      <example required="true" hooks="math" id="98592789a35440a8ac6d28bbc97e0302">
        <text><![CDATA[
Assume that our alphabet consists of all alphanumeric characters. For each of the following verbal descriptions of sets of character strings, find a regular expression that defines the described set:
        ]]></text>
        <unorderedlist>
          <item><![CDATA[the set of character strings that consist entirely of vowels;]]></item>
          <item><![CDATA[the set of all integers (negative and positive);]]></item>
          <item><![CDATA[the set of all arithmetic expressions involving binary numbers, addition, and subtraction;]]></item>
          <item><![CDATA[the set of all words that begin with a vowel and end with a vowel;]]></item>
          <item><![CDATA[the set of all numbers of even length.]]></item>
        </unorderedlist>
      </example>
      <example required="true" hooks="math" id="791effdeab954f668592fa5324aff657">
        <text><![CDATA[
In practice, programming languages that provide libraries of functions and procedures for working with regular expressions also support other special characters. For example, Python regular expressions may contain some of the following special characters:
        ]]></text>
        <unorderedlist>
          <item><![CDATA[the <code>\(</code>, <code>\)</code> special characters make it possible to include parentheses in expressions in a way that does not cause them to interpreted as regular expression grouping symbols;]]></item>
          <item><![CDATA[the special symbol <code>\s</code> matches a single whitespace character;]]></item>
          <item><![CDATA[the special symbol <code>[0-9]</code> matches a single numeric digit;]]></item>
          <item><![CDATA[the special symbol <code>[a-z]</code> matches a single lowercase letter;]]></item>
          <item><![CDATA[the special symbol <code>[A-Z]</code> matches a single uppercase letter;]]></item>
          <item><![CDATA[the special symbol <code>[a-zA-Z]</code> matches a single letter;]]></item>
          <item><![CDATA[the special symbol <code>[a-zA-Z0-9]</code> matches a single alphanumeric character.]]></item>
        </unorderedlist>
      </example>
      <example required="true" id="71f7125be5124059a51f065d1950e6e8">
        <text><![CDATA[
In the Python programming language, the <code>re</code> module provides functionality for automatically checking whether a string matches a particular regular expression. In order to check whether a string exactly matches a regular expression, it is necessary to wrap the regular expression in parentheses and then add special markers to ensure that the regular expression matches from the beginning of the string to the end of the string.
        ]]></text>
        <paragraph><![CDATA[
If a match succeeds, a match object is returned that contains additional information (e.g., the position of the match); otherwise, <code>None</code> is returned.
        ]]></paragraph>
        <code hooks="Python"><![CDATA[
>>> @import re

>>> re.match(r"^(a|b|c)$", "a")   # Succeeds.
<_sre.SRE_Match object; span=(0, 1), match='a'>

>>> re.match(r"^(a|b|c)$", "def") # Fails.
@None

>>> re.match(r"^((red|green|blue)+)$", "redgreenblueredblue")
<_sre.SRE_Match object; span=(0, 19), match='redgreenblueredblue'>

>>> re.match(r"^([a-zA-Z0-9]+)$", "redgreenblueredblue")
<_sre.SRE_Match object; span=(0, 19), match='redgreenblueredblue'>

>>> re.match(r"^([a-zA-Z0-9]+)$", "!@#$")
@None
        ]]></code>   
      </example>
      <fact required="true" hooks="math" id="174fccbd604846ad92d764daf2393aa3">
        <text><![CDATA[
Regular expressions are not powerful enough to describe many common languages in which we may be interested. Examples of sets of character strings that cannot be defined using regular expression include:
        ]]></text>
        <unorderedlist>
          <item><![CDATA[the set of arithmetic expressions with balanced parentheses;]]></item>
          <item><![CDATA[the set of all palindromes;]]></item>
          <item><![CDATA[the set of all strings in which the same string is repeated exactly two times in a row.]]></item>
        </unorderedlist>
        <text><![CDATA[
For languages such as the above, a more powerful tool for describing sets of character strings is needed.
        ]]></text>
      </fact>
    </subsection>
    <subsection title="Sets of token sequences">
      <text><![CDATA[
Unlike human languagues, programming languages usually have a relatively small collection of symbol strings (e.g., commands or instructions) that are used to construct programs. Thus, we can adjust the definition of what constitutes a language to account for this.
      ]]></text>
      <definition required="true" hooks="math" id="fe3a9fbf541445de977ab5df0e57621f"><![CDATA[
Given an alphabet %A, a <i>token</i> is a finite, non-empty (usually short) string of characters from that alphabet.
      ]]></definition>
      <definition required="true" hooks="math" id="8f78a2be462e425da6c87339850e7f8b"><![CDATA[
Given a set of tokens %T, let %U be the set of all finite sequences that can be built using tokens from %T (including the empty sequence, which we will call \varepsilon). In other words, we can say:
\begin{eqnarray}
  %U & = & { %s | %s is a finite sequence of tokens from %T }
\end{eqnarray}
Any subset %L \subset %U is a <i>language</i>. That is, any set of token sequences (whether the set is finite or infinite) is a language.
      ]]></definition>
      <example required="true" hooks="math" id="06d4c9d409dc44ad8c1dccbef3412163"><![CDATA[
Consider the following set of tokens:
\begin{eqnarray}
%T & = & { <b>true</b>, <b>false</b>, <b>or</b>, <b>and</b>, <b>not</b>, <b>(</b>, <b>)</b>, <b>,</b> }
\end{eqnarray}
The set of token sequences that represent valid boolean formulas is a language:
\begin{eqnarray}
%L & = & { & %~ & <b>or ( false , and ( true , false ) )</b>, \\
   & %~ &  & %~ & <b>and ( true , false )</b>, \\
   & %~ &  & %~ & <b>not</b> <b>(</b> <b>false</b> <b>)</b>, \\
   & %~ &  & %~ & <b>true</b>, \\
   & %~ &  & %~ & <b>false</b>, \\
   & %~ &  & %~ & ... }
\end{eqnarray}
      ]]></example>
    <text><![CDATA[
If a language is just a subset of the set of all possible token sequences, how do we mathematically specify interesting subsets?
    ]]></text>  
    </subsection>
    <subsection title="Language syntax and Backus-Naur Form (BNF) notation">
      <text><![CDATA[
If a language is just a set of finite token strings, then defining a language amounts to defining this set. How can we define this set? By introducing a collection of rules or constraints governing how characters and/or tokens can be assembled to form strings or sequences in the language. 
      ]]></text>
      <definition required="true" hooks="math" id="7e82906541a4467faea16807f380dd44"><![CDATA[
Given a token set %T and a language %L consisting of finite sequences of tokens from %T, the <i>syntax</i> of %L is the set of rules defining <i>exactly</i> which token sequences are in %L.
These rules are sometimes also called <i>syntactic rules</i>, a <i>formal grammar</i>, or simply a <i>grammar</i>.
      ]]></definition>
      <text><![CDATA[
There are many possible ways by which we could represent syntactic rules, and these rules can be classified, or stratified, according to their expressive power. A more extensive coverage of this topic is beyond the scope of this course, and is normally presented in courses on the theory of computation and automata. In this course, we will focus on two particular kinds of grammar: regular grammars and context-free grammars. The most common representation for such grammars is Backus-Naur Form, abbreviated henceforward as <i>BNF</i>.
      ]]></text>
      <definition required="true" hooks="math" id="2075c983aff44402b4e5467cdd450d53"><![CDATA[
A grammar definition consists of one or more <i>productions</i> (or <i>production rules</i>). Each production has the following form:
\begin{eqnarray}
<i>non-terminal</i> & ::= & <i>terminal_or_non-terminal</i>  ...  <i>terminal_or_non-terminal</i> \\
                    & | & <i>terminal_or_non-terminal</i> ... <i>terminal_or_non-terminal</i> \\
                    & \vdots & \\
                    & | & <i>terminal_or_non-terminal</i> ... <i>terminal_or_non-terminal</i>
\end{eqnarray}
The left-hand side (to the left of the ::= symbol) in each production is called a <i>non-terminal</i>. The right-hand side of each production is an unordered collection of <i>choices</i> separated by the | symbol. Each choice is a <i>sequence</i> of non-terminals (which must appear once on the left-hand side of a production) or <i>terminals</i> (a terminal is a token).
      ]]></definition>
      <text><![CDATA[
These production rules in a grammar's BNF representation can be viewed both as a way to construct an element (i.e., a token sequence that is a program) in the language, or as a way to break down a token sequence piece by piece until nothing is left.
      ]]></text>
      <example required="true" hooks="math" id="16147b7c6f904109b9900322be8ad838"><![CDATA[
Let %T be a token set:
\begin{eqnarray}
%T & = & { <b>true</b> }
\end{eqnarray}
The following is a very simple programming language that contains only a single possible token sequence consisting of the single token <b>true</b>:
\begin{eqnarray}
<i>program</i> & ::= & <b>true</b>
\end{eqnarray}
In this case, the language is finite and small, so we can actually write it down as a set:
\begin{eqnarray}
%L & = & { <b>true</b> }
\end{eqnarray}
      ]]></example>
      <example required="true" hooks="math" id="b8f92b53cb7449998112583773b3d97c"><![CDATA[
We can extend the language by adding another token:
\begin{eqnarray}
%T & = & { <b>true</b>, <b>false</b> }
\end{eqnarray}
The following BNF grammar definition now contains two choices (each choice is a sequence consisting of a single terminal):
\begin{eqnarray}
<i>program</i> & ::= & <b>true</b> \\
               & | & <b>false</b>
\end{eqnarray}
This programming language now contains two token sequences:
\begin{eqnarray}
%L & = & { <b>true</b>, <b>false</b> }
\end{eqnarray}
      ]]></example>
      <example required="true" hooks="math" id="9380e58ddbde4fe88ddb2daff5bd4617"><![CDATA[
We can extend the language definition further:
\begin{eqnarray}
%T & = & { <b>true</b>, <b>false</b>, <b>or</b>, <b>and</b>, <b>not</b>, <b>(</b>, <b>)</b>, <b>,</b> }
\end{eqnarray}
The following BNF grammar definition now contains five choices (each choice is a sequence consisting of non-terminals and terminals):
\begin{eqnarray}
<i>program</i> & ::= & <b>true</b> \\
               & | & <b>false</b> \\
               & | & <b>and (</b> <i>program</i> <b>,</b> <i>program</i> <b>)</b> \\
               & | & <b>or (</b> <i>program</i> <b>,</b> <i>program</i> <b>)</b> \\
               & | & <b>not (</b> <i>program</i> <b>)</b>
\end{eqnarray}
This programming language now contains infinitely many finite token sequences:
\begin{eqnarray}
%L & = & { & %~ & <b>or ( false , and ( true , false ) )</b>, \\
   & %~ &  & %~ & <b>and ( true , false )</b>, \\
   & %~ &  & %~ & <b>not</b> <b>(</b> <b>false</b> <b>)</b>, \\
   & %~ &  & %~ & <b>true</b>, \\
   & %~ &  & %~ & <b>false</b>, \\
   & %~ &  & %~ & ... }
\end{eqnarray}
      ]]></example>
      <example required="true" hooks="math" id="8c1203dd65bb49868abc64ad5353725f"><![CDATA[
Let us consider another example: a language of positive integers.
\begin{eqnarray}
%T & = & { <b>0</b>, <b>1</b>, <b>2</b>, <b>3</b>, <b>4</b>, <b>5</b>, <b>6</b>, <b>7</b>, <b>8</b>, <b>9</b> }
\end{eqnarray}
We can define the following grammar:
\begin{eqnarray}
<i>number</i> & ::= & <b>0</b> | <b>1</b> | <b>2</b> | <b>3</b> | <b>4</b> | <b>5</b> | <b>6</b> | <b>7</b> | <b>8</b> | <b>9</b> \\
  & | & <b>1</b> <i>number</i> | <b>2</b> <i>number</i> | <b>3</b> <i>number</i> | <b>4</b> <i>number</i> \\
  & | & <b>5</b> <i>number</i> | <b>6</b> <i>number</i> | <b>7</b> <i>number</i> | <b>8</b> <i>number</i> | <b>9</b> <i>number</i> \\
\end{eqnarray}
However, the above does not allow us to have a <b>0</b> in any number with more than one digit. One way to fix this (there are many other ways) is to introduce more productions into the grammar:
\begin{eqnarray}
<i>nozero</i> & ::= & <b>1</b> | <b>2</b> | <b>3</b> | <b>4</b> | <b>5</b> | <b>6</b> | <b>7</b> | <b>8</b> | <b>9</b> \\
<i>digit</i> & ::= & <b>0</b> | <i>nozero</i> \\
<i>digits</i> & ::= & <i>digit</i> | <i>digit</i> <i>digits</i> \\
<i>number</i> & ::= & <i>digit</i> | <i>nozero</i> <i>digits</i>
\end{eqnarray}
      ]]></example>
      <text>
Note that the grammar may contain multiple productions. Any non-terminal defined in a production can appear on the right-hand side of any of the productions.
      </text>
      <example required="true" hooks="math" id="19dc317f45ec4ae18018ca5b17fce114"><![CDATA[
We can extend the language by adding a production for statements, and allowing a program to be a sequence of one or more statements.
\begin{eqnarray}
%T & = & { <b>true</b>, <b>false</b>, <b>or</b>, <b>and</b>, <b>not</b>, <b>(</b>, <b>)</b>, <b>,</b>, <b>print</b>, <b>skip</b>, <b>;</b> }
\end{eqnarray}
The following is the new grammar definition for this language.
\begin{eqnarray}
<i>program</i> & ::= & <i>statement</i> \\
               & | & <i>statement</i> <i>program</i>  \\
<i>statement</i> & ::= & <b>print</b> <i>formula</i> <b>;</b> \\
                 & | & <b>skip</b> <b>;</b>  \\
<i>formula</i> & ::= & <b>true</b> \\
                 & | & <b>false</b> \\
                 & | & <b>not (</b> <i>formula</i> <b>)</b> \\
                 & | & <b>and (</b> <i>formula</i> <b>,</b> <i>formula</i> <b>)</b> \\
                 & | & <b>or (</b> <i>formula</i> <b>,</b> <i>formula</i> <b>)</b>
\end{eqnarray}
      ]]></example>
    </subsection>
  </section>
  <section title="Parsing">
    <text>
Given a programming language definition, we want to have the ability to operate on programs written in that language using a computer. To do so, we need to convert the character string representations of programs in that programming language into instances of a data structure; each data structure instance would then be a representation of the program as data.
    </text>
    <subsection title="Concrete and abstract syntaxes">
      <definition required="true" id="e601deb568ed46a1a1d741907a6dcfa9"><![CDATA[
Given an alphabet, token set, and grammar definition (e.g., represented using BNF notation), we define the <i>concrete syntax</i> to be the set of all character strings that conform to the grammar definition. We call a particular character string that conforms to the grammar definition a <i>concrete syntax instance</i>.
      ]]></definition>
      <definition required="true" id="db9e874ec6b6475a93bc3ef4db0f2066"><![CDATA[
For a particular programming language definition, we define the <i>abstract syntax</i> to be the set of all data structure instances that correspond to a character string that conforms to the grammar definition for that language. An instance of the abstract syntax is sometimes called a <i>parse tree</i>.
      ]]></definition>
      <example required="true" id="4ba33545333f48e88baddfa4507a1db0">
        <text hooks="math"><![CDATA[
Consider again the language that conforms to the following grammar:
\begin{eqnarray}
<i>program</i> & ::= & <b>true</b> | <b>false</b> | <b>not (</b> <i>program</i> <b>)</b> \\
                 & | & <b>and (</b> <i>program</i> <b>,</b> <i>program</i> <b>)</b> | <b>or (</b> <i>program</i> <b>,</b> <i>program</i> <b>)</b> 
\end{eqnarray}
The following is the character string of one possible program in the language. This character string is an instance of the concrete syntax of the language.
        ]]></text>
        <code hooks="Python">
and (or (and (true, false), not(false)), or (true, false))
        </code>
        <text>
The above character string might be converted into a structured representation of the program within some host language (i.e., the programming language being used to operate on these programs: checking for errors, interpreting, or compiling the program). Below, we present one possible Python representation of the instance of the abstract syntax (i.e., the parse tree) corresponding to the concrete syntax instance above. This representation uses nested Python dictionaries to represent the parse tree, with strings being used to represent node labels and leaves.
        </text>
        <code hooks="Python">
{ "And": [
    { "Or": [
        { "And": ["True","False"]}, 
        { "Not": ["False"]}
      ]
    }, 
    { "Or": ["True","False"]}
  ]
}
        </code>
      </example>
    </subsection>
    <subsection title="Lexing (a.k.a., tokenizing) and parsing">
      <definition required="true" id="3f625b68bc8a426c80fe1c774e04c362"><![CDATA[
A <i>lexer</i> or <i>tokenizer</i> is an algorithm that converts an instance of the concrete syntax of a language (i.e., a character string that conforms to the grammar definition for the language) into a sequence of tokens.
      ]]></definition>
      <example required="true" id="2c7cc0e69813454eafc7128e5ac57055">
        <text hooks="math"><![CDATA[
Consider again the language that conforms to the following grammar:
\begin{eqnarray}
<i>program</i> & ::= & <b>true</b> | <b>false</b> | <b>not (</b> <i>program</i> <b>)</b> \\
                 & | & <b>and (</b> <i>program</i> <b>,</b> <i>program</i> <b>)</b> | <b>or (</b> <i>program</i> <b>,</b> <i>program</i> <b>)</b> 
\end{eqnarray}
The following Python implementation of a tokenizing algorithm for this language uses regular expressions to split a character string into a sequence of individual tokens from the token set.
        ]]></text>
        <code hooks="Python">
@import re
@def tokenize(s):
    # Use a regular expression to split the string into
    # tokens or sequences of zero or more spaces.
    tokens = [t @for t @in re.split(r"(\s+|true|false|and|or|not|,|\(|\))", s)]

    # Throw out the spaces and return the result.
    @return [t @for t @in tokens @if @not t.isspace() @and @not t == ""]
        </code>
        <text>
Below is an example input and output.
        </text>
        <code hooks="Python">
>>> tokenize("and (or (and (true, false), not(false)), or (true, false))")

['and', '(', 'or', '(', 'and', '(', 'true', ',', 'false', ')', ',', 'not', 
 '(', 'false', ')', ')', ',', 'or', '(', 'true', ',', 'false', ')', ')']
        </code>
      </example>
      <definition required="true" id="3c944fff48f246aba9409f76e48ccef4"><![CDATA[
A <i>parser</i> is an algorithm that converts a token sequence into an instance of the abstract syntax (i.e., a parse tree).
      ]]></definition>
      <text><![CDATA[
The tokenizer and parser are then composed to transform a character string into a parse tree.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">character string<br/>(concrete syntax)</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">lexer/<br/>tokenizer</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">token<br/>sequence</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">parser</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">parse tree<br/>(abstract syntax)</td>
  </tr>
</table>
</div>
Often, the tokenizer and parser are together called a <i>parser</i>. In situations where this can cause confusion, we will refer to the actual process that converts token sequences into parse trees as the <i>parsing algorithm</i>.
<div class="diagram">
<table class="container">
  <tr>
  <td class="box" style="background-color:powderblue;">character string<br/>(concrete syntax)</td>
  <td><span style="font-size:20px;">&#8658;</span></td>
  <td class="box" style="background-color:#EFEFEF;">
  <table class="container">
    <tr>
    <td class="box" style="background-color:lightyellow;">lexer/<br/>tokenizer</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">token<br/>sequence</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">parsing<br/>algorithm</td>
    </tr>
  </table>
  <br/>parser
  </td>
  <td><span style="font-size:20px;">&#8658;</span></td>
  <td class="box" style="background-color:powderblue;">parse tree<br/>(abstract syntax)</td>
  </tr>
</table>
</div>
The BNF representation of a grammar can be converted into a parsing algorithm that turns a token sequence into an abstract syntax data structure instance (i.e., a parse tree). How easily this can be done depends on the properties of the grammar.
      ]]></text>
      <fact required="true" id="47254608df414ace8d04c630a2b15689"><![CDATA[
Given a BNF representation of a grammar, if for every production in the grammar, each choice begins with a unique terminal (i.e., a terminal that is <i>not</i> the first terminal in any other choice within that production), then we say the grammar is in <i>LL(1)</i> form, and we can implement a <i>predictive recursive descent</i> parsing algorithm to parse any token sequence that conforms to this grammar (note that these are only <i>sufficient</i> conditions for the grammar to be in LL(1) form; less restrictive conditions also exist).
      ]]></fact>
      <text>
A predictive recursive descent parser can effectively run in linear time; it decomposes the token sequence from left to right while assembling a parse tree.
      </text>
      <example required="true" id="2cd418f2876c42d59a57e34bd6288f22">
        <text hooks="math"><![CDATA[
Consider again the language that conforms to the following grammar:
\begin{eqnarray}
<i>program</i> & ::= & <b>true</b> | <b>false</b> | <b>not (</b> <i>program</i> <b>)</b> \\
               & | & <b>and (</b> <i>program</i> <b>,</b> <i>program</i> <b>)</b> | <b>or (</b> <i>program</i> <b>,</b> <i>program</i> <b>)</b> 
\end{eqnarray}
The following Python implementation of a predictive recursive descent parsing algorithm for this language builds a parse tree using the nested dictionary representation seen in <a href="#4ba33545333f48e88baddfa4507a1db0">a previous example</a>. This recursive algorithm takes a single argument: a sequence of tokens. It returns two results: a parse tree, and the remainder of the token sequence. <b>Note that the order in which the choices in the production are being handled is not determined by the order of the choices in the production.</b> The choices in a production are unordered; any parser implementation that captures all the possible choices conforms to the grammar definition.
        ]]></text>
        <code hooks="Python">
@def parse(tokens):
    @if tokens[0] == 'true':
        @return ('True', tokens[1:])

    @if tokens[0] == 'false':
        @return ('False', tokens[1:])

    @if tokens[0] == 'not' @and tokens[1] == '(':
        (e1, tokens) = parse(tokens[2:])
        @if tokens[0] == ')':
          @return ({'Not':[e1]}, tokens[1:])

    @if tokens[0] == 'or' @and tokens[1] == '(':
        (e1, tokens) = parse(tokens[2:])
        @if tokens[0] == ',':
            (e2, tokens) = parse(tokens[1:])
            @if tokens[0] == ')':
                @return ({'Or':[e1,e2]}, tokens[1:])

    @if tokens[0] == 'and' @and tokens[1] == '(':
        (e1, tokens) = parse(tokens[2:])
        @if tokens[0] == ',':
            (e2, tokens) = parse(tokens[1:])
            @if tokens[0] == ')':
                @return ({'And':[e1,e2]}, tokens[1:])
        </code>
        <text>
Below is an example input and output. Notice that no tokens are left in the token sequence once the result is returned.
        </text>
        <code hooks="Python">
>>> @import json
>>> (tree, tokens) =\
      parse(tokenize(\
        "and (or (and (true, false), not(false)), or (true, false))"\
        )\
      )
>>> @print(json.dumps(tree, sort_keys=True, indent=2))
{
  "And": [
    {
      "Or": [
        {
          "And": [
            "True", 
            "False"
          ]
        }, 
        {
          "Not": [
            "False"
          ]
        }
      ]
    }, 
    {
      "Or": [
        "True", 
        "False"
      ]
    }
  ]
}
>>> @print(tokens)
[]
        </code>
      </example>
      <fact required="true" id="95cb72f5b4d24ddba2c8081c7b42618a"><![CDATA[
If we relax the conditions on the grammar definition that make it LL(1) by dropping the requirement that the first terminal in each sequence within a production must be unique, we can no longer use predictive recursive descent parsing algorithm to parse a language corresponding to this grammar because the first terminal in each sequence within a production no longer uniquely determines which choice within a production should be used to continue parsing a token sequence. However, as long as every sequence within every production starts with a terminal, we can implement a <i>backtracking recursive descent</i> parsing algorithm to parse token sequence in the language.
      ]]></fact>
      <example required="true" id="5917f6f5de7c46079190f4b6c4961ca3">
        <text hooks="math"><![CDATA[
In the previus example, the grammar only allowed prefix logical operators. Suppose we wanted to parse token sequences for a grammar with infix operators.
\begin{eqnarray}
<i>program</i> & ::= & <b>true</b> | <b>false</b> | <b>not (</b> <i>program</i> <b>)</b> \\
               & | & <b>(</b> <i>program</i> <b>and</b> <i>program</i> <b>)</b> | <b>(</b> <i>program</i> <b>or</b> <i>program</i> <b>)</b> 
\end{eqnarray}
It is no longer possible to implement a predictive recursive descent parser. We must instead employ backtracking, and we must also keep track of whether we have consumed all the tokens.
        ]]></text>
        <code hooks="Python">
@def parse(tmp, top = @True):
    tokens = tmp[0:]
    @if tokens[0] == 'true':
        tokens = tokens[1:]
        @if @not top @or @len(tokens) == 0:
            @return ('True', tokens)

    tokens = tmp[0:]
    @if tokens[0] == 'false':
        tokens = tokens[1:]
        @if @not top @or @len(tokens) == 0:
            @return ('False', tokens)

    tokens = tmp[0:]
    @if tokens[0] == 'not' @and tokens[1] == '(':
        tokens = tokens[2:]
        r = parse(tokens, @False)
        @if @not r @is @None:
            (e1, tokens) = r
            @if tokens[0] == ')':
                tokens = tokens[1:]
                if @not top @or @len(tokens) == 0:
                    @return ({'Not':[e1]}, tokens)

    tokens = tmp[0:]
    @if tokens[0] == '(':
        tokens = tokens[1:]
        r = parse(tokens, @False)
        @if @not r @is @None:
            (e1, tokens) = r
            @if tokens[0] == 'or':
                tokens = tokens[1:]
                r = parse(tokens, @False)
                @if @not r @is @None:
                    (e2, tokens) = r
                    @if tokens[0] == ')':
                        tokens = tokens[1:]
                        @if @not top @or @len(tokens) == 0:
                            @return ({'Or':[e1,e2]}, tokens)

    tokens = tmp[0:]
    @if tokens[0] == '(':
        tokens = tokens[1:]
        r = parse(tokens, @False)
        @if @not r @is @None:
            (e1, tokens) = r
            @if tokens[0] == 'and':
                tokens = tokens[1:]
                r = parse(tokens, @False)
                @if @not r @is @None:
                    (e2, tokens) = r
                    @if tokens[0] == ')':
                        tokens = tokens[1:]
                        @if @not top @or @len(tokens) == 0:
                            @return ({'And':[e1,e2]}, tokens)
        </code>
        <text>
The above code is far too repetitive. However, we can take the parts that repeat and turn them into a loop body that loops over all the possible choices in the production.
        </text>
        <code hooks="Python">
@def parse(tmp, top = @True):
    seqs = [\
        ('True', ['true']), \
        ('False', ['false']), \
        ('Not', ['not', '(', parse, ')']), \
        ('And', ['(', parse, 'and', parse, ')']), \
        ('Or', ['(', parse, 'or', parse, ')']) \
        ]

    # Try each choice sequence.
    @for (label, seq) @in seqs:
        tokens = tmp[0:]
        ss = [] # To store matched terminals.
        es = [] # To collect parse trees from recursive calls.
        
        # Walk through the sequence and either
        # match terminals to tokens or make
        # recursive calls depending on whether
        # the sequence entry is a terminal or
        # parsing function.
        @for x @in seq:
            @if @type(x) == @type(""): # Terminal.

                @if tokens[0] == x: # Does terminal match token?
                    tokens = tokens[1:]
                    ss = ss + [x]
                @else:
                    @break # Terminal did not match token.

            @else: # Parsing function.

                # Call parsing function recursively
                r = x(tokens, @False) 
                @if @not r @is @None:
                    (e, tokens) = r
                    es = es + [e]

        # Check that we got either a matched token
        # or a parse tree for each sequence entry.
        @if @len(ss) + @len(es) == @len(seq):
            @if @not top @or @len(tokens) == 0:
                @return ({label:es} @if @len(es) > 0 @else label, tokens)
        </code>
      </example>
    </subsection>
    <subsection title="More parsing examples and building parsers for other classes of grammar">
      <exercise required="true" id="7c9969979aa04b03a4fbecdaca21880e">
        <text hooks="math"><![CDATA[
Consider the following grammar definition:
\begin{eqnarray}
<i>command</i> & ::= & <b>start</b>  \\
               & | & <b>suspend</b> \\
               & | & <b>wake</b> \\
               & | & <b>terminate</b> \\
               & | & <b>reboot</b> \\
               & | & <b>if</b> <i>condition</i> <b>then</b> <i>command</i> \\
               & | & <b>if</b> <i>condition</i> <b>then</b> <i>command</i> <b>else</b> <i>command</i> \\
               & | & <b>repeat</b> <i>command</i> \\
               & | & <b>while</b> <i>condition</i> <b>then</b> <i>command</i> \\
<i>condition</i> & ::= & <b>power low</b> \\
               & | & <b>temperature high</b> \\
               & | & <b>temperature very low</b> \\
               & | & <b>user input</b>
\end{eqnarray}
Suppose we want to implement a parser for the above grammar. A partial implementation of a parser for the above grammar (what has been presented in lecture so far) is provided below.
        ]]></text>
        <code hooks="Python">
@def command(tokens, top = @True):
    seqs = {\
       ("Start", "start"),\
       ("Suspend", "suspend"),\
       ("Wake", "wake"),\
       ("Terminate", "terminate"),\
       ("Reboot", "reboot")\
       }
    @for (key, value) @in seqs:
        @if tokens[0] == value:
            tokens = tokens[1:]
            @if @not top @or @len(tokens) == 0:
                @return (key, tokens)
    
    @if tokens[0] == 'repeat':
        r = command(tokens[1:], @False)
        @if @not r @is @None:
            (e, tokens) = r
            @if @not top @or @len(tokens) == 0:
                @return ({"Repeat": [e]}, tokens)

    @if tokens[0] == 'while':
        r = condition(tokens[1:], @False)
        @if @not r @is @None:
            (e1, tokens) = r
            @if tokens[0] == 'then':
                 r = command(tokens[1:], @False)
                 @if @not r @is @None:
                     (e2, tokens) = r           
                     @if @not top @or @len(tokens) == 0:
                         @return ({"While": [e1,e2]}, tokens)

@def condition(tokens, top = True):
    seqs = [\
       ("PowerLow", ["power", "low"]),\
       ("TempHigh", ["temperature", "high"]),\
       ("UserInput", ["user", "input"])\
       ]
    @for (key, seq) @in seqs:
        @if tokens[0] == seq[0]:
            @if tokens[1] == seq[1]:
                tokens = tokens[2:]
                @if @not top @or @len(tokens) == 0:
                    @return (key, tokens)
        </code>
          <text><![CDATA[
It is possible to replace the <code>condition()</code> function with a generic parser for base cases that contain an arbitrary number of terminals in each sequence.
Any call to <code>condition(...)</code> can then be replaced with a call to <code>parseBaseCases(seqsCondition, ...)</code>.
          ]]></text>
        <code hooks="Python">
seqsCondition = [\
       ("PowerLow", ["power", "low"]),\
       ("TempHigh", ["temperature", "high"]),\
       ("TempVeryLow", ["temperature", "very", "low"]),\
       ("UserInput", ["user", "input"])\
       ]

@def parseBaseCases(seqs, tokens, top = @True):
    @for (key, seq) @in seqs:
         # Check if token sequence matches sequence.
        i = 0
        @for terminal @in seq:
            @if terminal == tokens[i]:
                @pass
            @else:
                @break
            i = i + 1
                
        # Check if the previous loop succeeded.
        @if i == @len(seq):
            tokens = tokens[@len(seq):]
            if @not top @or @len(tokens) == 0:
                @return (key, tokens)
        </code>
      </exercise>
      <example required="true" id="b1e8bae08f134922b2bdc85fd206cbe4">
        <text hooks="math"><![CDATA[ 
Consider the following grammar definition:
\begin{eqnarray}
<i>formula</i> & ::= & <b>true</b> \\
               & | & <b>false</b> \\
               & | & <b>not</b> <i>formula</i> \\
               & | & <b>(</b> <i>formula</i> <b>)</b> \\
               & | & <i>formula</i> <b>and</b> <i>formula</i> \\
               & | & <i>formula</i> <b>or</b> <i>formula</i> 
\end{eqnarray}
Implementing a naive recursive descent parser, predictive or backtracking, would not work for this grammar. Consider what would happen if we ran the following code on any input:
        ]]></text>
        <code hooks="Python"><![CDATA[ 
@def parse(tokens):
    @if tokens[0] == 'true':
        @return ('True', tokens[1:])

    @if tokens[0] == 'false':
        @return ('False', tokens[1:])

    # ...

    # Recursive call, but no tokens consumed.
    (e1, tokens) = parse(tokens) 
      @if tokens[0] == 'and':
        (e2, tokens) = parse(tokens[1:])
        @return ({'And':[e1,e2]}, tokens[1:])

    # ...
        ]]></code>
        <text hooks="math"><![CDATA[ 
The above code never terminates, and after a large number of recursive calls are made, the Python interpreter returns an error indicating it is out of stack space.
To get around this problem, one option is to perform <i>left-recursion elimination</i> on the grammar so that a recursive call never occurs first for any of the choices.
\begin{eqnarray}
<i>formula</i> & ::= & <i>left</i> <b>and</b> <i>formula</i> \\
               & | & <i>left</i> <b>or</b> <i>formula</i> \\
               & | & <i>left</i> \\
<i>left</i> & ::= & <b>true</b> \\
               & | & <b>false</b> \\
               & | & <b>not</b> <i>formula</i> \\
               & | & <b>(</b> <i>formula</i> <b>)</b>
\end{eqnarray}
The above is usually acceptable if the operator, such as <b>and</b>, is commutative or right-associative. However, if the operator is left-associative, the above strategy would not necessarily lead to a correct parse tree. Can you explain why? In such a scenario, other techniques would need to be employed. If the operator is indeed associative or right-associative, however, the parser implementation could then look something like the following:
        ]]></text>
        <code hooks="Python"><![CDATA[ 
@def formula(tmp):
    tokens = tmp[0:]
    (e1, tokens) = left(tokens)
      @if tokens[0] == 'and':
        (e2, tokens) = formula(tokens[1:])
        @return ({'And':[e1,e2]}, tokens[1:])

    # ...

@def left(tokens):
    @if tokens[0] == 'true':
        @return ('True', tokens[1:])

    @if tokens[0] == 'false':
        @return ('False', tokens[1:])

    # ...
        ]]></code>
        <text hooks="math"><![CDATA[ 
Note that performing left-recursion elimination does <i>not</i> necessarily change the definition of the concrete syntax, the definition of the abstract syntax of a language (i.e., the set of parse trees), or the meaning of a language. Left-recursion elimination is a strategy for converting a grammar definition into a definition that is easier to implement using a recursive descent parser; it is an implementation strategy. Thus, the resulting parse trees should contain no record or indication that left-recursion elimination was performed on the grammar before the parser was implemented.
        ]]></text>
        <paragraph hooks="math"><![CDATA[ 
Also note that the resulting parser implementation <code>formula()</code> uses backtracking because the <i>formula</i> production rule has three choices that all begin with the same non-terminal <i>left</i>. It would be possible to perform left factoring on the <i>formula</i> production rule as follows, which would then make it possible to implement <code>formula()</code> as a predictive parser:
\begin{eqnarray}
<i>formula</i> & ::= & <i>left</i> <i>rest</i> \\
<i>rest</i> & ::= & <b>and</b> <i>formula</i> \\
               & | & <b>or</b> <i>formula</i> \\
               & | &
\end{eqnarray}
        ]]></paragraph>
      </example>
    </subsection>
    <assignment title="Grammars, Lexing, and Parsing">
      <instructions>
        <text><![CDATA[
In this assignment you will be implementing lexing and parsing algorithms using Python. You must submit a single Python source file named <code>hw1/hw1.py</code>. Please follow the <a href="#A">gsubmit</a> directions.
        ]]></text>
        <paragraph><![CDATA[
Your solutions to each of the problem parts below will be graded on their correctness, concision, and mathematical legibility. The different problems and problem parts rely on the lecture notes and on each other; carefully consider whether you can use functions from the lecture notes, or functions you define in one part within subsequent parts.
        ]]></paragraph>
        <paragraph><![CDATA[
<b style="color:green;">A testing script with many test cases is available for download: <a href="hw1-tests.py"><code>hw1-tests.py</code></a>. You should be able to place it in the same directory as <code>hw1.py</code> and run it. Feel free to modify or extend it as you see fit.</b>
        ]]></paragraph>
      </instructions>
      <problems>
        <problem>
          <parts>
            <part>
              <text><![CDATA[
Implement a function <code>tokenize()</code> that takes two arguments: a list of terminals and a concrete syntax character string to tokenize. It should build a regular expression, use that regular expression to convert the second string into a token sequence (represented in Python as a list of strings), and then return that token sequence. <b style="color:green;">You should not assume the tokens will always be separated by spaces in the concrete syntax</b>.
              ]]></text>
              <code hooks="Python">
>>> tokenize(["red", "blue", "#"], "red#red blue# red#blue")
['red', '#', 'red', 'blue', '#', 'red', '#', 'blue']
              </code>
            </part>
            <part>
              <text><![CDATA[
Implement a predictive recursive descent parsing algorithm <code>transformation()</code> that takes a token sequence (represented in Python as a list of strings) and parses that token sequence into a parse tree according to the following grammar definition:
              ]]></text>
              <text hooks="math"><![CDATA[
\begin{eqnarray}
<i>transformation</i> & ::= & <b>projection</b> <b>;</b> <i>transformation</i> \\
                  & | & <b>reflection</b> <b>;</b> <i>transformation</i> \\
                  & | & <b>left</b> <b>rotation</b> <b>;</b> <i>transformation</i> \\
                  & | & <b>right</b> <b>rotation</b>  <b>;</b> <i>transformation</i> \\
                  & | & <b>finish</b> <b>;</b>
\end{eqnarray}
              ]]></text>
              <text><![CDATA[
Each node in the parse tree should be labelled <code>"Projection"</code>, <code>"Reflection"</code>, <code>"LeftRotation"</code>, <code>"RightRotation"</code>, or <code>"Finish"</code>. An example input and output are provided below. <b style="color:green;">Note that the output below omits the token list. It is fine if your implementation of <code>transformation()</code> returns an empty token list along with the parse tree.</b>
              ]]></text>
              <code hooks="Python"><![CDATA[
>>> transformation(tokenize(\
               ["projection","reflection","left","right","rotation","finish",";"],\
               "projection; reflection; left rotation; right rotation; reflection; projection; finish;"\
              ))
{'Projection': [{'Reflection': [{'LeftRotation': [{'RightRotation': [{'Reflection': [{'Projection': ['Finish']}]}]}]}]}]}
              ]]></code>
              <text><![CDATA[
For the sake of legibility, we reproduce the output above with indentation using the <code>json</code> module. <b style="color:green;">Your implementation does not need to format its results in this way and can produce it in the above format.</b>
              ]]></text>
              <code hooks="Python"><![CDATA[
{ "Projection": [
    { "Reflection": [
        { "LeftRotation": [
            { "RightRotation": [
                { "Reflection": [
                    { "Projection": ["Finish"]}
                   ]
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}
              ]]></code>
            </part>
          </parts>
        </problem>
        <problem>
          <text><![CDATA[
In this problem you will implement a complete parser for a programming language with the following grammar definition (note that in this language, variables always appear with an initial <b>@</b> character and numeric literals always appear with an initial <code>#</code> character, and these special characters could be separated by whitespace from the actual variable or number):
          ]]></text>
          <text hooks="math"><![CDATA[
\begin{eqnarray}
<i>program</i> & ::= & <b>print</b> <i>formula</i> <b>;</b> <i>program</i> \\
                 & | & <b>print</b> <i>term</i> <b>;</b> <i>program</i> \\
                 & | & <b>assign</b> <b>@</b> <i>variable</i> <b>=</b> <i>term</i> <b>;</b> <i>program</i>\\
                 & | & <b>end</b> <b>;</b> \\
<i>formula</i> & ::= & <b>true</b> \\
               & | & <b>false</b> \\ 
               & | & <b>not (</b> <i>formula</i> <b>)</b> \\
               & | & <b>and (</b> <i>formula</i> <b>,</b> <i>formula</i> <b>)</b> \\
               & | & <b>or (</b> <i>formula</i> <b>,</b> <i>formula</i> <b>)</b> \\
               & | & <b>compare (</b> <i>term</i> <b>,</b> <i>term</i> <b>)</b> \\
               & | & <b>less than (</b> <i>term</i> <b>,</b> <i>term</i> <b>)</b> \\
               & | & <b>greater than (</b> <i>term</i> <b>,</b> <i>term</i> <b>)</b> \\
<i>term</i> & ::= & <b>add (</b> <i>term</i> <b>,</b> <i>term</i> <b>)</b> \\
            & | & <b>subtract (</b> <i>term</i> <b>,</b> <i>term</i> <b>)</b> \\
            & | & <b>abs (</b> <i>term</i> <b>)</b> \\
            & | & <b>@</b> <i>variable</i> \\
            & | & <b>#</b> <i>number</i> \\
<i>variable</i> & ::= & non-empty character strings containing only lowercase alphabetical characters \\
<i>number</i> & ::= & <code>[1-9][0-9]*</code>
\end{eqnarray}
          ]]></text>
          <text><![CDATA[
In addition to a function corresponding to the tokenization algorithm, the parser implementation will consist of five interdependent Python functions: <code>program()</code>, <code>formula()</code>, <code>term()</code>, <code>variable()</code>, and <code>number()</code>. Each function corresponds to one of the productions. Below is an implementation of <code>number()</code>:
          ]]></text>
          <code hooks="Python">
@import re
@def number(tokens):
    @if re.match(r"^([1-9][0-9]*)$", tokens[0]):
        @return ({"Number": [@int(tokens[0])]}, tokens[1:])
          </code>
          <text><![CDATA[
You should examine each of the other productions to determine whether a <a href="#47254608df414ace8d04c630a2b15689">predictive recursive descent</a> parser or a <a href="#95cb72f5b4d24ddba2c8081c7b42618a">backtracking recursive descent</a> parser is required. You should also make calls within each function to one or more of the other functions as needed.
          ]]></text>
          <text><![CDATA[     
<p>Your algorithm must parse all programs in this programming language correctly. However, it need not return useful error messages if the input provided does not conform to the grammar definition.</p>
          ]]></text>
          <parts>
            <part>
               <text><![CDATA[
Implement a function <code>variable()</code> that takes a single token list as an argument and, if the token sequence conforms to the grammar definition, returns a tuple containing two values: an instance of the abstract syntax (i.e., parse tree) with the root node label <code>"Variable"</code>, and the remaining, unparsed suffix of the input token sequence.
               ]]></text>
            </part>
            <part>
               <text><![CDATA[
Implement a function <code>term()</code> that takes a single token list as an argument and, if the token sequence conforms to the grammar definition, returns a tuple containing two values: an instance of the abstract syntax (i.e., parse tree) with an appropriate root node label (<code>"Add"</code>, <code>"Subtract"</code>, <code>"Abs"</code>, <code>"Variable"</code>, or <code>"Number"</code>), and the remaining, unparsed suffix of the input token sequence.
               ]]></text>
               <code hooks="Python">
>>> term(['abs', '(', 'subtract', '(', '#', '2', ',', '#', '3', ')', ')'])
{ "Abs": [
    { "Subtract": [
        { "Number": [2]}, 
        { "Number": [3]}
      ]
    }
  ]
}
              </code>
            </part>
            <part>
               <text><![CDATA[
Implement a function <code>formula()</code> that takes a single token list as an argument and, if the token sequence conforms to the grammar definition, returns a tuple containing two values: an instance of the abstract syntax (i.e., parse tree) with an appropriate root node label (<code>"True"</code>, <code>"False"</code>, <code>"Not"</code>, <code>"And"</code>, <code>"Or"</code>, <code>"Compare"</code>, <code>"LessThan"</code>, or <code>"GreaterThan"</code>), and the remaining, unparsed suffix of the input token sequence.
               ]]></text>
            </part>
            <part>
               <text><![CDATA[
Implement a function <code>program()</code> that takes a single token list as an argument and, if the token sequence conforms to the grammar definition, returns a tuple containing two values: an instance of the abstract syntax (i.e., parse tree) with an appropriate root node label (<code>"Print"</code>, <code>"Assign"</code>, or <code>"End"</code>), and the remaining, unparsed suffix of the input token sequence.
               ]]></text>
            </part>
            <part>
               <text><![CDATA[
Implement a function <code>complete()</code> that takes a single string as an argument. If the input string conforms to the grammar of the programming language, the function should return a parse tree corresponding to that input string.
               ]]></text>
            </part>
          </parts>
        </problem>
        <problem>
          <text><![CDATA[
Extend or modify your parser from the previous problem to support the following grammar:
          ]]></text>
          <text hooks="math"><![CDATA[
\begin{eqnarray}
<i>program</i> & ::= & <b>print</b> <i>formula</i> <b>;</b> <i>program</i> | <b>print</b> <i>term</i> <b>;</b> <i>program</i> \\
               & | & <b>assign</b> <b>@</b> <i>variable</i> <b>=</b> <i>term</i> <b>;</b> <i>program</i> \\
               & | & <b>end</b> <b>;</b> \\
<i>formula</i> & ::= & <b>true</b> | <b>false</b> \\ 
               & | & <b>not (</b> <i>formula</i> <b>)</b> | <b>and (</b> <i>formula</i> <b>,</b> <i>formula</i> <b>)</b> | <b>or (</b> <i>formula</i> <b>,</b> <i>formula</i> <b>)</b> \\
               & | & <b>compare (</b> <i>term</i> <b>,</b> <i>term</i> <b>)</b> | <b>less than (</b> <i>term</i> <b>,</b> <i>term</i> <b>)</b> | <b>greater than (</b> <i>term</i> <b>,</b> <i>term</i> <b>)</b> \\
               & | & <b>(</b> <i>formula</i> <b>&&</b> <i>formula</i> <b>)</b> | <b>(</b> <i>formula</i> <b>||</b> <i>formula</i> <b>)</b> \\
               & | & <b>(</b> <i>term</i> <b>=</b> <i>term</i> <b>)</b> | <b>(</b> <i>term</i> <b>&lt;</b> <i>term</i> <b>)</b> | <b>(</b> <i>term</i> <b>&gt;</b> <i>term</i> <b>)</b> \\
<i>term</i> & ::= & <b>add (</b> <i>term</i> <b>,</b> <i>term</i> <b>)</b> | <b>subtract (</b> <i>term</i> <b>,</b> <i>term</i> <b>)</b> | <b>abs (</b> <i>term</i> <b>)</b>  | <b>@</b> <i>variable</i> | <b>#</b> <i>number</i> \\
            & | & <b>(</b> <i>term</i> <b>+</b> <i>term</i> <b>)</b> 
              %~ | %~ <b>(</b> <i>term</i> <b>-</b> <i>term</i> <b>)</b> 
              %~ | %~ <b>|</b> <i>term</i> <b>|</b> \\
<i>variable</i> & ::= & non-empty character strings containing only lowercase alphabetical characters \\
<i>number</i> & ::= & positive integers or negative integers preceded by <b>&minus;</b>
\end{eqnarray}
          ]]></text>
          <text><![CDATA[
The language that conforms to the above grammar is a strict superset of the language in the previous problem, so your solution should behave the same way as before on the subset of the language in the previous problem. You may use the same parse tree labels for both the prefix and infix notation for each construct and operator (<code>&&</code> corresponds to <code>and</code>, <code>||</code> corresponds to <code>or</code>, <code>=</code> corresponds to <code>compare</code>, <code>&lt;</code> corresponds to <code>less than</code>, <code>&gt;</code> corresponds to <code>greater than</code>, <code>+</code> corresponds to <code>add</code>, <code>-</code> corresponds to <code>subtract</code> and <code>|...|</code> corresponds to <code>abs</code>).
          ]]></text>
        </problem>
      </problems>
    </assignment>
  </section>
  <section title="Semantics, Evaluation, and Interpretation">
    <subsection title="Formally defining an abstract syntax">
      <text><![CDATA[
While the abstract syntax of a programming language is the set of data structure instances that represent programs, it is also useful to model the abstract syntax as a mathematical object in its own right. This makes it possible to define formally (i.e., mathematically, independently of any implementation language, platform, operating system, and so on) the meaning of a language, and how programs can be run. It also makes it possible to formally define analyses on programs, as well as properties of transformations over programs.
      ]]></text>
      <paragraph><![CDATA[
Typically, an abstract syntax definition will closely match a concrete syntax definition, except that there is no need to specify the token set, and redundant syntactic constructs and syntactic sugar will be eliminated. For example, parentheses are a syntactic convention that is not necessary if one is working with parse trees because parse trees are already grouped implicitly due to the tree structure of the abstract syntax instance.
      ]]></paragraph>
      <example required="true" id="7bf280c88ee14a299c3490762a33e4dd">
        <text  hooks="math"><![CDATA[
The following is an example of an abstract syntax definition.
\begin{eqnarray}
<i>formula</i> & ::= & <b>true</b> | <b>false</b> | <b>not</b> <i>formula</i> | <i>formula</i> <b>and</b> <i>formula</i> | <i>formula</i> <b>or</b> <i>formula</i>
\end{eqnarray}
Notice the omission of the parentheses. Also, there is no need to be concerned with the fixity (i.e., infix vs. prefix) of binary operators, since this definition is not being used to implement a parsing algorithm.
        ]]></text>
      </example>
    </subsection>
    <subsection title="Denotational semantics and operational semantics">
      <text><![CDATA[
The abstract syntax of a programming language is a set of symbolic objects (i.e., the abstract syntax instances, such as programs) that have no meaning unless a meaning is assigned to them. There are two ways in which we can assign meaning to these objects. We can choose to assign a mathematical object to each abstract syntax instance, or we can define a collection of deterministic transformations that specify how we can convert each abstract syntax instance into another abstract syntax instance. Roughly speaking, assigning a mathematical object to each program tells us what it <i>means</i>, while specifying symbolic converion rules tells us how to <i>run</i> the program.
      ]]></text>
      <definition required="true" hooks="math" id="41aa3d27c2754fa880cb8c2280322f63"><![CDATA[
The <i>denotational semantics</i> of an abstract syntax is a mapping from the set of abstract syntax instances %A to some mathematical set of objects %D, which is often called a <i>semantic domain</i> or just <i>domain</i>. The mapping from %A to %D itself is often denoted using the circumfix Oxford double bracket notation [[ ... ]], and the definition of a denotational semantics of %A (i.e., the definition of this mapping [[ ... ]]) is often specified using a collection of inference rules.
      ]]></definition>
      <definition required="true" hooks="math" id="63092f7e13d44b0cac8bde679e6f2c6d"><![CDATA[
Let %A be an abstract syntax of a programming language. The <i>operational semantics</i> of an abstract syntax is a set of rules that specify how each abstract syntax instance %a \in %A can be transformed some kind of object that represents the result of performing the computation described by %A.
      ]]></definition>
      <text><![CDATA[
There are distinct kinds of operational semantics, such as <i>small-step semantics</i> and <i>big-step semantics</i> (also known as <i>natural semantics</i>). In this course, the operational semantics we will be using is closest to big-step semantics, with some simplifications. We adopt this particular approach to defining operational semantics because it corresponds more closely to a functional, recursive implementation of an algorithm for interpreting programs.
<br/><br/>
The operational semantics for a programming language represents a <i>contract</i>, a set of <i>constraints</i>, or a set of <i>requirements</i> that an algorithm that implementing an interpreter or compiler of that language must respect in order to be considered correct. However, whoever builds an implementation of an interpreter or compiler for a language has full freedom and flexibility in how they choose to implement the interpreter in all other aspects as long as it conforms to the operational semantics. This is what makes it possible to introduce optimizations into interpreters and compilers (such as optimizations to improve performance or reduce use of memory) while preserving the correctness of their behavior. The operational semantics for a programming language is defined using a collection of <i>inference rules</i>.
      ]]></text>
      <definition required="true" id="9af40ca04b2f44c795bbb02e7bed83ef">
        <text hooks="math"><![CDATA[
An <i>inference rule</i> is a notation used within mathematics and computer science to define relationships between mathematical facts and formulas. Each inference rule consists of a horizontal line with zero or more logical formulas above the line and one logial formula below the line. The logical formulas above the line are called <i>premises</i>, and the formula below the line is called the <i>conclusion</i>.
       ]]></text>
        <inferences hooks="math">
          <inference title="Name-of-Inference-Rule">
            <premises><![CDATA[<i>premise</i> %~ %~ <i>premise</i>]]></premises>
            <conclusion><![CDATA[<i>conclusion</i>]]></conclusion>
          </inference>
          <inference title="Example">
            <premises><![CDATA[<b>sun is out</b> %~ %~ <b>sky is clear</b>]]></premises>
            <conclusion><![CDATA[<b>it is not raining</b>]]></conclusion>
          </inference>
        </inferences>
        <text hooks="math"><![CDATA[
An inference rule can be interpreted as a portion of a larger algorithm. The premises specify the recursive calls, or calls to other functions, that may need to be made, and the results that are obtained from those invocations. The conclusion specifies what inputs can be handled by that inference rule, and what outputs should be returned given those inputs and the premises.
       ]]></text>
        <inferences hooks="math">
          <inference title="Algorithm-Case">
            <premises><![CDATA[<i>input_1</i> \Downarrow <i>output_1</i> %~ %~ <i>input_2</i> \Downarrow <i>output_2</i>]]></premises>
            <conclusion><![CDATA[<i>input_0</i> \Downarrow <i>output_0</i>]]></conclusion>
          </inference>
        </inferences>
        <text hooks="math"><![CDATA[
Note that in the above, <i>input_1</i> and <i>input_2</i> may depend on <i>input_0</i>, and <i>output_0</i> may depend on <i>output_1</i> and <i>output_2</i>. In other words, one could rewrite an inference rule in the following way using natural language:
       ]]></text>
        <inferences hooks="math">
          <inference title="Algorithm-Case">
            <premises><![CDATA[<b>invoking this or another algorithm with</b> <i>input_1</i> <b>yields</b> <i>output_1</i>]]></premises>
            <conclusion><![CDATA[<b>given</b> <i>input_0</i>, <b> and if premises above are true, then output</b> <i>output_0</i>]]></conclusion>
          </inference>
        </inferences>
       </definition>
    </subsection>
    <subsection title="Evaluation of expressions">
      <text><![CDATA[
The abstract syntax, or a subset of the abstract syntax, of a programming language is considered to be a set of <i>expressions</i> if the language's operational semantics do not impose any restrictions on the <i>order</i> in which a computation can operate on the expression to produce a result, called a <i>value</i>. This is possible because expressions usually represent operations with no <i>side effects</i>, such as emitting output to a screen, reading or writing files, looking at a clock, controlling a device, and so on.
      ]]></text>
      <definition required="true" hooks="math" id="b16e887dc1bc430da525e124a5f603b1"><![CDATA[
Let %A be an abstract syntax of a programming language, and let %V be some subset of %A that we will call the <i>value set</i>. This set will represent the possible meanings of parse trees in %A, and it will represent the possible results of evaluating parse trees in %A. Values that can occur directly within abstract syntax trees of the language (e.g., numeric and string literals, constructors, and so on) are usually called <i>constants</i>.
      ]]></definition>
      <definition required="true" hooks="math" id="53f0258543cc4f4592e7dc534bdfff60"><![CDATA[
An <i>evaluation algorithm</i> converts any abstract syntax tree that represents an expression into an abstract syntax tree that represents a value.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">expressions<br/>(abstract syntax)</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">evaluation<br/>algorithm</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">values<br/>(abstract syntax)</td>
  </tr>
</table>
</div>
      ]]></definition>
      <example required="true" id="634d9dc447034b4abc749a6713b63c19">
        <text hooks="math"><![CDATA[
Define the abstract syntax according to the following grammar, with %A consisting of all formula abstract syntax instances, and %V = {<b>true</b>, <b>false</b>} consisting of all value abstract syntax instances:
\begin{eqnarray}
<i>formula</i> & ::= & <i>value</i> | <b>not</b> <i>formula</i> | <i>formula</i> <b>and</b> <i>formula</i> | <i>formula</i> <b>or</b> <i>formula</i> \\
<i>value</i> & ::= & <b>true</b> | <b>false</b>
\end{eqnarray}
The following is a definition of an operational semantics for this language.
        ]]></text>
        <inferences hooks="math">
          <inference title="True">
            <premises><![CDATA[]]></premises>
            <conclusion><![CDATA[<b>true</b> \Downarrow <b>true</b>]]></conclusion>
          </inference>
          <inference title="False">
            <premises><![CDATA[]]></premises>
            <conclusion><![CDATA[<b>false</b> \Downarrow <b>false</b>]]></conclusion>
          </inference>
          <inference title="Not-True">
            <premises><![CDATA[%f \Downarrow <b>true</b>]]></premises>
            <conclusion><![CDATA[<b>not</b> %f \Downarrow <b>false</b>]]></conclusion>
          </inference>
          <inference title="Not-False">
            <premises><![CDATA[%f \Downarrow <b>false</b>]]></premises>
            <conclusion><![CDATA[<b>not</b> %f \Downarrow <b>true</b>]]></conclusion>
          </inference>
          <inference title="And-True-True">
            <premises><![CDATA[%f_1 \Downarrow <b>true</b> %~ %~ %f_2 \Downarrow <b>true</b>]]></premises>
            <conclusion><![CDATA[%f_1 <b>and</b> %f_2 \Downarrow <b>true</b>]]></conclusion>
          </inference>
          <inference title="And-True-False">
            <premises><![CDATA[%f_1 \Downarrow <b>true</b> %~ %~ %f_2 \Downarrow <b>false</b>]]></premises>
            <conclusion><![CDATA[%f_1 <b>and</b> %f_2 \Downarrow <b>false</b>]]></conclusion>
          </inference>
          <inference title="And-False-True">
            <premises><![CDATA[%f_1 \Downarrow <b>false</b> %~ %~ %f_2 \Downarrow <b>true</b>]]></premises>
            <conclusion><![CDATA[%f_1 <b>and</b> %f_2 \Downarrow <b>false</b>]]></conclusion>
          </inference>
          <inference title="And-False-False">
            <premises><![CDATA[%f_1 \Downarrow <b>false</b> %~ %~ %f_2 \Downarrow <b>false</b>]]></premises>
            <conclusion><![CDATA[%f_1 <b>and</b> %f_2 \Downarrow <b>false</b>]]></conclusion>
          </inference>
          <inference title="Or-True-True">
            <premises><![CDATA[%f_1 \Downarrow <b>true</b> %~ %~ %f_2 \Downarrow <b>true</b>]]></premises>
            <conclusion><![CDATA[%f_1 <b>or</b> %f_2 \Downarrow <b>true</b>]]></conclusion>
          </inference>
          <inference title="Or-True-False">
            <premises><![CDATA[%f_1 \Downarrow <b>true</b> %~ %~ %f_2 \Downarrow <b>false</b>]]></premises>
            <conclusion><![CDATA[%f_1 <b>or</b> %f_2 \Downarrow <b>true</b>]]></conclusion>
          </inference>
          <inference title="Or-False-True">
            <premises><![CDATA[%f_1 \Downarrow <b>false</b> %~ %~ %f_2 \Downarrow <b>true</b>]]></premises>
            <conclusion><![CDATA[%f_1 <b>or</b> %f_2 \Downarrow <b>true</b>]]></conclusion>
          </inference>
          <inference title="Or-False-False">
            <premises><![CDATA[%f_1 \Downarrow <b>false</b> %~ %~ %f_2 \Downarrow <b>false</b>]]></premises>
            <conclusion><![CDATA[%f_1 <b>or</b> %f_2 \Downarrow <b>false</b>]]></conclusion>
          </inference>
        </inferences>
      </example>
      <example required="true" id="60b6dc0bb16b498594677f3bb08ccc82">
        <text hooks="math"><![CDATA[
The rules in the above example are numerous, and having this many rules in a definition becomes impractical (especially with more complex operators and language constructs). To address this, we can define a meta-language on the set of values %V = {<b>true</b>, <b>false</b>}.
\begin{eqnarray}
\neg <b>true</b> & = & <b>false</b>\\
\neg <b>false</b> & = & <b>true</b>\\
<b>true</b> \wedge <b>true</b> & = & <b>true</b>\\
<b>true</b> \wedge <b>false</b> & = & <b>false</b>\\
<b>false</b> \wedge <b>true</b> & = & <b>false</b>\\
<b>false</b> \wedge <b>false</b> & = & <b>false</b>\\
<b>true</b> \vee <b>true</b> & = & <b>true</b>\\
<b>true</b> \vee <b>false</b> & = & <b>true</b>\\
<b>false</b> \vee <b>true</b> & = & <b>true</b>\\
<b>false</b> \vee <b>false</b> & = & <b>false</b>
\end{eqnarray}
The definition then becomes more concise.
        ]]></text>
        <inferences hooks="math">
          <inference title="True">
            <premises><![CDATA[]]></premises>
            <conclusion><![CDATA[<b>true</b> \Downarrow <b>true</b>]]></conclusion>
          </inference>
          <inference title="False">
            <premises><![CDATA[]]></premises>
            <conclusion><![CDATA[<b>false</b> \Downarrow <b>false</b>]]></conclusion>
          </inference>
          <inference title="Not">
            <premises><![CDATA[%f \Downarrow %v]]></premises>
            <conclusion><![CDATA[<b>not</b> %f \Downarrow \neg %v]]></conclusion>
          </inference>
          <inference title="And">
            <premises><![CDATA[%f_1 \Downarrow %v_1 %~ %~ %f_2 \Downarrow %v_2]]></premises>
            <conclusion><![CDATA[%f_1 <b>and</b> %f_2 \Downarrow %v_1 \wedge %v_2]]></conclusion>
          </inference>
          <inference title="Or">
            <premises><![CDATA[%f_1 \Downarrow %v_1 %~ %~ %f_2 \Downarrow %v_2]]></premises>
            <conclusion><![CDATA[%f_1 <b>or</b> %f_2 \Downarrow %v_1 \vee %v_2]]></conclusion>
          </inference>
        </inferences>
        <text hooks="math"><![CDATA[
We can convert the above operational semantics inference rules into a Python implementation of an interpreter for this simple language. The functions <code>vnot</code>, <code>vand</code>, and <code>vor</code> correspond to \neg, \wedge, and \vee, respectively, in the operational semantics.
        ]]></text>
        <code hooks="Python">
@def vnot(v):
    @if v == 'True':  @return 'False'
    @if v == 'False': @return 'True'

@def vand(v1, v2):
    if v1 == 'True'  @and v2 == 'True':  @return 'True'
    if v1 == 'True'  @and v2 == 'False': @return 'False'
    if v1 == 'False' @and v2 == 'True':  @return 'False'
    if v1 == 'False' @and v2 == 'False': @return 'False'

@def vor(v1, v2):
    @if v1 == 'True'  @and v2 == 'True':  @return 'True'
    @if v1 == 'True'  @and v2 == 'False': @return 'True'
    @if v1 == 'False' @and v2 == 'True':  @return 'True'
    @if v1 == 'False' @and v2 == 'False': @return 'False'

Node = @dict
Leaf = @str

@def evaluate(e):
    @if @type(e) == Node:
        @for label @in e:
            children = e[label]
            @if label == 'Not':
                f = children[0]
                v = evaluate(f)
                @return vnot(v)
            @elif label == 'And':
                # Notice that we can make the recursive calls
                # below in any order we like; the order of the
                # calls is not specified by the operational
                # semantics.
                f1 = children[0]
                v1 = evaluate(f1)
                f2 = children[1]
                v2 = evaluate(f2)
                @return vand(v1, v2)
            @elif label == 'Or':
                f2 = children[1]
                v2 = evaluate(f2)
                f1 = children[0]
                v1 = evaluate(f1)
                @return vor(v1, v2)
    @elif @type(e) == Leaf:
        @if e == 'True':
            @return 'True'
        @if e == 'False':
            @return 'False'
        </code>
        <text hooks="math"><![CDATA[
In fact, we could convert the above so that it returns a Python value directly, rather than an abstract syntax tree corresponding to a value.
        ]]></text>
        <code hooks="Python">
@def evaluate(e):
    @if @type(e) == Node:
        @for label @in e:
            children = e[label]
            @if label == 'Not':
                f = children[0]
                v = evaluate(f)
                @return @not v # Use the Python not operator.
            @elif label == 'And':
                f1 = children[0]
                v1 = evaluate(f1)
                f2 = children[1]
                v2 = evaluate(f2)
                @return v1 @and v2 # Use the Python and operator.
            @elif label == 'Or':
                f2 = children[1]
                v2 = evaluate(f2)
                f1 = children[0]
                v1 = evaluate(f1)
                @return v1 @or v2 # Use the Python or operator.
    @elif @type(e) == Leaf:
        @if e == 'True':
            @return @True # Use the Python True constant.
        @if e == 'False':
            @return @False # Use the Python False constant.
        </code>
      </example>
    </subsection>
    <subsection title="Execution of sequences of statements">
      <text><![CDATA[
The abstract syntax, or a subset of the abstract syntax, of a programming language is considered to be a set of <i>statements</i> if the operational semantics for that syntax impose a sequential ordering on the computation they represent. This usually corresponds to the notion of a single point of <i>control flow</i> traversing the program's abstract syntax as the program is executed (which is a good model of a computer architecture that contains only a single processor that can perform one instruction at a time).
<br/><br/>
Languages that have statements and a notion of control flow are called <i>imperative</i>. Languages that have only expressions and no statements can be called <i>pure</i> or <i>functional</i>, although that terminology will often have additional meanings in such a context that we will go over in subsequent sections.
      ]]></text>
      <definition required="true" hooks="math" id="db57dc0684174cd097ebf73d733dc9bc"><![CDATA[
Let %A be an abstract syntax of a programming language, and let %V be some subset of %A. Let %O be a set of possible outputs (e.g., a text terminal or file).
        <ul>
          <li>In this course, we will denote a possible output in %O using the symbol %o.</li>
          <li>We denote the empty output using %o_0.</li>
          <li>We denote an output %o <b>preceded</b> by the value %v as %v;%o (that is, %v is the first value in the output %v;%o, and %o is the rest).</li>
          <li>Given two outputs %o_1 and %o_2, %o_1;%o_2 represents two outputs in sequence: %o_1 followed by %o_2.</li>
        </ul>
      ]]></definition>
      
      <definition required="true" hooks="math" id="28221c6d8fdd4748bd22545462178e97"><![CDATA[
An <i>execution algorithm</i> converts any abstract syntax tree that represents a sequence of statements into an abstract syntax tree that represents an output.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">statement sequence<br/>(abstract syntax)</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">execution<br/>algorithm</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">output<br/>(record of side effects)</td>
  </tr>
</table>
</div>
      ]]></definition>
      <text hooks="math"><![CDATA[
Thus, we can represent an output in Python using, for example, a list of values.
      ]]></text>
      <example required="true" id="5dead3e1ed524b24a68fc4f4b393eb8a">
        <text hooks="math"><![CDATA[
We present an operational semantics for a simple programming language with statements. 
\begin{eqnarray}
<i>program</i> & ::= & <b>print</b> <i>formula</i> <b>;</b> <i>program</i> | <b>end</b> <b>;</b> \\
<i>formula</i> & ::= & <i>value</i> | <b>not</b> <i>formula</i> | <i>formula</i> <b>and</b> <i>formula</i> | <i>formula</i> <b>or</b> <i>formula</i> \\
<i>value</i> & ::= & <b>true</b> | <b>false</b>
\end{eqnarray}
Recall that %O represents the set of outputs (e.g., to the terminal), with %o_0 representing the empty output and %v;%o representing a terminal %o with the value %v as its first output.
        ]]></text>
        <inferences hooks="math">
          <inference title="Statement-Print">
            <premises><![CDATA[%p \Downarrow %o %~ %~ %f \Downarrow %v]]></premises>
            <conclusion><![CDATA[<b>print</b> %f <b>;</b> %p \Downarrow %v;%o]]></conclusion>
          </inference>
          <inference title="Statement-End">
            <premises><![CDATA[]]></premises>
            <conclusion><![CDATA[<b>end ;</b> \Downarrow %o_0]]></conclusion>
          </inference>
          <inference title="Formula-True">
            <premises><![CDATA[]]></premises>
            <conclusion><![CDATA[<b>true</b> \Downarrow <b>true</b>]]></conclusion>
          </inference>
          <inference title="Formula-False">
            <premises><![CDATA[]]></premises>
            <conclusion><![CDATA[<b>false</b> \Downarrow <b>false</b>]]></conclusion>
          </inference>
          <inference title="Formula-Not">
            <premises><![CDATA[%f \Downarrow %v]]></premises>
            <conclusion><![CDATA[<b>not</b> %f \Downarrow \neg %v]]></conclusion>
          </inference>
          <inference title="Formula-And">
            <premises><![CDATA[%f_1 \Downarrow %v_1 %~ %~ %f_2 \Downarrow %v_2]]></premises>
            <conclusion><![CDATA[%f_1 <b>and</b> %f_2 \Downarrow %v_1 \wedge %v_2]]></conclusion>
          </inference>
          <inference title="Formula-Or">
            <premises><![CDATA[%f_1 \Downarrow %v_1 %~ %~ %f_2 \Downarrow %v_2]]></premises>
            <conclusion><![CDATA[%f_1 <b>or</b> %f_2 \Downarrow %v_1 \vee %v_2]]></conclusion>
          </inference>
        </inferences>
        <text hooks="math"><![CDATA[
We can convert the above operational semantics inference rules into a Python implementation of an interpreter for this simple language. We represent outputs in %O as Python lists of values, because lists preserve order. Note that we refer to the implementation of <code>evaluate()</code> from a <a href="60b6dc0bb16b498594677f3bb08ccc82">previous example</a>.
        ]]></text>
        <code hooks="Python">
@def execute(s):
    @if @type(s) == Leaf:
        @if s == 'End':
            @return []
    @elif @type(s) == Node:
        @for label @in s:
            @if label == 'Print':
                children = s[label]
                f = children[0]
                p = children[1]
                v = evaluate(f) # Implemented elsewhere.
                o = execute(p)
                @return [v] + o
        </code>
        <text hooks="math"><![CDATA[
As before, we can actually use the Python <code>print()</code> function and turn this into an interpreter that uses the Python runtime system directly to interpret the program. However, we must be careful about where we put the call to <code>print()</code>: it must be invoked in a way that conforms to a <i>pre-order</i> traversal of the syntax tree.
        ]]></text>
        <code hooks="Python">
@def execute(s):
    @if @type(s) == Leaf:
        @if s == 'End':
            @return []
    @elif @type(s) == Node:
        @for label @in s:
            @if label == 'Print':
                children = s[label]
                f = children[0]
                p = children[1]
                v = evaluate(f)
                @print(v) # Must appear before recursive call.
                o = execute(p)
                @return [v] + o
        </code>
      </example>
      <text hooks="math"><![CDATA[
        In an operational semantics for a language with variables and variable assignment, a data structure called an <i>environment</i> is usually used to represent what variables are in scope, as well as the values assigned to variables. We introduce a mathematical definition of an environment so that we can employ it within our operational semantics definitions.
      ]]></text>
      <definition required="true" hooks="math" id="e1a5053a93d54ad4b02da10e4981b810"><![CDATA[
        Given a programming language definition with a set of values %V and a set of possible variable names %X (as defined by the concrete syntax), an <i>environment</i> or <i>context</i> is a mapping from a subset of the variables %X to the set of values %V.      
        <ul>
          <li>In this course, we will usually denote an environment using the symbol \Sigma.</li>
          <li>Given a variable name %x \in %X, we denote by \Sigma(%x) the value that the environment \Sigma assigns to %x.</li>
          <li>An empty environment (one that does not map any variable names to any values) is denoted using \Sigma_0.</li>
          <li>Given an environment \Sigma, a variable %x \in %X, and a value %v \in %V, we denote by \Sigma \uplus {%x \mapsto %v} the extension of the environment \Sigma with a new mapping from %x to %v (i.e., if \Sigma' = \Sigma \uplus {%x \mapsto %v} then \Sigma'(%x) = %v).</li>
        </ul>
      ]]></definition>
      <text hooks="math"><![CDATA[
We can update our diagram for an execution algorithm.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:#ECECEC;">
      <table class="container">
        <tr>
          <td class="box" style="background-color:powderblue;">environment</td>
          <td class="box" style="background-color:powderblue;">statement sequence<br/>(abstract syntax)</td>
        </tr>
      </table>
    </td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">execution<br/>algorithm</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">output<br/>(record of side effects)</td>
  </tr>
</table>
</div> 
Within implementations of interpreters and compilers, environments will often be represented with finite maps, associative lists, dictionary, or stacks, depending on the structure and semantics of the language.
      ]]></text>
      <example required="true" id="cbfa02d3624d42b08704d6a4c4fb9e03">
        <text hooks="math"><![CDATA[
We present an operational semantics for a simple programming language with variables and variable assignment.
\begin{eqnarray}
<i>program</i> & ::= & <b>print</b> <i>formula</i> <b>;</b> <i>program</i> | <b>assign</b> <i>variable</i> <b>:=</b> <i>formula</i> <b>;</b> <i>program</i> | <b>end</b> <b>;</b> \\
<i>formula</i> & ::= & <i>value</i> | <i>variable</i> | <b>not</b> <i>formula</i> | <i>formula</i> <b>and</b> <i>formula</i> | <i>formula</i> <b>or</b> <i>formula</i> \\
<i>variable</i> & ::= & <i>any valid variable name as defined by the concrete syntax</i> \\
<i>value</i> & ::= & <b>true</b> | <b>false</b>
\end{eqnarray}
Notice the use of an environment \Sigma, also known as a context, that maps variable names to values.
        ]]></text>
        <inferences hooks="math">
          <inference title="Statement-Assign">
            <premises><![CDATA[\Sigma \uplus {%x \mapsto %v}, %p \Downarrow %o %~ %~ \Sigma, %f \Downarrow %v]]></premises>
            <conclusion><![CDATA[\Sigma, <b>assign</b> %x <b>:=</b> %f <b>;</b> %p \Downarrow %o]]></conclusion>
          </inference>
          <inference title="Statement-Print">
            <premises><![CDATA[\Sigma, %p \Downarrow %o %~ %~ \Sigma, %f \Downarrow %v]]></premises>
            <conclusion><![CDATA[\Sigma, <b>print</b> %f <b>;</b> %p \Downarrow %v;%o]]></conclusion>
          </inference>
          <inference title="Statement-End">
            <premises><![CDATA[]]></premises>
            <conclusion><![CDATA[\Sigma, <b>end ;</b> \Downarrow %o_0]]></conclusion>
          </inference>
          <inference title="Formula-True">
            <premises><![CDATA[]]></premises>
            <conclusion><![CDATA[\Sigma, <b>true</b> \Downarrow <b>true</b>]]></conclusion>
          </inference>
          <inference title="Formula-False">
            <premises><![CDATA[]]></premises>
            <conclusion><![CDATA[\Sigma, <b>false</b> \Downarrow <b>false</b>]]></conclusion>
          </inference>
          <inference title="Formula-Not">
            <premises><![CDATA[\Sigma, %f \Downarrow %v]]></premises>
            <conclusion><![CDATA[\Sigma, <b>not</b> %f \Downarrow \neg %v]]></conclusion>
          </inference>
          <inference title="Formula-And">
            <premises><![CDATA[\Sigma, %f_1 \Downarrow %v_1 %~ %~ \Sigma, %f_2 \Downarrow %v_2]]></premises>
            <conclusion><![CDATA[\Sigma, %f_1 <b>and</b> %f_2 \Downarrow %v_1 \wedge %v_2]]></conclusion>
          </inference>
          <inference title="Formula-Or">
            <premises><![CDATA[\Sigma, %f_1 \Downarrow %v_1 %~ %~ \Sigma, %f_2 \Downarrow %v_2]]></premises>
            <conclusion><![CDATA[\Sigma, %f_1 <b>or</b> %f_2 \Downarrow %v_1 \vee %v_2]]></conclusion>
          </inference>
          <inference title="Formula-Variable">
            <premises><![CDATA[\Sigma(%x) = %v]]></premises>
            <conclusion><![CDATA[\Sigma, %x \Downarrow %v]]></conclusion>
          </inference>
        </inferences>
        <text hooks="math"><![CDATA[
We can convert the above operational semantics inference rules into a Python implementation of an interpreter for this language. We represent environments as dictionaries in which variable names are labels, and these labels map to values in the language. The functions <code>vnot</code>, <code>vand</code>, and <code>vor</code> are the same as those in a <a href="60b6dc0bb16b498594677f3bb08ccc82">previous example</a>.
        ]]></text>
        <code hooks="Python">
@def evaluate(env, e):
    @if @type(e) == Node:
        @for label @in e:
            children = e[label]
            @if label == 'Not':
                f = children[0]
                v = evaluate(env, f)
                @return vnot(v)
            @elif label == 'And':
                f1 = children[0]
                v1 = evaluate(env, f1)
                f2 = children[1]
                v2 = evaluate(env, f2)
                @return vand(v1, v2)
            @elif label == 'Or':
                f2 = children[1]
                v2 = evaluate(env, f2)
                f1 = children[0]
                v1 = evaluate(env, f1)
                @return vor(v1, v2)
            @elif label == 'Variable':
                x = children[0]
                @if x @in env:
                    @return env[x]
                @else:
                    print(x + " is unbound.")
                    @exit()
    @elif @type(e) == Leaf:
        @if e == 'True':
            @return 'True'
        @if e == 'False':
            @return 'False'

@def execute(env, s):
    if @type(s) == Leaf:
        @if s == 'End':
            @return []
    @elif @type(s) == Node:
        @for label @in s:
            @if label == 'Print':
                children = s[label]
                f = children[0]
                p = children[1]
                v = evaluate(env, f)
                o = execute(env, p)
                @return [v] + o
            @if label == 'Assign':
                children = s[label]
                x = children[0]['Variable'][0]
                f = children[1]
                p = children[2]
                v = evaluate(env, f)
                env[x] = v
                o = execute(env, p)
                @return o
        </code>
      </example>
      <text hooks="math"><![CDATA[
If an abstract syntax parse tree node for a statement can have two or more children that are also statement sequences, and if the operational semantics of the language require that statements must be executed consecutively (i.e., not in parallel), then the execution algorithm must also return a new copy of the environment, modified to reflect the variable assignments that might have occurred in the statement sequence.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:#ECECEC;">
      <table class="container">
        <tr>
          <td class="box" style="background-color:powderblue;">environment</td>
          <td class="box" style="background-color:powderblue;">statement sequence<br/>(abstract syntax)</td>
        </tr>
      </table>
    </td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">execution<br/>algorithm</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:#ECECEC;">
      <table class="container">
        <tr>
          <td class="box" style="background-color:powderblue;">environment</td>
          <td class="box" style="background-color:powderblue;">output<br/>(record of side effects)</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
</div>
      ]]></text>
      <example required="true" id="c09ab939e50b40428d392867c00b4710">
        <text hooks="math"><![CDATA[
We present an operational semantics for an extension of a language in a <a href="#cbfa02d3624d42b08704d6a4c4fb9e03">previous example</a>.
\begin{eqnarray}
<i>program</i> & ::= & <b>print</b> <i>formula</i> <b>;</b> <i>program</i> \\
  & | & <b>assign</b> <i>variable</i> <b>:=</b> <i>formula</i> <b>;</b> <i>program</i> \\
  & | & <b>repeat</b> <b>twice</b> <b>{</b> <i>program</i> <b>}</b> <i>program</i> \\
  & | & <b>end</b> <b>;</b> \\
    & \vdots & 
\end{eqnarray}
An example of a program in this language is presented below:
        ]]></text>
        <code hooks="Python">
print true;
repeat twice {
  print false;
  end;
}
print true;
end;
        </code>
        <text hooks="math"><![CDATA[
The operational semantics inference rules are the same as those in a <a href="#cbfa02d3624d42b08704d6a4c4fb9e03">previous example</a>. However, we must modify the inference rules for statements. In particular, the predicate \Downarrow that defines execution of statements must also specify the new environment that exists after a statement is executed. This is to capture the fact that a program may have variable assignments in a block of code that may be executed multiple times (or, in other languages with branching constructs, may be executed conditionally).
        ]]></text>
        <inferences hooks="math">
          <inference title="Statement-Assign">
            <premises><![CDATA[\Sigma_1 \uplus {%x \mapsto %v}, %p \Downarrow \Sigma_2, %o %~ %~ \Sigma_1, %f \Downarrow %v]]></premises>
            <conclusion><![CDATA[\Sigma_1, <b>assign</b> %x <b>:=</b> %f <b>;</b> %p \Downarrow \Sigma_2, %o]]></conclusion>
          </inference>
          <inference title="Statement-Print">
            <premises><![CDATA[\Sigma_1, %p \Downarrow \Sigma_2, %o %~ %~ \Sigma_1, %f \Downarrow %v]]></premises>
            <conclusion><![CDATA[\Sigma_1, <b>print</b> %f <b>;</b> %p \Downarrow \Sigma_2, %v;%o]]></conclusion>
          </inference>
          <inference title="Statement-Repeat-Twice">
            <premises><![CDATA[
              \Sigma_1, %p_1 \Downarrow \Sigma_2, %o_1 %~ %~ \Sigma_2, %p_1 \Downarrow \Sigma_3, %o_2 %~ %~ \Sigma_3, %p_2 \Downarrow \Sigma_4, %o_3
            ]]></premises>
            <conclusion><![CDATA[\Sigma_1, <b>repeat twice</b> <b>{</b> %p_1 <b>}</b> %p_2 \Downarrow \Sigma_4, %o_1;%o_2;%o_3]]></conclusion>
          </inference>
          <inference title="Statement-End">
            <premises><![CDATA[]]></premises>
            <conclusion><![CDATA[\Sigma, <b>end ;</b> \Downarrow \Sigma, %o_0]]></conclusion>
          </inference>
        </inferences>

        <text hooks="math"><![CDATA[
We can convert the above operational semantics inference rules into a Python implementation of an interpreter for this language. The implementation of <code>evaluate()</code> is the same as the one in a <a href="#cbfa02d3624d42b08704d6a4c4fb9e03">previous example</a>, while the implementation of <code>execute()</code> from <a href="#cbfa02d3624d42b08704d6a4c4fb9e03">that example</a> must be modified so that it also returns an updated version of the environment data structure.
        ]]></text>
        <code hooks="Python">
@def execute(env, s):
    @if @type(s) == Leaf:
        @if s == 'End':
            @return (env, [])
    @elif @type(s) == Node:
        @for label @in s:
            @if label == 'Print':
                children = s[label]
                f = children[0]
                p = children[1]
                v = evaluate(env, f)
                (env, o) = execute(env, p)
                @return (env, [v] + o)
            @if label == 'Assign':
                children = s[label]
                x = children[0]['Variable'][0]
                f = children[1]
                p = children[2]
                v = evaluate(env, f)
                env[x] = v
                (env, o) = execute(env, p)
                @return (env, o)
            @if label == 'RepeatTwice':
                children = s[label]
                body = children[0]
                rest = children[1]
                env1 = env
                (env2, o1) = execute(env1, body)
                (env3, o2) = execute(env2, body)
                (env4, o3) = execute(env3, rest)
                @return (env4, o1 + o2 + o3)
        </code>
      </example>
    </subsection>
    
    
    
    
    <subsection title="Interpreters">
      <text><![CDATA[
An interpreter is an algorithm that invokes evaluation and execution algorithms as required by the operational semantics for a language.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">program<br/>(abstract syntax)</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:#ECECEC;">
      <table class="container">
        <tr>
          <td class="box" style="background-color:lightyellow;">evaluation<br/>algorithm</td>
          <td class="box" style="background-color:lightyellow;">execution<br/>algorithm</td>
        </tr>
      </table>
    </td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">output and/or<br/>value(s)<br/></td>
  </tr>
</table>
</div>
Often, the term <i>interpreter</i> will refer to the entire toolchain of components that make it possible to convert the character string (i.e., concrete syntax) representation of a program in the source language into value(s) and/or a record of the side effects of a program. In these cases, we will refer to the individual component that performs interpretation as the <i>interpretation algorithm</i> or <i>interpretation component</i>.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">character string<br/>(concrete syntax)</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:#EFEFEF;">
      <table class="container">
        <tr>
        <td class="box" style="background-color:lightyellow;">parser</td>
        <td><span style="font-size:20px;">&#8658;</span></td>
        <td class="box" style="background-color:powderblue;">abstract<br/>syntax</td>
        <td><span style="font-size:20px;">&#8658;</span></td>
        <td class="box" style="background-color:lightyellow;">interpretation<br/>algorithm</td>
        </tr>
      </table>
      <br/>interpreter
    </td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">output and/or<br/>value(s)<br/></td>
    <td></td>
    <td></td>
  </tr>
</table>
</div>
      ]]></text>
    </subsection>
    <assignment title="More Parsing Algorithms and Interpreters">
      <instructions>
        <text><![CDATA[
In this assignment you will implement a full, working interpreter for a small imperative programming language. You must submit two Python source file named <code>hw2/parse.py</code> and <code>hw2/interpret.py</code>. Please follow the <a href="#A">gsubmit</a> directions and remember to put your files in the <code>hw2</code> directory.
        ]]></text>
        <paragraph><![CDATA[
Your solutions to each of the problem parts below will be graded on their correctness, concision, and mathematical legibility. The different problems and problem parts rely on the lecture notes and on each other; carefully consider whether you can use functions from the lecture notes, or functions you define in one part within subsequent parts.
        ]]></paragraph>
        <paragraph><![CDATA[
<b style="color:green;">A testing script with several test cases is available for download: <a href="hw2-tests.py"><code>hw2-tests.py</code></a>. Feel free to modify or extend it as you see fit.</b>
        ]]></paragraph>
      </instructions>
      <problems>
        <problem>
          <text><![CDATA[
In this problem you will implement a parser for a simple programming language. All the functions you define in this problem should appear in the file <code>parse.py</code>. You may adapt the techniques and/or code from <b><a href="#assignment1">Assignment #1</a></b> where appropriate to complete this problem. Recall that all parsers take a sequence of tokens (and possibly a flag) as their input, and return a tuple containing a parse tree and a sequence of remaining tokens.
          ]]></text>
          <parts>
            <part>
              <text hooks="math"><![CDATA[
Include in your code the parsers <code>variable()</code> and <code>number()</code> that can parse token sequences that conform to the following two productions. The functions should return a string or integer, respectively, <b>without wrapping the result in a dictionary</b>. If the first token in the token sequence supplied to a function does not correspond to the production, the function should return <code>None</code>.
\begin{eqnarray}
<i>variable</i> & ::= & <i>any alphanumeric string beginning with a lowercase alphabetical letter</i> \\
<i>number</i> & ::= & <i>any valid non-negative integer</i>
\end{eqnarray}
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
Implement a parser <code>formula()</code> that can parse token sequences that conform to the following production. You may need to perform left-recursion elimination on a production before you can implement a working parser. You should use the abstract syntax tree node labels <code>"Xor"</code>, <code>"Bool"</code>, <code>"Variable"</code>, <code>"True"</code>, and <code>"False"</code>. <b style="color:green;">If the token sequence is not in the language defined by the production, the function should return <code>None</code> (this will be tested, and is necessary to receive full credit).</b> Note that to complete this part, you will need to assume that a parser for <i>term</i> is already implemented (you will then implement it in the next part of the problem, immediately below).
\begin{eqnarray}
<i>formula</i> & ::= & <i>formula</i> <b>xor</b> <i>formula</i> \\
            & | & <b>bool (</b> <i>term</i> <b>)</b> \\
            & | & <i>variable</i> \\
            & | & <b>true</b> \\
            & | & <b>false</b>
\end{eqnarray}
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
Implement a parser <code>term()</code> that can parse token sequences that conform to the following productions. These productions ensure that the traditional order of operations for addition and multiplication is preserved in a parse tree. However, you may need to perform left-recursion elimination on a production before you can implement a working parser. You should use the abstract syntax tree node labels <code>"Add"</code>, <code>"Multiply"</code>, <code>"Int"</code>, <code>"Parens"</code>, <code>"Variable"</code>, and <code>"Number"</code>. <b style="color:green;">If the token sequence is not in the language defined by the production, the function should return <code>None</code> (this will be tested, and is necessary to receive full credit).</b>
\begin{eqnarray}
<i>term</i> & ::= & <i>factor</i> <b>+</b> <i>term</i> \\
            & | & <i>factor</i> \\
<i>factor</i> & ::= & <i>factor</i> <b>*</b> <i>factor</i> \\
            & | & <b>int (</b> <i>formula</i> <b>)</b> \\
            & | & <b>(</b> <i>term</i> <b>)</b> \\
            & | & <i>variable</i> \\
            & | & <i>number</i>
\end{eqnarray}
              ]]></text>
            </part>
            <part>
              <text hooks="math"><![CDATA[
Implement a parser <code>program()</code> that can parse token sequences that conform to the following production. You may want to implement a helper parser function <code>expression()</code>. You should use the abstract syntax tree node labels <code>"Print"</code>, <code>"Assign"</code>, <code>"If"</code>, <code>"While"</code>, and <code>"End"</code>. Note that the last choice in the production defining <i>program</i> is meaningful: it means that an empty token sequence is a valid program. The parse tree corresponding to an empty program should be <code>"End"</code>. <b style="color:green;">If the token sequence is not in the language defined by the production, the function should return <code>None</code> (this will be tested, and is necessary to receive full credit).</b>
\begin{eqnarray}
<i>program</i> & ::= & <b>print</b> <i>expression</i> <b>;</b> <i>program</i> \\
                 & | & <b>assign</b> <i>variable</i> <b>=</b> <i>expression</i> <b>;</b> <i>program</i>\\
                 & | & <b>if</b> <i>expression</i> <b>{</b> <i>program</i> <b>}</b> <i>program</i>\\
                 & | & <b>while</b> <i>expression</i> <b>{</b> <i>program</i> <b>}</b> <i>program</i>\\
                 & | & \\
<i>expression</i> & ::= & <i>formula</i> \\
                  & | & <i>term</i> \\
\end{eqnarray}
Recall that the last <i>program</i> subtree in each of the choices in the production defining <i>program</i> represents the <i>rest</i> of the program. For example, in the choice "<b>if</b> <i>expression</i> <b>{</b> <i>program</i> <b>}</b> <i>program</i>", the first <i>program</i> subtree is the body of the <b>if</b> statement, while the second <i>program</i> subtree is the rest of the program. For another example, the following is one possible program in this language:
              ]]></text>  
              <code hooks="Python">
if true {
  print true;
}
print false;
              </code>
            </part>
          </parts>
        </problem>
        <problem>
          <text><![CDATA[
In this problem you will implement an interpreter for a simple programming language. All the functions you define in this problem should appear in the file <code>interpret.py</code>. Your interpreter must conform to the operational semantics for this language, as presented in each of the problem parts below.
          ]]></text>
          <parts>
            <part>
              <text hooks="math"><![CDATA[
Implement a function <code>evalTerm(env, t)</code> that takes an environment <code>env</code> and a parse tree <code>t</code> as its two arguments. The function should return the value that corresponds to the evaluation of the parse tree <code>t</code>, as determined by the operational semantics below.
              ]]></text>
              <inferences hooks="math">
                <inference title="Term-Number">
                  <premises><![CDATA[]]></premises>
                  <conclusion><![CDATA[\Sigma, %n \Downarrow %n]]></conclusion>
                </inference>
                <inference title="Term-Variable">
                  <premises><![CDATA[\Sigma(%x) = %v]]></premises>
                  <conclusion><![CDATA[\Sigma, %x \Downarrow %v]]></conclusion>
                </inference>
                <inference title="Term-Parens">
                  <premises><![CDATA[\Sigma, %t \Downarrow %v]]></premises>
                  <conclusion><![CDATA[\Sigma, <b>(</b> %t <b>)</b> \Downarrow %v]]></conclusion>
                </inference>
                <inference title="Term-Int-True">
                  <premises><![CDATA[\Sigma, %f \Downarrow <b>true</b>]]></premises>
                  <conclusion><![CDATA[\Sigma, <b>int</b> <b>(</b> %f <b>)</b> \Downarrow 1]]></conclusion>
                </inference>
                <inference title="Term-Int-False">
                  <premises><![CDATA[\Sigma, %f \Downarrow <b>false</b>]]></premises>
                  <conclusion><![CDATA[\Sigma, <b>int</b> <b>(</b> %f <b>)</b> \Downarrow 0]]></conclusion>
                </inference>
                <inference title="Term-Add">
                  <premises><![CDATA[\Sigma, %t_1 \Downarrow %v_1 %~ %~ \Sigma, %t_2 \Downarrow %v_2]]></premises>
                  <conclusion><![CDATA[\Sigma, %t_1 <b>+</b> %t_2 \Downarrow %v_1 + %v_2]]></conclusion>
                </inference>
                <inference title="Term-Multiply">
                  <premises><![CDATA[\Sigma, %t_1 \Downarrow %v_1 %~ %~ \Sigma, %t_2 \Downarrow %v_2]]></premises>
                  <conclusion><![CDATA[\Sigma, %t_1 <b>*</b> %t_2 \Downarrow %v_1 \cdot %v_2]]></conclusion>
                </inference>
              </inferences>
            </part>
            <part>
              <text hooks="math"><![CDATA[
Implement a function <code>evalFormula(env, f)</code> that takes an environment <code>env</code> and a parse tree <code>f</code> as its two arguments. The function should return the value that corresponds to the evaluation of the parse tree <code>f</code>, as determined by the operational semantics below (let \oplus represent the logical exclusive or operation, which can be implemented with the Python built-in relational operator <code>!=</code>).
              ]]></text>
              <inferences hooks="math">
                <inference title="Formula-True">
                  <premises><![CDATA[]]></premises>
                  <conclusion><![CDATA[\Sigma, <b>true</b> \Downarrow <b>true</b>]]></conclusion>
                </inference>
                <inference title="Formula-False">
                  <premises><![CDATA[]]></premises>
                  <conclusion><![CDATA[\Sigma, <b>false</b> \Downarrow <b>false</b>]]></conclusion>
                </inference>
                <inference title="Formula-Variable">
                  <premises><![CDATA[\Sigma(%x) = %v]]></premises>
                  <conclusion><![CDATA[\Sigma, %x \Downarrow %v]]></conclusion>
                </inference>
                <inference title="Formula-Bool-True">
                  <premises><![CDATA[\Sigma, %t \Downarrow %v %~ %~ %v &ne; 0]]></premises>
                  <conclusion><![CDATA[\Sigma, <b>bool</b> <b>(</b> %t <b>)</b> \Downarrow <b>true</b>]]></conclusion>
                </inference>
                <inference title="Formula-Bool-False">
                  <premises><![CDATA[\Sigma, %t \Downarrow 0]]></premises>
                  <conclusion><![CDATA[\Sigma, <b>bool</b> <b>(</b> %t <b>)</b> \Downarrow <b>false</b>]]></conclusion>
                </inference>
                <inference title="Formula-Xor">
                  <premises><![CDATA[\Sigma, %f_1 \Downarrow %v_1 %~ %~ \Sigma, %f_2 \Downarrow %v_2]]></premises>
                  <conclusion><![CDATA[\Sigma, %f_1 <b>xor</b> %f_2 \Downarrow %v_1 \oplus %v_2]]></conclusion>
                </inference>
              </inferences>
            </part>
            <part>
              <text hooks="math"><![CDATA[
Implement a function <code>execProgram(env, s)</code> that takes an environment <code>env</code> and a parse tree <code>s</code> as its two arguments. The function should return a tuple containing the output (represented as a list of values) and an updated environment that represent the result of the execution of the program <code>s</code> as determined by the operational semantics below. Note that <b style="color:gray;">end ;</b> corresponds to the empty token sequence and is used as a placeholder to make the notation unambiguous. <b style="color:green;">You should <i>not</i> use the Python <code>while</code> control construct, or any other looping construct, anywhere in your implementation of the [Statement-While-*] cases; you will only receive credit if you use recursion as determined by the inference rules.</b>
              ]]></text>
              <inferences hooks="math">
                <inference title="Statement-Print">
                  <premises><![CDATA[\Sigma_1, %p \Downarrow \Sigma_2, %o %~ %~ \Sigma_1, %e \Downarrow %v]]></premises>
                  <conclusion><![CDATA[\Sigma_1, <b>print</b> %e <b>;</b> %p \Downarrow \Sigma_2, %v;%o]]></conclusion>
                </inference>
                <inference title="Statement-Assign">
                  <premises><![CDATA[\Sigma_1 \uplus {%x \mapsto %v}, %p \Downarrow \Sigma_2, %o %~ %~ \Sigma_1, %e \Downarrow %v]]></premises>
                  <conclusion><![CDATA[\Sigma_1, <b>assign</b> %x <b>=</b> %e <b>;</b> %p \Downarrow \Sigma_2, %o]]></conclusion>
                </inference>
                <inference title="Statement-If-False">
                  <premises><![CDATA[\Sigma_1, %p_2 \Downarrow \Sigma_2, %o_1 %~ %~ \Sigma_1, %e \Downarrow <b>false</b>]]></premises>
                  <conclusion><![CDATA[\Sigma_1, <b>if</b> %e <b>{</b> %p_1 <b>}</b> %p_2 \Downarrow \Sigma_2, %o_1]]></conclusion>
                </inference>
                <inference title="Statement-If-True">
                  <premises><![CDATA[\Sigma_1, %p_1 \Downarrow \Sigma_2, %o_1 %~ %~ \Sigma_2, %p_2 \Downarrow \Sigma_3, %o_2 %~ %~ \Sigma_1, %e \Downarrow <b>true</b>]]></premises>
                  <conclusion><![CDATA[\Sigma_1, <b>if</b> %e <b>{</b> %p_1 <b>}</b> %p_2 \Downarrow \Sigma_3, %o_1;%o_2]]></conclusion>
                </inference>
                <inference title="Statement-While-False">
                  <premises><![CDATA[\Sigma_1, %p_2 \Downarrow \Sigma_2, %o_1 %~ %~ \Sigma_1, %e \Downarrow <b>false</b>]]></premises>
                  <conclusion><![CDATA[\Sigma_1, <b>while</b> %e <b>{</b> %p_1 <b>}</b> %p_2 \Downarrow \Sigma_2, %o_1]]></conclusion>
                </inference>
                <inference title="Statement-While-True">
                  <premises><![CDATA[
                    \Sigma_1, %p_1 \Downarrow \Sigma_2, %o_1 %~ %~ \Sigma_2, <b>while</b> %e <b>{</b> %p_1 <b>}</b> %p_2 \Downarrow \Sigma_3, %o_2 %~ %~ \Sigma_1, %e \Downarrow <b>true</b>
                  ]]></premises>
                  <conclusion><![CDATA[\Sigma_1, <b>while</b> %e <b>{</b> %p_1 <b>}</b> %p_2 \Downarrow \Sigma_3, %o_1;%o_2]]></conclusion>
                </inference>
                <inference title="Statement-End">
                  <premises><![CDATA[]]></premises>
                  <conclusion><![CDATA[\Sigma, <b style="color:gray;">end ;</b> \Downarrow \Sigma, %o_0]]></conclusion>
                </inference>
              </inferences>
            </part>
            <part>
              <text hooks="math"><![CDATA[
Implement a function <code>interpret()</code> that takes a single string as its argument. The function should tokenize the string and parse it to generate a parse tree. If parsing fails, it should return <code>None</code>; otherwise, it should execute the parse tree to obtain an <i><a href="#db57dc0684174cd097ebf73d733dc9bc">output</a></i>. It should then return the output. <b style="color:green;">Your implementation only needs to interpret entire programs; you do not need to interpret stand-alone terms or formulas.</b>
              ]]></text>
            </part>
          </parts>
        </problem>
        <problem>
          <text><![CDATA[
<b>Extra credit:</b> Add the choices <b>(</b> <i>term</i> <b>=</b> <i>term</i> <b>)</b>, <b>(</b> <i>term</i> <b>&lt;</b> <i>term</i> <b>)</b> and <b>(</b> <i>term</i> <b>&gt;</b> <i>term</i> <b>)</b> to the <i>formula</i> production rule in the language, and extend the parsing and evaluation algorithms accordingly (you can use <code>Compare</code>, <code>LessThan</code>, and <code>GreaterThan</code> for the tree node labels).
          ]]></text>
        </problem>
      </problems>
    </assignment>
  </section>
  <section title="Compilation">
    <text><![CDATA[
Compilation involves translating or transforming one programming language (sometimes called the <i>source</i> language) into another (often called the <i>target</i> language). It is often the case that the target language is a more "low-level" language that more closely corresponds to the capabilities of a physical (i.e., electronic) device, such as the central processor (CPU), memory, and other devices that constitute a modern computer. However, today, compilation could also refer to any transformation from one programming language to another. For example, it might be necessary to compile PHP to ASP, which are both server-side web application scripting languages, in order to migrate software from one operating system to another.
    ]]></text>
    <subsection title="History, background, and context">
      <text><![CDATA[
One way to summarize a very thin slice of the history of general-purpose computers and their relationship with programming languages is to consider how the increasingly complex structure of a computer both enabled and required increasingly abstract programming languages and programming language features.
<br/><br/>
The three major categories of concept involved are the program, the computing device, and the physical laws upon which the computing device is based. As long as the physical laws being used are predictable (i.e., consistent across time and space), we can build computing devices that behave the same way even if they are operated in different places or at different times. We can then interpret what that device does in some meaningful way (e.g., as arithmetic operations). To perform different kinds of tasks using the device, we would need some kind of way to change its initial configuration (i.e., to "program" it).
<div class="diagram">
<table class="container">
  <tr><td class="box" style="background-color:lightyellow;">program (e.g., input/configuration, instructions, etc.)</td></tr>
  <tr><td class="box" style="background-color:orange;">computing device (e.g., difference engine, modern CPU, quantum computer, etc.)</td></tr>
  <tr><td class="box" style="background-color:powderblue;">physical laws (mechanics, electricity, chemistry, biology, quantum mechanics, etc.)</td></tr>
</table>
</div>
Until the 1940s, all artifacts that could be considered computing devices (e.g., an abacus, <a href="http://en.wikipedia.org/wiki/Difference_engine">Babbage's difference engine</a>, etc.) were single-purpose machines that could only perform the same operation (but possibly on different inputs, which corresponded to different initial configurations of the device). In the early 1940s, a number of computers were built (such as the <a href="http://en.wikipedia.org/wiki/ENIAC">ENIAC</a> and <a href="http://en.wikipedia.org/wiki/Colossus_computer">Colossus</a>) that could be physically reconfigured to perform different operations. Arguably, the "program" was the machine's physical configuration. In the late 1940s, computers were developed (or improved, as in the case of ENIAC) that could operate according to a program stored in a memory device. At this point, both the program and the input were stored in a single, unified memory component; the program told the central processing unit (CPU) what operations to perform, and what modifications to make to memory. This characteristic is part of what's known as the <a href="http://en.wikipedia.org/wiki/Von_Neumann_architecture">Von Neumann architecture</a>.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:#EEEEEE;">memory
      <table class="container">
        <tr>
          <td class="box" style="background-color:lightyellow;">input</td>
          <td class="box" style="background-color:lightyellow;">program</td>
        </tr>
      </table>
    </td>
  </tr>
  <tr><td class="box" style="background-color:orange;">central processing unit (CPU)</td></tr>
</table>
</div>
Subsequent improvements to computing device components in the 1950s and onward primarily served to make the components smaller, cheaper, faster, and more reliable while still conforming to the Von Neumann architecture. However, the programs controlling these devices continued to become more and more sophisticated.
<br/><br/>
Machine languages were developed in the 1940s (particularly in the very late 1940s) and the 1950s. These consisted of small collections of instructions that corresponded to operations that could be performed by the CPU. A program was then a list of machine language instructions, and the abstraction this supplied to the programmer was that of a block of memory indexed by an integer range, and a single processor that could perform a sequence of operations on memory. The diagram below provides a stylized depiction of the view from a user's or programmer's perspective.
<div class="diagram">
<table class="container">
  <tr><td class="box" style="background-color:lightyellow;">machine program</td></tr>
  <tr><td class="box" style="background-color:#ECECEC;">machine languauge</td></tr>
  <tr>
    <td class="box" style="background-color:#CCCCCC;">
      <table class="container">
        <tr>
          <td class="box" style="background-color:orange;">CPU</td>
          <td class="box" style="background-color:orange;">memory</td>
        </tr>
      </table>
      hardware
    </td>
  </tr>
</table>
</div>
In part because using machine languages to specify the desired behavior of computers was time-consuming and error-prone, more human-friendly and legible languages were developed in the mid and late 1950s, such as FORTRAN, LISP, and COBOL. These programs were mechanically transformed into machine language programs using a compiler, which was itself a program. For example, after a human wrote a FORTRAN program, it could be compiled once into a machine language program by running the compiler once. The machine language program this produced could then be run any number of times or copied and reused later.
<div class="diagram">
<table class="container">
  <tr><td class="box" style="background-color:#ECECEC;">FORTRAN program</td></tr>
  <tr><td class="box" style="background-color:#ECECEC;">FORTRAN compiler</td></tr>
  <tr><td class="box" style="background-color:lightyellow;">machine program</td></tr>
  <tr><td class="box" style="background-color:#ECECEC;">machine languauge</td></tr>
  <tr>
    <td class="box" style="background-color:#CCCCCC;">
      <table class="container">
        <tr>
          <td class="box" style="background-color:orange;">CPU</td>
          <td class="box" style="background-color:orange;">memory</td>
        </tr>
      </table>
      hardware
    </td>
  </tr>
</table>
</div>
Special-purpose applications could be written using either a machine language or a high-level language.
<div class="diagram">
<table class="container">
  <tr><td class="box" style="background-color:lightyellow;">application</td></tr>
  <tr><td class="box" style="background-color:#ECECEC;">high-level program</td></tr>
  <tr><td class="box" style="background-color:#ECECEC;">compiler</td></tr>
  <tr><td class="box" style="background-color:lightyellow;">machine program</td></tr>
  <tr><td class="box" style="background-color:#ECECEC;">machine languauge</td></tr>
  <tr>
    <td class="box" style="background-color:#CCCCCC;">
      <table class="container">
        <tr>
          <td class="box" style="background-color:orange;">CPU</td>
          <td class="box" style="background-color:orange;">memory</td>
        </tr>
      </table>
      hardware
    </td>
  </tr>
</table>
</div>
Once it became possible for non-experts and multiple users to use a computer with a variety of different components beyond the memory and CPU (due to advances in many areas, including reductions in cost and the availability of better interface devices and special-purpose components), operating systems were developed to make it possible to manage multiple applications that might run by different users and might employ different components. However, all the applications would need to be either written using a machine language, or written in a language that could be compiled into a machine language. The operating system would then manage how these machine programs could use the various components and resources available to the computer (including the resource of time).
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" colspan="2" style="background-color:#EEEEEE;">
      user A
      <table class="container">
        <tr>
          <td class="box" style="background-color:lightyellow;">application</td>
          <td class="box" style="background-color:lightyellow;">application</td>
        </tr>
      </table>
    </td>
    <td class="box" colspan="2" style="background-color:#EEEEEE;">
      user B
      <table class="container">
        <tr>
          <td class="box" style="background-color:lightyellow;">application</td>
          <td class="box" style="background-color:lightyellow;">application</td>
        </tr>
      </table>
    </td>
  </tr>
  <tr>
    <td class="box" style="background-color:#EEEEEE;">high-level<br/>program</td>
    <td class="box" style="background-color:#EEEEEE;">high-level<br/>program</td>
    <td class="box" style="background-color:#EEEEEE;">high-level<br/>program</td>
    <td class="box" style="background-color:#EEEEEE;">high-level<br/>program</td>
  </tr>
  <tr><td class="box" colspan="4" style="background-color:#ECECEC;">compiler</td></tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">machine<br/>program</td>
    <td class="box" style="background-color:lightyellow;">machine<br/>program</td>
    <td class="box" style="background-color:lightyellow;">machine<br/>program</td>
    <td class="box" style="background-color:lightyellow;">machine<br/>program</td>
  </tr>
  <tr><td class="box" colspan="4" style="background-color:#ECECEC;">machine languauge</td></tr>
  <tr><td class="box" colspan="4" style="background-color:lightyellow;">operating system</td></tr>
  <tr>
    <td class="box" colspan="4" style="background-color:#CCCCCC;">
      <table class="container">
        <tr>
          <td class="box" style="background-color:orange;">CPU</td>
          <td class="box" style="background-color:orange;">CPU</td>
          <td class="box" style="background-color:orange;">CPU</td>
          <td class="box" style="background-color:orange;">memory</td>
          <td class="box" style="background-color:orange;">input device</td>
          <td class="box" style="background-color:orange;">output device</td>
          <td class="box" style="background-color:orange;">other device</td>
        </tr>
      </table>
      hardware
    </td>
  </tr>
</table>
</div>
One could collapse this into a relatively simple diagram by omitting the portions of the diagram that do not represent components that either appear to be running to the user, or are actually running on the device.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:lightyellow;">application</td>
    <td class="box" style="background-color:lightyellow;">application</td>
    <td class="box" style="background-color:lightyellow;">application</td>
    <td class="box" style="background-color:lightyellow;">application</td>
  </tr>
  <tr><td class="box" colspan="4" style="background-color:lightyellow;">operating system</td></tr>
  <tr><td class="box" colspan="4" style="background-color:#CCCCCC;">hardware</td></tr>
</table>
</div>
The above diagram might represent a single computer in a single physical location running a single operating system and a few applications. Today, this picture is much more complicated. While many devices are still captured by the above diagram, in many other cases the actual abstractions provided are much more rich and diverse, and they reflect the diverse ecosystem of capabilities and components available to a user, programmer, or application.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" colspan="10" style="background-color:lightyellow;">app.</td>
    <td class="box" style="background-color:lightyellow;">app.</td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td class="box" colspan="11" style="background-color:lightyellow;">web app. platform</td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td class="box" colspan="11" style="background-color:lightyellow;">browser</td>
    <td class="box" style="background-color:lightyellow;">app.</td>
    <td class="box" colspan="3" style="background-color:lightyellow;">app.</td>
  </tr>
  <tr>
    <td class="box" colspan="8" style="background-color:lightyellow;">API</td>
    <td class="box" style="background-color:lightyellow;">API</td>
    <td class="box" colspan="3" style="background-color:lightyellow;">OS</td>
    <td class="box" colspan="3" style="background-color:lightyellow;">OS</td>
  </tr>
  <tr>
    <td class="box" colspan="8" style="background-color:lightyellow;">web service</td>
    <td class="box" style="background-color:lightyellow;">web service</td>
    <td class="box" colspan="3" style="background-color:lightyellow;">virtual machine</td>
    <td class="box" colspan="3" style="background-color:lightyellow;">virtual machine</td>
  </tr>
  <tr>
    <td class="box" colspan="8" style="background-color:lightyellow;">dist. platform</td>
    <td class="box" style="background-color:lightyellow;">web server</td>
    <td class="box" colspan="6" style="background-color:lightyellow;">virtualization layer</td></tr>
  <tr>
    <td class="box" colspan="3" style="background-color:lightyellow;">controller</td>
    <td class="box" colspan="5" style="background-color:lightyellow;">controller</td>
    <td class="box" style="background-color:lightyellow;">OS</td>
    <td class="box" colspan="6" style="background-color:lightyellow;">host operating system</td>
  </tr>
  <tr>
    <td class="box" style="background-color:#CCCCCC; font-size:8px;">node</td>
    <td class="box" style="background-color:#CCCCCC; font-size:8px;">node</td>
    <td class="box" style="background-color:#CCCCCC; font-size:8px;">node</td>
    <td class="box" style="background-color:#CCCCCC; font-size:8px;">node</td>
    <td class="box" style="background-color:#CCCCCC; font-size:8px;">node</td>
    <td class="box" style="background-color:#CCCCCC; font-size:8px;">node</td>
    <td class="box" style="background-color:#CCCCCC; font-size:8px;">node</td>
    <td class="box" style="background-color:#CCCCCC; font-size:8px;">node</td>
    <td class="box" style="background-color:#CCCCCC;">server</td>
    <td class="box" colspan="6" style="background-color:#CCCCCC;">hardware (web/cloud server)</td>
  </tr>
</table>
</div>
Today, the picture is much more complicated. Many applications running on a device actually provide capabilities that are assembled from a collection of underlying layers of potentially interdependent components. Every component in every layer must provide an interface and a collection of abstractions that capture its capabilities and communicate them to users (and expose them to the components on the layers above). Effectively, every component in every layer has a programming language, and assembling multilayered applications may require many compilation steps at various layers.
      ]]></text>
    </subsection>
    <subsection title="Transformations between abstract syntaxes">
      <definition required="true" hooks="math" id="dfe2befbecb0490b8983a5bc51697a09"><![CDATA[
Given two abstract syntaxes %A and %B (i.e., both %A and %B are sets of parse trees that conform to two distinct grammars), an algorithm that <i>always terminates</i> and maps parse trees in %A to parse trees in %B is called a <i>compilation algorithm</i>, and it is said to <i>compile</i> programs in the language corresponding to %A into programs in the language corresponding to %B. Note that while a compiler must always terminate on all inputs, it is allowed to return an error on some inputs.
      ]]></definition>
    <text hooks="math"><![CDATA[
Note the similarities and distinctions between an interpreter and a compiler. Both interpreters and compilers map some set of abstract syntax trees to some other set of abstract syntax trees (in the case of interpreters, the resulting abstract syntax trees are usually <i>values</i> that are simpler than programs). However, an interpreter might not terminate (e.g., if the program it is interpreting does not terminate when it is evaluated and/or executed), while a compiler must terminate. Furthermore, an interpreter must keep track of both values and side effects (such as output), while a compiler is simply transforming one program into another program without concerning itself with what the program might do when evaluated/executed.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">source language<br/>abstract syntax</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">compiler</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">target language<br/>abstract syntax</td>
  </tr>
</table>
</div>
Often, the term <i>compiler</i> will refer to the entire toolchain of components that make it possible to convert the character string (i.e., concrete syntax) representation of a program in the source language into the concrete syntax representation of the program in the target language. In these cases, we will refer to the individual component that performs compilation as the <i>compilation algorithm</i> or <i>compilation component</i>.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">source language<br/>concrete syntax</td>
    <td></td>
    <td></td>
    <td></td>
    <td class="box" style="background-color:powderblue;">libraries</td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&#8659;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td><span style="font-size:20px;">&#8659;</span></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">parser</td>
    <td></td>
    <td></td>
    <td></td>
    <td class="box" style="background-color:lightyellow;">linker</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">target language<br/>concrete syntax</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&#8659;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td><span style="font-size:20px;">&#8657;</span></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td class="box" style="background-color:powderblue;">source language<br/>abstract syntax</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">compilation<br/>algorithm</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">target language<br/>abstract syntax</td>
    <td></td>
    <td></td>
  </tr>
</table>
</div>
Furthermore, a compilation algorithm will often consist of multiple stages. Each stage may perform some specific task, such as simplifying the features used in a program (e.g., eliminating procedures and replacing them with labels and branching statements, or eliminating variable names and replacing them with explicit memory addresses), or it may perform optimizations (e.g., elimination of unreachable code blocks). The <i>intermediate representation</i> (IR) between each stage might be a distinct abstract syntax data structure.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">source<br/>language<br/>abstract<br/>syntax</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">comp.<br/>alg. A</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">IR<br/>#1</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">comp.<br/>alg. B</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">IR<br/>#2</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">comp.<br/>alg. C</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">target<br/>language<br/>abstract<br/>syntax</td>
  </tr>
</table>
</div>
    ]]></text>
    </subsection>
    <subsection title="Machine languages and bytecodes">
      <definition required="true" hooks="math" id="a3c0158e667c47a8b3b73cf929ebc7af"><![CDATA[
Given a model of a computer that consists of a single central processing unit (CPU) that can perform some basic operations, and a block of memory (accessible to the CPU) that is organized using some kind of sequential and/or hierarchical addressing scheme (e.g., positive integers in some range represent memory locations), a <i>machine language</i>, <i>assembly language</i>, or <i>machine code</i> is an imperative programming language that consists of instructions that can directly be executed by a single CPU.
      ]]></definition>
      <text><![CDATA[
Note that in modern systems and networks, machine code might not be executed by a CPU directly. Instead, a program might be running on an operating system that might itself be running on a virtual machine, which is being simulated by a program that runs on a physical computer but emulates the behavior of a (perhaps very different) CPU and memory.
      ]]></text>
      <definition required="true" hooks="math" id="91ebfabbdd9f42e7bfd579be18a6d52a"><![CDATA[
A <i>bytecode</i> is a low-level programming language that is similar to a machine language (i.e., the instructions in the language are primarily for manipulating memory and performing basic arithmetic and logical operations) but is not platform-dependent (i.e., dependent on a particular CPU model), and itself needs to be either interpreted (e.g., by a run-time system or virtual machine) or compiled into a machine language.
      ]]></definition>
      <text><![CDATA[
Note that there is a distinction between machine code and bytecode, though this distinction is increasingly harder to discern in practice with the advent of widespread virtualization. Usually, machine code is said to be <i>executed</i> when it is run on its native CPU, and <i>simulated</i> if it is being executed by some software application that emulates the behavior of a CPU; bytecode is typically executed by an interpreter, which might be called a <i>run-time system</i> or a <i>virtual machine</i> (depending on the features and capabilities of the interpreter, some of which will be discussed in more detail in subsequent sections). Examples of bytecodes include the Java bytecode (interpreted by the Java Virtual Machine, or JVM) and the Python bytecode.
      ]]></text>
      <example required="true" id="3ee4c63a96db4254ba2b6ad0ee4e29a2">
        <text hooks="math"><![CDATA[
Consider the following target language, which has many characteristics of a machine language or bytecode. A program consists of an ordered sequence of instructions that can manipulate a block of memory addresses.
\begin{eqnarray}
<i>program</i> & ::= & <i>instruction</i> <i>program</i> \\
              & | & \\
<i>instruction</i> & ::= & <b>label</b> <i>label</i> \\
                   & | & <b>branch</b> <i>label</i> <i>address</i> \\
                   & | & <b>branch</b> <i>label</i> \\
                   & | & <b>set</b> <i>address</i> <i>number</i> \\
                   & | & <b>copy</b> <i>address</i> <i>address</i> \\
                   & | & <b>add</b> \\
<i>label</i> & ::= & <i>any valid label</i> \\
<i>address</i> & ::= & <i>any positive integer or zero</i> \\
<i>number</i> & ::= & <i>any positive integer or zero</i>
\end{eqnarray}
We can implement a simple Python simulator (or virtual machine, if the above is a bytecode) for this language.
        ]]></text>
        <code hooks="Python"><![CDATA[
# Simulate a machine running the program represented by the string s.
@def simulate(s):
    instructions = [l.split(" ") @for l @in s.split("\n")]
    mem = {0: 0}
    control = 0
    @while control < @len(instructions):
        inst = instructions[control]
        @if inst[0] == 'label':
            @pass
        # For two arguments, test the memory address in the second
        # argument; given one argument, branch unconditionally.
        @if inst[0] == 'branch':
            @if @len(inst) == 2 @or mem[@int(inst[2])] != 0:
                control = instructions.index(['label', inst[1]])
                @continue
        @if inst[0] == 'set':
            mem[@int(inst[1])] = @int(inst[2])
        @if inst[0] == 'copy':
            mem[@int(inst[2])] = mem[@int(inst[1])]
        @if inst[0] == 'add':
            mem[0] = mem[1] + mem[2]
        control = control + 1
    @return mem[0]
        ]]></code>
        <text hooks="math"><![CDATA[
A program in this language might look as follows:
        ]]></text>
        <code hooks="Python"><![CDATA[
>>> p = '''
  label start
  set 1 2
  set 2 3
  branch skip 1
  set 2 40
  label skip
  add
  '''
>>> simulate(p)
5
        ]]></code>        
      </example>
      <example required="true" id="3246043602d540668dc63d5b6277a47f">
        <text hooks="math"><![CDATA[
In this example, the target language will be a slightly more complex machine language than the one presented in <a href="3ee4c63a96db4254ba2b6ad0ee4e29a2">a previous example</a>. A program consists of an ordered sequence of instructions that can manipulate a block of memory addresses. The abstract syntax for the language is presented below.
\begin{eqnarray}
<i>program</i> & ::= & <i>instruction</i> <i>program</i> \\
              & | & \\
<i>instruction</i> & ::= & <b>label</b> <i>label</i> \\
                   & | & <b>goto</b> <i>label</i> \\
                   & | & <b>branch</b> <i>label</i> <i>address</i> \\
                   & | & <b>jump</b> <i>address</i> \\
                   & | & <b>set</b> <i>address</i> <i>number</i> \\
                   & | & <b>copy</b> \\
                   & | & <b>add</b> \\
<i>label</i> & ::= & <i>any alphanumeric character string</i> \\
<i>address</i> & ::= & <i>any integer</i> \\
<i>number</i> & ::= & <i>any integer</i>
\end{eqnarray}
When a machine is running a program, the state of the machine consists of a single block of memory (indexed by integers: both negative and positive) and a single integer representing the machine's position in the sequence of instructions (this integer represents which instruction in the program currently has <i>control</i>, i.e., which instruction is being executed by the CPU). The memory has eight special memory locations, which are defined below:
<ul>
  <li><b>memory address 0:</b> the address of the result of an <b>add</b> operation;</li>
  <li><b>memory address 1:</b> the address of the first input to an <b>add</b> operation;</li>
  <li><b>memory address 2:</b> the address of the second input to an <b>add</b> operation;</li>
  <li><b>memory address 3:</b> the address containing the "from" address for a <b>copy</b> operation;</li>
  <li><b>memory address 4:</b> the address containing the "to" address for a <b>copy</b> operation;</li>
  <li><b>memory address 5:</b> the output buffer (set to %-1 after every step);</li>
  <li><b>memory address 6:</b> the address of the program's control index.</li>
</ul>
The meaning of each instruction is described below:
<ul>
  <li><b>label %l:</b> there is no effect and control is passed to the next instruction;</li>
  <li><b>goto %l:</b> control immediately moves to the program instruction <b>label</b> %l;</li>
  <li><b>branch %l %a:</b> control immediately moves to the program instruction <b>label</b> %l if memory address %a contain a non-zero integer;</li>
  <li><b>jump %a:</b> if the integer %i is stored in memory address %a, control moves immediately to the %ith instruction in the program;</li>
  <li><b>set %a %n:</b> memory address %a is set to the integer %n;</li>
  <li><b>copy:</b> if %a is the integer stored in memory address 3, and %b is the integer stored in memory address 4, then the contents of memory address %a are copied to memory address %b;</li>
  <li><b>add:</b> the contents of memory location 1 and memory location 2 are added and stored in memory location 0.</li>
</ul>
We can implement a simple <a href="hw3/machine.py">Python simulator</a> for this language.
<br/><br/>
As an example of how this language might be used, suppose we want to write a program in this language to copy the contents of memory address 10 to memory address 20. The machine language program presented below would have this behavior:
        ]]></text>   
        <code hooks="Python"><![CDATA[
set 3 10
set 4 20
copy
        ]]></code>
        <text hooks="math"><![CDATA[
In fact, we can write a Python program that can generate an instance of the above for any two addresses. Notice that the <code>copy()</code> function below can be viewed as a macro that generates a specific machine language program.
        ]]></text>
        <code hooks="Python"><![CDATA[
@def copy(frm, to):
   @return [\
      'set 3 ' + @str(frm),\
      'set 4 ' + @str(to),\
      'copy'\
   ]
        ]]></code>
        <text hooks="math"><![CDATA[
Suppose we have another macro <code>increment()</code> that takes a single argument, a memory address, and generates a machine program that increments the value at the address specified memory address. We could then implement the following macro, which will set an entire region of memory to a particular constant.
        ]]></text>
        <code hooks="Python"><![CDATA[
@def setAllToInRegion(constant, startAddr, endAddr):
  # Memory location 8 contains the constant.
  # Memory location 9 contains the counter.  
  @return [\
        'set 8 ' + @str(constant),\
        'set 9 ' + @str(startAddr),\
        'label loop'\
      ] \
      # Set second argument (destination) of copy.
      + copy(9,4)\
      + [\
        # Set first argument (source) for copy.
        'set 3 8',\
        'copy'\
      ]\
      # Increment the counter.
      + increment(9) \
      # If counter is endAddr, break out of loop;
      # otherwise, go back to the beginning of the loop.
      # We check by adding -endAddr to the counter.
      # First argument of add.
      + copy(9,1) \
      + [\
        # Second argument of add.
        'set 2 -' + @str(endAddr),\
        'add',\
        'branch loop 0'\
      ]
        ]]></code>
        <text hooks="math"><![CDATA[
Running <code>setAllToInRegion()</code> on specific inputs generates a machine language program for a particular region.
        ]]></text>
        <code hooks="Python"><![CDATA[
>>> setAllToInRegion(3, 10, 100)
['set 8 3', 
 'set 9 10', 
 'label loop', 
 'set 3 9', 
 'set 4 4', 
 'copy', 
 'set 3 8', 
 'copy', 
 '# increment() done as homework.',
 'set 3 9', 
 'set 4 1', 
 'copy', 
 'set 2 -100', 
 'add', 
 'branch loop 0']
        ]]></code>
      </example>      
    </subsection>
    <subsection title="Compiling expressions to a machine language or bytecode">
      <text hooks="math"><![CDATA[
In order to compile a high-level language to a machine language that only provides the CPU and indexed memory abstractions, it is necessary to transform the high-level language's parse tree into a series of instructions that manipulate memory in a way that appears identical to the behavior of the high-level program when it is being interpreted.
<br/><br/>
Since machine language programs describe how to manipulate memory, it is a good idea to plan how the machine program will utilize the memory available to it to store intermediate results it needs to compute while the program is running.
      ]]></text>
      <definition required="true" hooks="math" id="f7d602562fe211e38cf6ce3f5508acd9">
        <text hooks="math"><![CDATA[
The region of memory that a machine program uses to store values (i.e., results of computing expressions) is called the <i>heap</i>.
        ]]></text>
        <paragraph hooks="math"><![CDATA[
As a machine program continues running and computing more results, it <i>grows</i> the heap by adding values to new memory locations. To keep track of this at the time of compilation, the compiler might maintain a counter that stores the current "top" of the heap. When a machine program is running, it may itself maintain a <i>heap pointer</i> to keep track of the last item stored on the heap, primarily so that it knows where to look for more space if it wants to store more values in memory.
        ]]></paragraph>
      </definition>
      <example required="true" id="f288b6e6a04d45e58feb24c6f72de96a">
        <text hooks="math"><![CDATA[
Suppose we are starting with the following source language:
\begin{eqnarray}
<i>formula</i> & ::= & <b>true</b> | <b>false</b> | <b>not</b> <i>formula</i> | <i>formula</i> <b>and</b> <i>formula</i> | <i>formula</i> <b>or</b> <i>formula</i>
\end{eqnarray}
How can we implement a compiler that converts formulas in the source language into sequences of instructions in the target language in the <a href="#3ee4c63a96db4254ba2b6ad0ee4e29a2">previous example</a>?
<br/><br/>
We can approach this problem by constructing a function <code>compileFormula()</code> that takes as its input the parse tree, and a variable <code>heap</code> that represents the highest address in memory that contains a computed value (in our case, <code>1</code> can represent <b>true</b> and <code>0</code> can represent <b>false</b>). The function returns a list of machine language instructions that computes that value, as well as the memory address where that value would be stored if anyone actually executed (or simulated) the machine language program.
        ]]></text>       
        <code hooks="Python"><![CDATA[
@def compileFormula(f, heap = 3, fresh = 0):
    @if @type(f) == Leaf:
        @if f == 'True':
            # Find a new memory address on the heap.
            heap = heap + 1
            # Generate instruction to store the integer representing 'True' on the heap.
            inst = 'set ' + @str(heap) + ' 1'
            # Return the instruction list and "top" of the heap.
            @return ([inst], heap, fresh)
        @if f == 'False':
            # Find a new memory address on the heap.
            heap = heap + 1
            # Generate instruction to store the integer representing 'False' on the heap.
            inst = 'set ' + @str(heap) + ' 0'
            # Return the instruction list and "top" of the heap.
            @return ([inst], heap, fresh)
    @if type(f) == Node:
        @for label @in f:
            children = f[label]
            if label == 'Not':
                # Compile the subtree f to obtain the list of
                # instructions that computes the value represented
                # by f.
                f = children[0]
                (insts, heap, fresh) = compileFormula(f, heap, fresh)
                # Generate more instructions to change the memory
                # location in accordance with the definition of the
                # 'Not' operation.
                instsNot = \
                   ["branch setZero" + str(fresh) + " " + @str(heap),\
                    "set " + @str(heap) + " 1",\
                    "branch finish" + @str(fresh),\
                    "label setZero" + @str(fresh),\
                    "set " + @str(heap) + " 0",\
                    "label finish" + @str(fresh)\
                   ]
                @return (insts + instsNot, heap, fresh + 1)
            @if label == 'Or':
                # Compile the two subtrees and get the instructions
                # lists as well as the addresses in which the results
                # of computing the two subtrees would be stored if someone
                # were to run those machine instructions.
                f1 = children[0]
                f2 = children[1]
                (insts1, heap2, fresh1) = compileFormula(f1, heap, fresh)
                (insts2, heap3, fresh2) = compileFormula(f2, heap2, fresh1)
                # Increment the heap counter so we store the
                # result of computing 'Or' in a new location.
                heap4 = heap3 + 1
                # Add instructions that compute the result of the
                # 'Or' operation.
                instsOr = \
                   ["copy " + @str(heap2) + " 1",\
                    "copy " + @str(heap3) + " 2",\
                    "add",\
                    "branch setOne" + @str(fresh2) + " 0",\
                    "branch finish" + @str(fresh2),\
                    "label setOne" + @str(fresh2),\
                    "set 0 1",\
                    "label finish" + @str(fresh2),\
                    "copy 0 " + @str(heap4)\
                   ]
                @return (insts1 + insts2 + instsOr, heap4, fresh2 + 1)
        ]]></code>
      </example>
    </subsection>
    <subsection title="Compiling statement sequences and procedures to a machine language or bytecode">
      <definition required="true" hooks="math" id="f7d604542fe211e38cf6ce3f5508acd9">
        <text hooks="math"><![CDATA[
The region of memory that a machine program uses to store information that makes it possible to simulate calls to named procedures is called the <i>stack</i>.
        ]]></text>
        <paragraph hooks="math"><![CDATA[
In its simplest form, the stack is simply a region of memory that holds integers corresponding to program locations. The top of the stack always corresponds to the program location to which control must move once the procedure that is currently being executed (or simulated) reaches the end of its body.
        ]]></paragraph>
      </definition>
      <example required="true" id="f7d618222fe211e38cf6ce3f5508acd9">
        <text hooks="math"><![CDATA[
Suppose we are starting with the following source language:
\begin{eqnarray}
<i>program</i> & ::= & <i>variable</i> <b>:=</b> <i>formula</i> <b>;</b> <i>program</i> \\
               & | & <b>print</b> <i>formula</i> <b>;</b> <i>program</i> \\
               & | & <b>procedure</b> <i>variable</i> <b>{</b> <i>program</i> <b>}</b> <i>program</i>  \\
               & | & <b>call</b> <i>variable</i> <b>;</b> <i>program</i>  \\
               & | & \\
<i>formula</i> & ::= & <b>true</b> | <b>false</b> | <i>variable</i> | <b>not</b> <i>formula</i> | <i>formula</i> <b>and</b> <i>formula</i> | <i>formula</i> <b>or</b> <i>formula</i>
\end{eqnarray}
How can we implement a compiler that converts formulas in the source language into sequences of instructions in the target language in a <a href="#3246043602d540668dc63d5b6277a47f">previous example</a>?
        ]]></text>
        <paragraph hooks="math"><![CDATA[
As an example, suppose we begin with the following program.
        ]]></paragraph>
        <code hooks="Python"><![CDATA[
procedure printProc {
  print true;
  print false;
}
call printProc;
print false;
call printProc;
print true;
        ]]></code>
        <text hooks="math"><![CDATA[
If we want to compile the above program, we will need to ensure that the machine language program passes control to the block of machine code representing the procedure body, and then passes it back when the body finishes running.
        ]]></text>
        <paragraph hooks="math"><![CDATA[
However, we must compile the procedure into a <i>single</i> block of machine code. How will that block know whether to come back to the point in the machine language program corresponding to the first <code>call printProc;</code> statement, or to the point corresponding to the second <code>call printProc;</code> statement?
        ]]></paragraph>
        <paragraph hooks="math"><![CDATA[
We will need to make sure that the <code>call printProc;</code> are compiled into machine code that stores the index of the current instruction at each call point at a particular memory location (in this example, suppose it is memory address <code>7</code>). Then, the block of machine code into which the procedure body is compiled can always consult the same memory location to determine to which point it should pass control back after the machine code for the procedure body finishes executing. Because control should not go back to the <b>goto</b> instruction but beyond it, it may be necessary to increment the value representing the program location before using the <b>jump</b> instruction. We provide machine language pseudocode below that does just that.
        ]]></paragraph>
        <code hooks="Python"><![CDATA[
# The procedure.
goto printProcEnd   # Skip procedure body.
label printProc
set 5 1             # print true;
set 5 0             # print false;

# Return control to the last calling point.
< increment integer stored in address 7 by 2 >
jump 7
label printProcEnd

# The first call.
< copy integer from address 6 to address 7 >
goto printProc

set 5 0             # print false;

# The second call.
< copy integer from address 6 to address 7 >
goto printProc

set 5 1             # print true;
        ]]></code>
        <paragraph hooks="math"><![CDATA[
The above approach might work if we never call a procedure from inside another procedure. However, it will not work if a <b>call</b> instruction appears inside the body of a procedure because that <b>call</b> instruction will be compiled into machine language instructions that overwrite the contents of memory address <code>7</code>, making it impossible to determine the program location to which control must return after the outermost procedure body finishes. To address this, it is possible to have the machine language program maintain a <a href="f7d604542fe211e38cf6ce3f5508acd9"><i>stack</i></a> starting at memory location <code>7</code> that will keep track of all the program locations to which control must return after each nested procedure call finishes. We do so in the machine language pseudocode below.
        ]]></paragraph> 
        <code hooks="Python"><![CDATA[
# Set stack pointer to top of stack at address 8.
set 7 8

# The procedure.
goto printProcEnd   # Skip procedure body.
label printProc
set 5 1             # print true;
set 5 0             # print false;

# Return control to the last calling point.
< copy integer from top of stack 
  (i.e., integer/address contained in address 7) to address 1 >

< set address 2 to some constant
  (to skip the calling machine instructions) >

< add contents of address 1 and address 2 >
jump 0
label printProcEnd

# The first call.
< increment integer in address 7 (the stack pointer) >
< copy integer from address 6 to top of stack
  (i.e., address/integer specified in address 7) >

goto printProc

set 5 0             # print false;

# The second call.
< increment integer in address 7 (the stack pointer) >
< copy integer from address 6 to top of stack
  (i.e., address/integer specified in address 7) >

goto printProc

set 5 1             # print true;
        ]]></code>
      </example>
      <!--
 - garbage collection: mark and sweep
 - run-time/virtual machine
 - compiling to a platform supporting parallelism
      -->
    </subsection>
    <assignment title="Compilation and Review of Interpretation">
      <instructions>
        <text><![CDATA[
In this assignment you will practice implementing interpretation and compilation algorithms using Python. You must submit four Python source files:
<ul>
  <li><code><a href="hw3/parse.py">hw3/parse.py</a></code> (there is no need to modify this file);</li>
  <li><code><a href="hw3/interpret.py">hw3/interpret.py</a></code>;</li>
  <li><code><a href="hw3/machine.py">hw3/machine.py</a></code>;</li>
  <li><code>hw3/compile.py</code>.</li>
</ul>
Please follow the <a href="#A">gsubmit</a> directions and remember to put your files in the <code>hw3</code> directory.
        ]]></text> 
        <paragraph><![CDATA[
Your solutions to each of the problem parts below will be graded on their correctness, concision, and mathematical legibility. The different problems and problem parts rely on the lecture notes and on each other; carefully consider whether you can use functions from the lecture notes, or functions you define in one part within subsequent parts.
        ]]></paragraph> 
        <paragraph><![CDATA[
<b style="color:green;">A testing script with several test cases is available for download: <a href="hw3-tests.py"><code>hw3-tests.py</code></a>. You should be able to place it in the same directory with the other assignment files and run it. Feel free to modify or extend it as you see fit.</b>
<!--<br/><br/>
<b style="color:green;">A full solution to this assignment is now available here: <a href="hw3/solutions/"><code>/hw3/solutions</code></a>.</b>-->
        ]]></paragraph> 
      </instructions>
      <problems>
        <problem>
          <text hooks="math"><![CDATA[
In this problem, you will implement an interpreter for a high-level language. All the functions you define should be included in the file <code><a href="hw3/interpret.py">hw3/interpret.py</a></code>. The abstract syntax for the language is presented below:
\begin{eqnarray}
<i>term</i> & ::= &  <i>number</i> | <i>variable</i> | <i>term</i> <b>+</b> <i>term</i> \\
<i>formula</i> & ::= &  <b>true</b> | <b>false</b> | <i>variable</i>
                  <!-- | <b>forall</b> <i>variable</i> <b>to</b> <i>number</i> <b>,</b>&nbsp; <i>formula</i> \\ -->
                  | <b>not</b> <i>formula</i> | <i>formula</i> <b>and</b> <i>formula</i> | <i>formula</i> <b>or</b> <i>formula</i> \\
                  <!-- | <i>term</i> <b>==</b> <i>term</i> -->
                  <!-- | <i>term</i> <b>&lt;</b> <i>term</i> -->
<i>expression</i> & ::= & <i>term</i> | <i>formula</i> \\
<i>program</i> & ::= & <b>print</b> <i>expression</i> <b>;</b> <i>program</i> \\
                 & | & <i>variable</i> <b>=</b> <i>expression</i> <b>;</b> <i>program</i>\\
                 & | & <b>if</b> <i>expression</i> <b>{</b> <i>program</i> <b>}</b> <i>program</i>\\
                 & | & <b>while</b> <i>expression</i> <b>{</b> <i>program</i> <b>}</b> <i>program</i>\\
                 & | & <b>procedure</b> <i>variable</i> <b>{</b> <i>program</i> <b>}</b> <i>program</i>  \\
                 & | & <b>call</b> <i>variable</i> <b>;</b> <i>program</i>  \\
                 & | & \\
\end{eqnarray}
The relevant portions of the operational semantics are provided below:
        ]]></text>  
              <inferences hooks="math">
                <inference title="Term-Variable">
                  <premises><![CDATA[\Sigma(%x) = %v]]></premises>
                  <conclusion><![CDATA[\Sigma, %x \Downarrow %v]]></conclusion>
                </inference>
                <inference title="Formula-Variable">
                  <premises><![CDATA[\Sigma(%x) = %v]]></premises>
                  <conclusion><![CDATA[\Sigma, %x \Downarrow %v]]></conclusion>
                </inference>
                <inference title="Formula-Not">
                  <premises><![CDATA[\Sigma, %f \Downarrow %v]]></premises>
                  <conclusion><![CDATA[\Sigma, <b>not</b> %f \Downarrow \neg %v]]></conclusion>
                </inference>
                <inference title="Formula-Or-Short">
                  <premises><![CDATA[\Sigma, %f_1 \Downarrow <b>true</b>]]></premises>
                  <conclusion><![CDATA[\Sigma, %f_1 <b>or</b> %f_2 \Downarrow <b>true</b>]]></conclusion>
                </inference>
                <inference title="Formula-Or">
                  <premises><![CDATA[\Sigma, %f_1 \Downarrow %v_1 %~ %~ \Sigma, %f_2 \Downarrow %v_2]]></premises>
                  <conclusion><![CDATA[\Sigma, %f_1 <b>or</b> %f_2 \Downarrow %v_1 \vee %v_2]]></conclusion>
                </inference>
                <inference title="Formula-And-Short">
                  <premises><![CDATA[\Sigma, %f_1 \Downarrow <b>false</b>]]></premises>
                  <conclusion><![CDATA[\Sigma, %f_1 <b>and</b> %f_2 \Downarrow <b>false</b>]]></conclusion>
                </inference>
                <inference title="Formula-And">
                  <premises><![CDATA[\Sigma, %f_1 \Downarrow %v_1 %~ %~ \Sigma, %f_2 \Downarrow %v_2]]></premises>
                  <conclusion><![CDATA[\Sigma, %f_1 <b>and</b> %f_2 \Downarrow %v_1 \wedge %v_2]]></conclusion>
                </inference>
                <inference title="Statement-Assign">
                  <premises><![CDATA[\Sigma_1 \uplus {%x \mapsto %v}, %p \Downarrow \Sigma_2, %o %~ %~ \Sigma_1, %e \Downarrow %v]]></premises>
                  <conclusion><![CDATA[\Sigma_1, %x <b>=</b> %e <b>;</b> %p \Downarrow \Sigma_2, %o]]></conclusion>
                </inference>
                <inference title="Statement-Procedure">
                  <premises><![CDATA[\Sigma_1 \uplus {%x \mapsto %p_1}, %p_2 \Downarrow \Sigma_2, %o]]></premises>
                  <conclusion><![CDATA[\Sigma_1, <b>procedure</b> %x <b>{</b> %p_1 <b>}</b> %p_2 \Downarrow \Sigma_2, %o]]></conclusion>
                </inference>
                <inference title="Statement-Call">
                  <premises><![CDATA[\Sigma_1(%x) = %p_1 %~ %~ \Sigma_1, %p_1 \Downarrow \Sigma_2, %o_1 %~ %~ \Sigma_2, %p_2 \Downarrow \Sigma_3, %o_2]]></premises>
                  <conclusion><![CDATA[\Sigma_1, <b>call</b> %x <b>;</b> %p_2 \Downarrow \Sigma_3, %o_1;%o_2]]></conclusion>
                </inference>
              </inferences>
          <text hooks="math"><![CDATA[
The remaining rules 
<span style="font-variant:small-caps;">[Term-Number]</span>, 
<span style="font-variant:small-caps;">[Term-Plus]</span>, 
<span style="font-variant:small-caps;">[Formula-True]</span>, 
<span style="font-variant:small-caps;">[Formula-False]</span>,
<span style="font-variant:small-caps;">[Statement-Print]</span>, 
<span style="font-variant:small-caps;">[Statement-If-False]</span>, 
<span style="font-variant:small-caps;">[Statement-If-True]</span>, 
<span style="font-variant:small-caps;">[Statement-While-False]</span>, 
<span style="font-variant:small-caps;">[Statement-While-True]</span>, and
<span style="font-variant:small-caps;">[Statement-End]</span> are exactly the same as those in <b><a href="#assignment2">Assignment #2</a></b>. Notice that in these inference rules, the environment now also contains mappings from procedure names to procedure bodies.
          ]]></text>
          <parts>
            <part>
              <text><![CDATA[
Implement a function <code>evalTerm(env, t)</code> that takes an environment <code>env</code> and a parse tree <code>t</code> as its two arguments. The function should return the value that corresponds to the evaluation of the parse tree <code>t</code>, as determined by the operational semantics.
              ]]></text>
            </part>
            <part>
              <text><![CDATA[
Implement a function <code>evalFormula(env, f)</code> that takes an environment <code>env</code> and a parse tree <code>f</code> as its two arguments. The function should return the value that corresponds to the evaluation of the parse tree <code>t</code>, as determined by the operational semantics.
              ]]></text>
            </part>
            <part>
              <text><![CDATA[
Implement a function <code>execProgram(env, s)</code> that takes an environment <code>env</code> and a parse tree <code>s</code> as its two arguments. The function should return a tuple containing an updated environment and the output (represented as a list of values) that represent the result of the execution of the program <code>s</code> as determined by the operational semantics.
              ]]></text>
            </part>
          </parts>
        </problem>
        <problem>
          <text><![CDATA[
In this problem you will implement several helper functions for building sequences of instructions in a machine language. The file <code><a href="hw3/machine.py">hw3/machine.py</a></code> already contains a simulator for the machine language with which you will be working; the machine language is defined in detail in <a href="#3246043602d540668dc63d5b6277a47f">a previous example in the lecture notes</a>.
Although any correct implementation is acceptable, it is suggested that you follow the conventions below:
<ul>
  <li>use negative memory addresses, starting at <code>-1</code>, for the stack;</li>
  <li>use memory address <code>7</code> to store the memory address of the top of the stack;</li>
  <li>use memory addresses <code>8</code> and higher for the heap (i.e., results of computations).</li>
</ul>
All the functions you define should be included in the file <code><a href="hw3/machine.py">hw3/machine.py</a></code>. 
          ]]></text>
          <parts>
            <part>
              <text><![CDATA[
Implement a function <code>increment(addr)</code> that takes a single integer argument <code>addr</code>. The function should return a list of instructions (in which each instruction is represented as a string in the list). These instructions should correspond to a machine language program that increments by <code>1</code> the integer stored in the memory location <code>addr</code> and cleans up any memory addresses it used in the process by setting them back to <code>0</code>.
              ]]></text>
            </part>
            <part>
              <text><![CDATA[
Implement a function <code>decrement(addr)</code> that takes a single integer argument <code>addr</code>. The function should return a sequence of instructions (represented as a Python list of strings). These instructions should correspond to a machine language program that decrements by <code>1</code> the integer stored in the memory location <code>addr</code> and cleans up any memory addresses it used in the process by setting them back to <code>0</code>.
              ]]></text>
            </part>
            <part>
              <text><![CDATA[
Implement a function <code>call(name)</code> that takes a single argument: <code>name</code> is a string corresponding to the name of a procedure. The function should return a sequence of instructions that performs the following operations:
<ul>
  <li>update the integer stored in the memory address that contains the address of the top of the call stack (i.e., decrement it, since the stack is in the part of memory indexed using negative integers);</li>
  <li>store the current program location at the top of the call stack;</li>
  <li>increment the value at the top of the call stack so it refers to the location in the program to which control should return after the end of the procedure being invoked;</li>
  <li><b>goto</b> the procedure body that corresponds to the procedure <code>name</code> supplied;</li>
  <li>update the integer stored in the memory address that contains the address of the top of the call stack (i.e., increment it, since the stack is in the part of memory indexed using negative integers).</li>
</ul>
The third step above is crucial: failing to specify the correct return location in the program can lead to an infinite loop.
              ]]></text>
            </part>
            <part>
              <text><![CDATA[
Implement a function <code>procedure(name, body)</code> that takes two arguments: <code>name</code> is a string corresponding to the name of a procedure, and <code>body</code> is a sequence of machine language instructions (represented as a Python list of strings). The function should return a sequence of instructions that includes:
<ul>
  <li>a <b>goto</b> instruction so that the procedure body is skipped by default if instructions are being executed sequentially;</li>
  <li>a label identifying the start of the procedure body;</li>
  <li>the procedure body</li>
  <li>instructions to <b>jump</b> back to the machine language program location that invoked the procedure;</li>
  <li>a label identifying the end of the procedure body.</li>
</ul>
              ]]></text>
            </part>
          </parts>
        </problem>
        <problem>
          <text><![CDATA[
In this problem you will implement a compiler; your solutions for this problem should appear in the file <code>hw3/compile.py</code>. The source language of the compiler will be the language for which you implemented an interpreter in <b>Problem #1</b>. The target language will be the machine language with which you worked in <b>Problem #2</b>.
          ]]></text>
          <parts>
            <part>
              <text><![CDATA[
Implement a function <code>compileTerm(env, t, heap)</code> that takes three arguments: <code>env</code> is a mapping from variables to memory addresses, <code>t</code> is a <i>term</i> parse tree, and <code>heap</code> is the memory address of the current top of the heap. The function should return a tuple <code>(insts, addr, heap)</code> in which <code>insts</code> is a sequence of machine language instructions (represented as a Python list of strings) that perform the computation represented by the parse tree, <code>addr</code> is the address of the result, and <code>heap</code> is an integer representing the memory of the top of the heap after the computation is performed.
              ]]></text>
            </part>
            <part>
              <text><![CDATA[
Implement a function <code>compileFormula(env, f, heap)</code>. The requirements for this function are the same as those for <code>compileTerm(env, t, heap)</code>, except that it must handle <i>formula</i> parse trees.
              ]]></text>
            </part>
            <part>
              <text><![CDATA[
Implement a function <code>compileProgram(env, s, heap)</code> that takes three arguments: <code>env</code> is a mapping from variables to memory addresses, <code>s</code> is a <i>program</i> parse tree, and <code>heap</code> is the memory address of the current top of the heap. The function should return a tuple <code>(env, insts, heap)</code> in which <code>env</code> is an updated environment, <code>insts</code> is a sequence of machine language instructions (represented as a Python list of strings) that perform the computation represented by the parse tree, and <code>heap</code> is an integer representing the memory of the top of the heap after the computation is performed.
              ]]></text>
            </part>
            <part>
              <text><![CDATA[
Implement a function <code>compile(s)</code> that takes a single string <code>s</code> that is a concrete syntax representation of a program in the source programming language and returns its compiled form: a sequence of instructions in the target machine language.
              ]]></text>
            </part>
          </parts>
        </problem>
        <problem>
          <text><![CDATA[
<b>Extra credit:</b> Add support for the binary equality operator <i>term</i> <b>=</b> <i>term</i> to <i>formula</i>. The file <a href="hw3/parse.py">hw3/parse.py</a> has been updated to support this operator and to emit the <code>'Compare'</code> node when this operation appears in the concrete syntax. You must extend both the interpreter and compiler to support this operator. 
          ]]></text>
        </problem>
      </problems>
    </assignment>
    <subsection title="Common compiler optimizations and register allocation">
      <text><![CDATA[
Optimization algorithms are typically transformations of the abstract syntax of a language. In a compiler, this abstract syntax is usually that of a particular intermediate representation used within the compiler, but optimizations might occur at any stage in the compilation process.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">source<br/>language<br/>abstract<br/>syntax</td>
    <td><span style="font-size:20px;">&rArr;<br/>&lArr;</span></td>
    <td class="box" style="background-color:lightyellow;">optimization<br/>algorithm #1</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">compilation<br/>algorithm A</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:powderblue;">intermediate<br/>representation<br/>(IR) #1</td>
    <td><span style="font-size:20px;">&rArr;<br/>&lArr;</span></td>
    <td class="box" style="background-color:lightyellow;">optimization<br/>algorithm #2</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">compilation<br/>algoritm B</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:powderblue;">intermediate<br/>representation<br/>(IR) #2</td>
    <td><span style="font-size:20px;">&rArr;<br/>&lArr;</span></td>
    <td class="box" style="background-color:lightyellow;">optimization<br/>algorithm #3</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">compilation<br/>algorithm C</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:powderblue;">target<br/>language<br/>abstract<br/>syntax</td>
    <td><span style="font-size:20px;">&rArr;<br/>&lArr;</span></td>
    <td class="box" style="background-color:lightyellow;">optimization<br/>algorithm #4</td>
  </tr>
</table>
</div>
      ]]></text>
      <definition required="true" id="f7d61c822fe211e38cf6ce3f5508acd9"><![CDATA[
<i>Loop unrolling</i> is an optimization that involves duplicating loop bodies a constant number of times, typically to reduce the number of conditional <b>branch</b> instructions that must occur if the number of loop iterations is known at compile time. Depending on the particular language and compiler, the loop unrolling optimization could be applied to high-level language abstract syntax trees, intermediate representation abstract syntax trees, and sometimes to machine language programs.
      ]]></definition>
      <example required="true" id="e5e18f0c7eea4f0d85cd48ae45d6ca0f">
        <text><![CDATA[
Suppose we are compiling a program written in a high-level language that looks like the following.
        ]]></text>
        <code hooks="Python"><![CDATA[
i = 0;
while (i < 1000000) {
  i++;
}
        ]]></code>
        <text><![CDATA[
One option is to compile the above program into the following sequence of machine language instructions (assume that the variable <code>i</code> corresponds to memory address <code>123</code>).
        ]]></text>
        <code hooks="Python"><![CDATA[
label whileLoop
< increment integer in address 123 >
< compare integer in address 123 to integer 1000000 and store result in address 200 >
branch whileLoop 200
        ]]></code>
        <text><![CDATA[
If we execute the above machine language program, we will execute 1,000,000 comparison operations. We can reduce the cost of the comparison operations in this case by duplicating the body of the loop some number of times.
        ]]></text>
        <code hooks="Python"><![CDATA[
i = 0;
while (i < 1000000) {
  i++;
  i++;
  i++;
  i++;
  i++;
  i++;
  i++;
  i++;
  i++;
  i++;
}
        ]]></code>
        <text><![CDATA[
Notice that in the above program, we have reduced the number of comparison operations by a factor of 10. However, to achieve this we had to increase the size of the machine language program by a factor of 10.
        ]]></text>
        <code hooks="Python"><![CDATA[
label whileLoop
< increment integer in address 123 >
< increment integer in address 123 >
< increment integer in address 123 >
< increment integer in address 123 >
< increment integer in address 123 >
< increment integer in address 123 >
< increment integer in address 123 >
< increment integer in address 123 >
< increment integer in address 123 >
< increment integer in address 123 >
< compare integer in address 123 to integer 1000000 and store result in address 200 >
branch whileLoop 200
        ]]></code>
      </example>
      <definition required="true" id="f7d6137c2fe211e38cf6ce3f5508acd9"><![CDATA[
<i>Constant folding</i> involves replacing subtrees (typically expressions) within an abstract syntax tree with values (the value should normally correspond to the result of evaluating the expression).
      ]]></definition>
      <example required="true" id="8e950576073f4bf79045b9e636757453">
        <text><![CDATA[
Suppose we have the following abstract syntax tree.
        ]]></text>
        <code hooks="Python"><![CDATA[
{'Print': [
  {'Plus': [
    {'Mult':[{'Number':[3]}, {'Number':[4]}]},
    {'Variable':['x']}
  ]}
]}
        ]]></code>
        <text><![CDATA[
An optimization algorithm that performs constant folding might traverse the above tree, recognize that the subtree <code>{'Mult':[{'Number':[3]}, {'Number':[4]}]}</code> can be evaluated in a finite amount of time, and then replace it with the value to which it evaluates. The overall tree would then look as follows.
        ]]></text>
        <code hooks="Python"><![CDATA[
{'Print': [
  {'Plus': [
    {'Number':[12]},
    {'Variable':['x']}
  ]}
]}
        ]]></code>
      </example>
      <definition required="true" id="196b533f6ecf46a6a4f7f639b072c51f">
        <text hooks="math"><![CDATA[
An abstract syntax tree is in <i>single static assignment</i> or <i>SSA</i> form if every variable appears exactly once on the left-hand side of an assignment statement.
        ]]></text>
        <paragraph hooks="math"><![CDATA[
An abstract syntax tree can be converted into SSA form by converting every variable on the left-hand side of an assignment statement so that it is unique, and then replacing all occurrences of that variable with the version of that variable that appears in the last assignment above the occurrence.
        ]]></paragraph>
      </definition>
      <example required="true" id="266f498ec6374a7191ede114f45b244a">
        <text><![CDATA[
Suppose we have the following program in a high-level programming language.
        ]]></text>
        <code hooks="Python"><![CDATA[
a := 2;
b := 5;
print a + b;
f := true and false;
print f;
a := 7;
g := true;
h := false;
b := 0;
print b;
print h;
print g;
print a;
        ]]></code>
        <text><![CDATA[
If we converted the abstract syntax tree that represents the above program into SSA form, we might obtain an abstract syntax tree that represents the following program.
        ]]></text>
        <code hooks="Python"><![CDATA[
a_0 := 2;
b_0 := 5;
print a_0 + b_0;
f_0 := true and false;
print f_0;
a_1 := 7;
g_0 := true;
h_0 := false;
b_1 := 9;
print b_1;
print h_0;
print g_0;
print a_1;
        ]]></code>
        <text><![CDATA[
Notice that each variable in the original program has been associated with an index so that no variable in the new program ever appears on the left-hand of an assignment more than once.
        ]]></text>
      </example>
      <definition required="true" id="25323684870d432981d07d82b725955e"><![CDATA[
<i>Register allocation</i> involves assigning a CPU register to each variable within the abstract syntax tree representing a program (typically an intermediate representation in single static assignment form). This usually requires building an <i>interference graph</i> of the variables within the program, and then solving the <i>graph coloring problem</i> where each register represents a color.
      ]]></definition>
      <example required="true" id="51f35310e639411c98f9246c52e08f33">
        <text hooks="math"><![CDATA[
When compiling list or set comprehensions in languages such as Haskell and Python, the operational semantics of comprehensions allows for parallelization of the individual steps in a way that iterative constructs do not allow. This is because in a comprehension, each "iteration" or "step" of the comprehension is evaluated under the same environment. In an imperative looping statement, the modified environment emitted by one iteration is fed into the execution of the next iteration, so the effects of each iteration accumulate over time. This requires executing each iteration one after the other, and keeping track of the changing environment.
        ]]></text>
        <paragraph hooks="math"><![CDATA[
Thus, it is possible to compile a program so that the individual "iterations" or "steps" of a comprehension are evaluated on different processors, or even different computers, and then reassembled into the final results. This is not necessarily possible with a looping statement.
        ]]></paragraph>
        <paragraph hooks="math"><![CDATA[
You can see this in the two different operational semantics rules below (the first for an imperative looping statement, the second for a comprehension expression).
        ]]></paragraph>
        <inferences hooks="math">
          <inference title="Stmt-For">
            <premises><![CDATA[
              \Sigma_0 \uplus {%x \mapsto 1}, %p \Downarrow \Sigma_1
              %~ %~ \Sigma_1 \uplus {%x \mapsto 2}, %p \Downarrow \Sigma_2
              %~ %~ \Sigma_2 \uplus {%x \mapsto 3}, %p \Downarrow \Sigma_3
            ]]></premises>
            <conclusion><![CDATA[\Sigma_0, <b>for</b> %x <b>in</b> {1,2,3}<b>:</b> %p \Downarrow \Sigma_3]]></conclusion>
          </inference>
          <inference title="Exp-Comprehension">
            <premises><![CDATA[
              \Sigma \uplus {%x \mapsto 1}, %p \Downarrow %v_1
              %~ %~ \Sigma \uplus {%x \mapsto 2}, %p \Downarrow %v_2
              %~ %~ \Sigma \uplus {%x \mapsto 3}, %p \Downarrow %v_3
            ]]></premises>
            <conclusion><![CDATA[\Sigma, <b>[</b> %e <b>for</b> %x <b>in</b> {1,2,3} <b>]</b> \Downarrow [%v_1, %v_2, %v_3]]]></conclusion>
          </inference>
        </inferences>
      </example>
      <text><![CDATA[
The following diagram illustrates how the various optimization and compilation algorithms described in this section might fit together within the architecture of a compiler.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">high-level<br/>source<br/>language<br/>abstract<br/>syntax</td>
    <td><span style="font-size:20px;">&rArr;<br/>&lArr;</span></td>
    <td class="box" style="background-color:lightyellow;">loop<br/>unrolling</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">SSA conversion</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:powderblue;">IR in SSA form</td>
    <td><span style="font-size:20px;">&rArr;<br/>&lArr;</span></td>
    <td class="box" style="background-color:lightyellow;">constant<br/>folding</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">compilation</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:powderblue;">low-level IR</td>
    <td><span style="font-size:20px;">&rArr;<br/>&lArr;</span></td>
    <td class="box" style="background-color:lightyellow;">register<br/>allocation</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">instruction<br/>selection</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:powderblue;">low-level<br/>target<br/>machine<br/>language<br/>abstract<br/>syntax</td>
    <td></td>
    <td></td>
  </tr>
</table>
</div>
      ]]></text>
    </subsection>
    <subsection title="Correctness of compilation algorithms">
      <text hooks="math"><![CDATA[
Compilers represent a unique kind of software application because their implementation can affect the quality of all the software applications that they compile. This means that compiler flaws can be particularly expensive; as a result, there may be many practical justifications for investing heavily in verifying that a compiler, or components thereof, behave correctly. However, to determine whether a compiler behaves correctly, it is first necessary to define what constitutes correct behavior.
<br/><br/>
One way to define correct behavior is to appeal to the operational semantics of the source and target languages.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">source language<br/>abstract syntax</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">compilation<br/>algorithm</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">target language<br/>abstract syntax</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&#8659;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td><span style="font-size:20px;">&#8659;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">source language<br/>operational semantics<br/>(interpreter)</td>
    <td></td>
    <td></td>
    <td></td>
    <td class="box" style="background-color:lightyellow;">target language<br/>operational semantics<br/>(simulator)</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&#8659;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:powderblue;">source language<br/>abstract syntax<br/>for values/outputs</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">simple<br/>conversion<br/>algorithm for<br/>values/outputs</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">target language<br/>abstract syntax<br/>for values/outputs</td>
  </tr>
</table>
</div>
      ]]></text>
      <definition hooks="math" required="true" id="f7d611922fe211e38cf6ce3f5508acd9"><![CDATA[
Suppose we are given a source and target language (including the definitions of the abstract syntax and the operational semantics for each language, as well as corresponding interpretation/simulation functions <b>interpret()</b> and <b>simulate()</b>), a simple conversion algorithm <b>convert()</b> between the sets of values and outputs in each language, and a compilation algorithm <b>compile()</b>.
<br/><br/>
The compilation algorithm <b>compile()</b> is <i>correct</i> (or <i>behaves correctly</i>) if for all possible input programs %p in the source language, the following equation is true:
\begin{eqnarray}
<b>simulate(compile(</b>%p<b>))</b>& = & <b>convert(interpret(</b>%p<b>))</b>
\end{eqnarray}
      ]]></definition>
      <text hooks="math"><![CDATA[
Notice that the <a href="#f7d611922fe211e38cf6ce3f5508acd9">above definition</a> of correctness is functional but perhaps not practical. If the operational semantics of one or both languages does not capture running time, security (e.g., stack overflows), or other concerns, the definition may be inadequate. We will discuss these issues in more detail in a <a href="#6">subsequent section</a>.
<br/><br/>
If the number of possible programs in the source language is infinite, it is impossible to check that the equation in the <a href="#f7d611922fe211e38cf6ce3f5508acd9">above definition</a> holds for all possible programs through testing alone, though testing can provide some confidence. Nevertheless, it may be possible to mathematically <i>prove</i> that the equation holds without doing any testing at all.
<br/><br/>
Software testing and verification is a broad area of research and practice that spans multiple (sometimes disparate) disciplines and communities. In this subsection, we will focus on three specific categories of testing and verification that are useful for determining the correctness of compiler implementations. These three categories represent only a small (but important) subset of the approaches currently being developed and used.
      ]]></text>   
      <definition required="true" id="f7d6204c2fe211e38cf6ce3f5508acd9">
        <text hooks="math"><![CDATA[
There are at least three possible approaches to verifying that a compiler's behavior conforms to its specification. These include:
        ]]></text>
        <unorderedlist>
          <item><![CDATA[suites of individual test cases;]]></item>
          <item><![CDATA[bounded exhaustive testing;]]></item>
          <item><![CDATA[formal (usually inductive) proof of correctness over all inputs.]]></item>
        </unorderedlist>
      </definition>
      <example required="true" id="f7d61a842fe211e38cf6ce3f5508acd9">
        <text hooks="math"><![CDATA[
Bounded exhaustive testing involves defining a metric on inputs (e.g., a mapping from inputs to an integer), and then testing all inputs for which the matric is below a certain integer bound. For example, let us consider a simple language for formulas:
\begin{eqnarray}
<i>formula</i> & ::= & <b>true</b> | <b>false</b> | <b>not</b> <i>formula</i>| <i>formula</i> <b>and</b> <i>formula</i> | <i>formula</i> <b>or</b> <i>formula</i> 
\end{eqnarray}
We can define a metric on the set of abstract syntax trees that conform to the above definition: the depth of the tree.
        ]]></text>
        <code hooks="Python">
Node = @dict
Leaf = @str

@def metric(f):
    if @type(f) == Leaf:
        @return 1
    if @type(f) == Node:
        @for label @in f:
            @return 1 + @max([metric(child) @for child @in f[label]])
        </code>
        <text hooks="math"><![CDATA[
We can then generate all trees whose metric falls within a specified bound.
        ]]></text>
        <code hooks="Python"><![CDATA[
@def formulas(n):
    @if n <= 0:
        []
    @elif n == 1:
        @return ['True', 'False']
    @else:
        fs = formulas(n-1)
        fsN = []
        fsN += [{'Not':[f]} @for f @in fs]
        fsN += [{'And':[f1,f2]} @for f1 @in fs @for f2 @in fs]
        fsN += [{'Or':[f1,f2]} @for f1 @in fs @for f2 @in fs]
        @return fs + fsN
        ]]></code>
        <text hooks="math"><![CDATA[
It is then possible to use the above code to generate test cases automatically, and to check the equation specifying compiler correctness against each test case.
        ]]></text>
      </example>
    </subsection>
  </section>
  <section title="Static Analysis and Abstract Interpretation">
    <text><![CDATA[
Most compilers and interpreters perform basic error checking and <i>static analysis</i> before running or compiling a program. This serves a variety of purposes, some of which include:
<ul>
  <li>catching errors in the program before incurring the cost (in time, power, etc.) or actually running it;</li>
  <li>returning more detailed and user-friendly error messages;</li>
  <li>determining information about the program that is required for the optimization and compilation algorithms (e.g., detecting opportunities for constant folding);</li>
  <li>improving performance of interpreted or compiled programs by eliminating run-time error checking;</li>
  <li>eliminating invalid test cases when doing bounded exhaustive testing.</li>
</ul>
Static analysis is related to a broader concept: <i>abstract interpretation</i>. It is possible to analyze programs along a variety of other dimensions that may of interest, including, for example, the program's range of outputs, the program's running time, the monetary cost of running the program, the program's power consumption, and so on.
<br/><br/>
Both static analysis and abstract interpretation algorithms are conventionally expected to terminate in a finite, and typically relatively fast, amount of time (e.g., it should be possible to run a new static analysis or abstract interpretation each and every time the program is compiled, even during an interactive programming and/or testing session).
<br/><br/>
In this section we present a notation for defining static analysis and abstract interpretation algorithms. This notation is very similar to the one we introduced for defining the <a href="#4.2">operational semantics</a> of programming languages.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">source<br/>language<br/>concrete<br/>syntax</td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td class="box" style="background-color:powderblue;">target<br/>language<br/>abstract<br/>syntax</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td><span style="font-size:20px;">&uArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">parser</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">source<br/>language<br/>abstract<br/>syntax</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">static<br/>analysis<br/>algorithms</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:powderblue;">abstract<br/>syntax<br/>or IR</td>
    <td><span style="font-size:20px;">&#8658;</span></td>
    <td class="box" style="background-color:lightyellow;">compilation<br/>algorithms</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td class="box" style="background-color:powderblue;">syntax<br/>errors</td>
    <td></td>
    <td></td>
    <td></td>
    <td class="box" style="background-color:powderblue;">other errors<br/>(unbound variables,<br/>type errors, etc.)</td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
</table>
</div>
    ]]></text>
    <subsection title="Monomorphic type systems and type checking">
      <text><![CDATA[
A <i>type checking</i> algorithm is a specific kind of static analysis algorithm. It represents a "low-resolution" evaluation of the abstract syntax tree of a program to determine the <i>type</i> that can be assigned to every subtree in that program.
      ]]></text>
      <example required="true" id="f7d607382fe211e38cf6ce3f5508acd9">
        <text hooks="math"><![CDATA[
Suppose we are working with a programming language with the following abstract syntax.
\begin{eqnarray}
<i>expression</i> & ::= & <b>true</b> | <b>false</b> | <i>number</i> \\
                   & | & <b>not</b> <i>expression</i>  \\
                   & | & <i>expression</i> <b>and</b> <i>expression</i> \\
                   & | & <i>expression</i> <b>or</b> <i>expression</i> \\
                   & | & <i>expression</i> <b>+</b> <i>expression</i>
\end{eqnarray}
The abstrac syntax for types is defined as follows:                   
\begin{eqnarray}           
<i>type</i> & ::= & <b style="color:firebrick">integer</b> \\
             & | & <b style="color:firebrick">boolean</b>
\end{eqnarray}
We can define a set of type inference rules for this language. These rules constitute the type system for the language.
        ]]></text>
        <inferences hooks="math">
          <inference title="Formula-True">
            <premises><![CDATA[]]></premises>
            <conclusion><![CDATA[\vdash <b>true</b>: <b style="color:firebrick">boolean</b>]]></conclusion>
          </inference>
          <inference title="Formula-False">
            <premises><![CDATA[]]></premises>
            <conclusion><![CDATA[\vdash <b>false</b>: <b style="color:firebrick">boolean</b>]]></conclusion>
          </inference>
          <inference title="Formula-Not">
            <premises><![CDATA[\vdash %e: <b style="color:firebrick">boolean</b>]]></premises>
            <conclusion><![CDATA[\vdash <b>not</b> %e: <b style="color:firebrick">boolean</b>]]></conclusion>
          </inference>
          <inference title="Formula-And">
            <premises><![CDATA[\vdash %e_1: <b style="color:firebrick">boolean</b> %~ %~ \vdash %e_2: <b style="color:firebrick">boolean</b>]]></premises>
            <conclusion><![CDATA[\vdash %e_1 <b>and</b> %e_2: <b style="color:firebrick">boolean</b>]]></conclusion>
          </inference>
          <inference title="Formula-Or">
            <premises><![CDATA[\vdash %e_1: <b style="color:firebrick">boolean</b> %~ %~  \vdash %e_2: <b style="color:firebrick">boolean</b>]]></premises>
            <conclusion><![CDATA[\vdash %e_1 <b>or</b> %e_2: <b style="color:firebrick">boolean</b>]]></conclusion>
          </inference>
          <inference title="Term-Number">
            <premises><![CDATA[]]></premises>
            <conclusion><![CDATA[\vdash <i>number</i>: <b style="color:firebrick">integer</b>]]></conclusion>
          </inference>
          <inference title="Term-Plus">
            <premises><![CDATA[\vdash %e_1: <b style="color:firebrick">integer</b> %~ %~ \vdash %e_2: <b style="color:firebrick">integer</b>]]></premises>
            <conclusion><![CDATA[\vdash %e_1 <b>+</b> %e_2: <b style="color:firebrick">integer</b>]]></conclusion>
          </inference>
        </inferences>
        <text hooks="math"><![CDATA[
We can convert the above inference rules into a type checking algorithm; the process is almost identical to the process used for converting an operational semantics into an interpreter implementation.
        ]]></text>
        <code hooks="Python"><![CDATA[
@def typeCheck(e):
    @if @type(e) == Leaf:
        @if e == 'True' @or e == 'False':
            @return 'boolean'
    @if @type(e) == Node:
        @for label @in e:
            @if label == 'Number':
                 @return 'integer'
            @if label == 'Not':
                  [e1] = e[label]
                  t1 = typeCheck(e1)
                  @if t1 != 'boolean':
                     @print("not must be applied to a boolean")
                     @return @None
                  @return 'boolean'
            
            # ...
            
            @if label == 'Plus':
                [e1,e2] = e[label]
                t1 = typeCheck(e1)
                t2 = typeCheck(e2)
                @if t1 != 'integer' @or t2 != 'integer':
                    @print("+ requires integer arguments")
                    @return @None
                @return 'integer'
        ]]></code>
      </example>
      <example required="true" id="f7d615702fe211e38cf6ce3f5508acd9">
        <text hooks="math"><![CDATA[
Suppose we are working with a programming language with the following abstract syntax.
\begin{eqnarray}
<i>program</i> & ::= & <i>variable</i> <b>:=</b> <i>expression</i> <b>;</b> <i>program</i> \\
               & | & \\
<i>expression</i> & ::= & <i>variable</i> \\
                   & | & <i>constant</i>  \\
                   & | & <b>not</b> <i>expression</i>  \\
                   & | & <i>expression</i> <b>and</b> <i>expression</i> \\
                   & | & <i>expression</i> <b>or</b> <i>expression</i> \\
                   & | & <i>expression</i> <b>*</b> <i>expression</i> \\
                   & | & <i>expression</i> <b>+</b> <i>expression</i> \\
<i>constant</i> & ::= & <b>true</b> | <b>false</b> | <i>number</i> \\
<i>number</i> & ::= & <i>any valid integer</i> \\
<i>variable</i> & ::= & <i>any valid variable</i>\\
<i>type</i> & ::= & <b style="color:firebrick">integer</b> \\
             & | & <b style="color:firebrick">boolean</b> \\
             & | & <b style="color:firebrick">void</b>
\end{eqnarray}
We can define a set of type inference rules for this language. These rules constitute the type system for the language.
        ]]></text>
        <inferences hooks="math">
          <inference title="Statement-Assign">
            <premises><![CDATA[\Gamma \uplus {%x \mapsto \tau} \vdash %p: <b style="color:firebrick">void</b> %~ %~ \Gamma \vdash %e: \tau]]></premises>
            <conclusion><![CDATA[\Gamma \vdash %x <b>:=</b> %e <b>;</b> %p : <b style="color:firebrick">void</b>]]></conclusion>
          </inference>
          <inference title="Statement-End">
           <premises><![CDATA[]]></premises>
            <conclusion><![CDATA[\Gamma \vdash <b style="color:gray;">end</b>: <b style="color:firebrick">void</b>]]></conclusion>
          </inference>
          <inference title="Variable">
            <premises><![CDATA[\Gamma(%x) = \tau]]></premises>
            <conclusion><![CDATA[\Gamma \vdash <i>x</i>: \tau]]></conclusion>
          </inference>
          <inference title="Formula-True">
            <premises><![CDATA[]]></premises>
            <conclusion><![CDATA[\Gamma \vdash <b>true</b>: <b style="color:firebrick">boolean</b>]]></conclusion>
          </inference>
          <inference title="Formula-False">
            <premises><![CDATA[]]></premises>
            <conclusion><![CDATA[\Gamma \vdash <b>false</b>: <b style="color:firebrick">boolean</b>]]></conclusion>
          </inference>
          <inference title="Formula-Not">
            <premises><![CDATA[\Gamma \vdash %e: <b style="color:firebrick">boolean</b>]]></premises>
            <conclusion><![CDATA[\Gamma \vdash <b>not</b> %e: <b style="color:firebrick">boolean</b>]]></conclusion>
          </inference>
          <inference title="Formula-And">
            <premises><![CDATA[\Gamma \vdash %e_1: <b style="color:firebrick">boolean</b> %~ %~ \Gamma \vdash %e_2: <b style="color:firebrick">boolean</b>]]></premises>
            <conclusion><![CDATA[\Gamma \vdash %e_1 <b>and</b> %e_2: <b style="color:firebrick">boolean</b>]]></conclusion>
          </inference>
          <inference title="Formula-Or">
            <premises><![CDATA[\Gamma \vdash %e_1: <b style="color:firebrick">boolean</b> %~ %~ \Gamma \vdash %e_2: <b style="color:firebrick">boolean</b>]]></premises>
            <conclusion><![CDATA[\Gamma \vdash %e_1 <b>or</b> %e_2: <b style="color:firebrick">boolean</b>]]></conclusion>
          </inference>
          <inference title="Term-Number">
            <premises><![CDATA[]]></premises>
            <conclusion><![CDATA[\Gamma \vdash <i>number</i>: <b style="color:firebrick">integer</b>]]></conclusion>
          </inference>
          <inference title="Term-Plus">
            <premises><![CDATA[\Gamma \vdash %e_1: <b style="color:firebrick">integer</b> %~ %~ \Gamma \vdash %e_2: <b style="color:firebrick">integer</b>]]></premises>
            <conclusion><![CDATA[\Gamma \vdash %e_1 <b>+</b> %e_2: <b style="color:firebrick">integer</b>]]></conclusion>
          </inference>
          <inference title="Term-Mult">
            <premises><![CDATA[\Gamma \vdash %e_1: <b style="color:firebrick">integer</b> %~ %~ \Gamma \vdash %e_2: <b style="color:firebrick">integer</b>]]></premises>
            <conclusion><![CDATA[\Gamma \vdash %e_1 <b>*</b> %e_2: <b style="color:firebrick">integer</b>]]></conclusion>
          </inference>
        </inferences>
      </example>
      <example required="true" id="ffe2a6789eb84626aedbde121a1a9b7b">
        <text hooks="math"><![CDATA[
Let's consider the difference between the operational semantics inference rule and the type checking rule for a <b>while</b> construct in a hypothetical programming language. Notice that the execution rule can result in an infinite recursion because a premise above the line contains an exact copy of the abstract syntax tree that we are trying to execute. Unlike the execution rule, the typing rule cannot result in an infinite recursion (it only requires a linear-time recursive examination of the abstract syntax tree).
        ]]></text>
        <inferences hooks="math">
          <inference title="Statement-While-Eval-True">
             <premises><![CDATA[
               \Sigma_1, %p_1 \Downarrow \Sigma_2, %o_1 %~ %~ \Sigma_2, <b>while</b> %e <b>{</b> %p_1 <b>}</b> %p_2 \Downarrow \Sigma_3, %o_2 %~ %~ \Sigma_1, %e \Downarrow <b>true</b>
             ]]></premises>
             <conclusion><![CDATA[\Sigma_1, <b>while</b> %e <b>{</b> %p_1 <b>}</b> %p_2 \Downarrow \Sigma_3, %o_1;%o_2]]></conclusion>
          </inference>
          <inference title="Statement-While-Type">
             <premises><![CDATA[
               \Gamma \vdash %e : <b style="color:firebrick">boolean</b> %~ %~ \Gamma \vdash %p_1 : <b style="color:firebrick">void</b> %~ %~ \Gamma \vdash %p_2 : <b style="color:firebrick">void</b>
             ]]></premises>
             <conclusion><![CDATA[\Gamma \vdash <b>while</b> %e <b>{</b> %p_1 <b>}</b> %p_2 : <b style="color:firebrick">void</b>]]></conclusion>
          </inference>
        </inferences>
      </example>
      <example required="true" id="f7d60f9e2fe211e38cf6ce3f5508acd9">
        <text hooks="math"><![CDATA[
Suppose we are working with a programming language that supports the definition of functions that take a single integer argument.
\begin{eqnarray}
program %p & ::= & <b>function</b> %f <b>(</b> <b>int</b> %x <b>)</b> <b>{</b> <b>return</b> %e <b>;</b> <b>}</b> %p \\
               & | & %x <b>:=</b> %e <b>;</b> %p \\
               & | & \\
expression %e & ::= & %x | %n | %e <b>+</b> %e | %f <b>(</b> %e <b>)</b> \\
number %n & ::= & <i>any valid integer</i> \\
variable %f, %x & ::= & <i>any valid variable</i>\\
type \tau & ::= & <b style="color:firebrick">int</b> \\
             & | & <b style="color:firebrick">int \rightarrow int</b> \\
             & | & <b style="color:firebrick">void</b>
\end{eqnarray}
We can define a set of type inference rules for this language. These rules constitute the type system for the language.
        ]]></text>
        <inferences hooks="math">
          <inference title="Statement-Assign">
            <premises><![CDATA[
            \Gamma \uplus {%x \mapsto <b style="color:firebrick">int</b>} \vdash %p: <b style="color:firebrick">void</b> %~ %~ \Gamma \vdash %e: <b style="color:firebrick">int</b>
            ]]></premises>
            <conclusion><![CDATA[\Gamma \vdash %x <b>:=</b> %e <b>;</b> %p : <b style="color:firebrick">void</b>]]></conclusion>
          </inference>
          <inference title="Statement-Function">
            <premises><![CDATA[
            \Gamma \uplus {%f \mapsto <b style="color:firebrick">int \rightarrow int</b>} \vdash %p: <b style="color:firebrick">void</b> 
            %~ %~ \Gamma \uplus {%x \mapsto <b style="color:firebrick">int</b>} \vdash %e: <b style="color:firebrick">int</b>
            ]]></premises>
            <conclusion><![CDATA[
            \Gamma \vdash <b>function</b> %f <b>(</b> <b style="color:firebrick">int</b> %x <b>)</b> <b>{</b> <b>return</b> %e <b>;</b> <b>}</b> %p : <b style="color:firebrick">void</b>
            ]]></conclusion>
          </inference>
          <inference title="Statement-End">
           <premises><![CDATA[]]></premises>
            <conclusion><![CDATA[\Gamma \vdash <b style="color:gray;">end</b>: <b style="color:firebrick">void</b>]]></conclusion>
          </inference>
          <inference title="Term-Variable">
            <premises><![CDATA[\Gamma(%x) = <b style="color:firebrick">int</b>]]></premises>
            <conclusion><![CDATA[\Gamma \vdash <i>x</i>: <b style="color:firebrick">int</b>]]></conclusion>
          </inference>
          <inference title="Term-Number">
            <premises><![CDATA[]]></premises>
            <conclusion><![CDATA[\Gamma \vdash %n: <b style="color:firebrick">int</b>]]></conclusion>
          </inference>
          <inference title="Term-Plus">
            <premises><![CDATA[\Gamma \vdash %e_1: <b style="color:firebrick">int</b> %~ %~ \Gamma \vdash %e_2: <b style="color:firebrick">int</b>]]></premises>
            <conclusion><![CDATA[\Gamma \vdash %e_1 <b>+</b> %e_2: <b style="color:firebrick">int</b>]]></conclusion>
          </inference>
          <inference title="Term-Apply">
            <premises><![CDATA[\Gamma(%f) = <b style="color:firebrick">int \rightarrow int</b> %~ %~ \Gamma \vdash %e: <b style="color:firebrick">int</b>]]></premises>
            <conclusion><![CDATA[\Gamma \vdash %f <b>(</b> %e <b>)</b>: <b style="color:firebrick">int</b>]]></conclusion>
          </inference>
        </inferences>
        <text hooks="math"><![CDATA[
Before implementing a type checking algorithm, suppose we want to implement an interpreter for this language. Below is an example of how it might be implemented.
        ]]></text>
        <code hooks="Python"><![CDATA[
@def evaluate(env, e):
   @if @type(e) == Node:
        @for label @in e:
            children = e[label]
            @if label == 'Number':
                n = children[0]
                @return n
            @elif label == 'Plus':
                [e1,e2] = children
                @return evaluate(env, e1) + evaluate(env, e2)
            @elif label == 'Variable':
                x = children[0]
                value = env[x]
                @return value
            @elif label == 'Apply':
                 [f, eArg] = children
                 f = f['Variable'][0] # Unpack.
                 x = env[f]['Function'][2]['Variable'][0]
                 eBody = env[f]['Function'][3] # Body.
                 vArg = evaluate(env, eArg)
                 envF = env.copy()
                 envF[x] = vArg
                 vResult = evaluate(envF, eBody)
                 @return vResult
        
@def execute(env, s):
    @if @type(s) == Leaf:
        @if s == 'End':
            @return (env, [])
    @elif type(s) == Node:
        @for label @in s:
            @if label == 'Assign':
                [var, e, p] = s[label]
                x = var['Variable'][0]
                env[x] = evaluate(env, e)
                (env, o) = execute(env, p)
                @return (env, o)
            @if label == 'Function':
                [f, ty, x, e, p] = s[label]
                f = f['Variable'][0] # Unpack.
                env[f] = s
                (env, o) = execute(env, p)
                @return (env, o)
        ]]></code> 
        <text hooks="math"><![CDATA[
A type checking algorithm implementation is presented below.
        ]]></text>
        <code hooks="Python"><![CDATA[
@def tyExpr(env, e):
   @if @type(e) == Node:
        @for label @in e:
            children = e[label]
            @if label == 'Number':
                @return 'TyInt'
            @elif label == 'Variable':
                x = children[0]
                @return env[x]
            @elif label == 'Apply':
                 [f, eArg] = children
                 f = f['Variable'][0] # Unpack.
                 tyArg = tyExpr(env, eArg)
                 tyFunArg = env[f]['Arrow'][0]
                 @if tyArg == tyFunArg:
                     @return env[f]['Arrow'][1]
        
@def tyProg(env, s):
   @if @type(s) == Leaf:
        @if s == 'End':
            @return 'Void'
   @elif type(s) == Node:
        @for label @in s:
            @if label == 'Assign':
                [x,e,p] = s[label]
                x = x['Variable'][0] # Unpack.
                tExpr = tyExpr(env, e)
                env[x] = tExpr
                tProg = tyProg(env, p)
                @if tExpr == 'TyInt' @and tProg == 'Void':
                    @return 'Void'
            @if label == 'Function':
                [f, tyArg, x, e, p] = s[label]
                name = f['Variable'][0]
                x = x['Variable'][0]
                envF = env.copy()
                envF[x] = 'TyInt'
                tBody = tyExpr(envF, e)
                env[name] = {'Arrow':[tyArg,tBody]}
                tProg = tyProg(env, p)                  
                @return tProg
        ]]></code>
      </example>
      <example required="true" id="f7d61e6c2fe211e38cf6ce3f5508acd9">
        <text hooks="math"><![CDATA[
Suppose we are working with a programming language that supports the definition of functions that take a single string argument. The type system of this language supports explicit tracking of the sizes of strings.
\begin{eqnarray}
program %p & ::= & <b>function</b> %f <b>(</b> <b style="color:firebrick">string[</b>%k<b style="color:firebrick">]</b> %x <b>)</b> <b>{</b> <b>return</b> %e <b>;</b> <b>}</b> %p \\
               & | & %x <b>:=</b> %e <b>;</b> %p \\
               & | & \\
expression %e & ::= & %x | %s | %e <b>+</b> %e | %f <b>(</b> %e <b>)</b> \\
string %s & ::= & <i>any valid string literal</i> \\
variable %f, %x & ::= & <i>any valid variable</i>\\
type \tau & ::= & <b style="color:firebrick">string[</b>%k<b style="color:firebrick">]</b> \\
             & | & <b style="color:firebrick">string[</b>%k<b style="color:firebrick">] \rightarrow string</b><b style="color:firebrick">[</b>%k<b style="color:firebrick">]</b> \\
             & | & <b style="color:firebrick">void</b> \\
type size %k & ::= & <i>any valid integer</i> \\
             & | & %k <b>+</b> %k \\
\end{eqnarray}
We can define a set of type inference rules for this language. These rules constitute the type system for the language.
        ]]></text>
        <inferences hooks="math">
          <inference title="Statement-Assign">
            <premises><![CDATA[
            \Gamma \uplus {%x \mapsto <b style="color:firebrick">string[</b>%k<b style="color:firebrick">]</b>} \vdash %p: <b style="color:firebrick">void</b> 
            %~ %~ \Gamma \vdash %e: <b style="color:firebrick">string[</b>%k<b style="color:firebrick">]</b>
            ]]></premises>
            <conclusion><![CDATA[\Gamma \vdash %x <b>:=</b> %e <b>;</b> %p : <b style="color:firebrick">void</b>]]></conclusion>
          </inference>
          <inference title="Statement-Function">
            <premises><![CDATA[
            \Gamma \uplus {%f \mapsto <b style="color:firebrick">string[</b>%k_1<b style="color:firebrick">]</b> <b>\rightarrow</b> <b style="color:firebrick">string[</b>%k_2<b style="color:firebrick">]</b>} \vdash %p: <b style="color:firebrick">void</b> 
            %~ %~ \Gamma \uplus {%x \mapsto <b style="color:firebrick">string[</b>%k_1<b style="color:firebrick">]</b>} \vdash %e: <b style="color:firebrick">string[</b>%k_2<b style="color:firebrick">]</b>
            ]]></premises>
            <conclusion><![CDATA[\Gamma \vdash <b>function</b> %f <b>(</b> <b style="color:firebrick">string[</b>%k_1<b style="color:firebrick">]</b> %x <b>)</b> <b>{</b> <b>return</b> %e <b>;</b> <b>}</b> %p : <b style="color:firebrick">void</b>]]></conclusion>
          </inference>
          <inference title="Statement-End">
           <premises><![CDATA[]]></premises>
            <conclusion><![CDATA[\Gamma \vdash <b style="color:gray;">end</b>: <b style="color:firebrick">void</b>]]></conclusion>
          </inference>
          <inference title="Term-Variable">
            <premises><![CDATA[\Gamma(%x) = <b style="color:firebrick">string[</b>%k<b style="color:firebrick">]</b>]]></premises>
            <conclusion><![CDATA[\Gamma \vdash <i>x</i>: <b style="color:firebrick">string[</b>%k<b style="color:firebrick">]</b>]]></conclusion>
          </inference>
          <inference title="Term-Number">
            <premises><![CDATA[|%s| = %k]]></premises>
            <conclusion><![CDATA[\Gamma \vdash %s: <b style="color:firebrick">string[</b>%k<b style="color:firebrick">]</b>]]></conclusion>
          </inference>
          <inference title="Term-Concat">
            <premises><![CDATA[
            \Gamma \vdash %e_1: <b style="color:firebrick">string[</b>%k_1<b style="color:firebrick">]</b> 
            %~ %~ \Gamma \vdash %e_2: <b style="color:firebrick">string[</b>%k_2<b style="color:firebrick">]</b>
            ]]></premises>
            <conclusion><![CDATA[\Gamma \vdash %e_1 <b>+</b> %e_2: <b style="color:firebrick">string[</b>%k_1<b>+</b>%k_2<b style="color:firebrick">]</b>]]></conclusion>
          </inference>
          <inference title="Term-Apply">
            <premises><![CDATA[
            \Gamma(%f) = <b style="color:firebrick">string[</b>%k_1<b style="color:firebrick">]</b> <b>\rightarrow</b> <b style="color:firebrick">string[</b>%k_2<b style="color:firebrick">]</b> 
            %~ %~ \Gamma \vdash %e: <b style="color:firebrick">string[</b>%k_1<b style="color:firebrick">]</b>]]></premises>
            <conclusion><![CDATA[
            \Gamma \vdash %f <b style="color:firebrick">(</b> %e <b style="color:firebrick">)</b>: <b style="color:firebrick">string[</b>%k_2<b style="color:firebrick">]</b>
            ]]></conclusion>
          </inference>
        </inferences>
      </example>
    </subsection>
    <subsection title="Abstract interpretation">
      <text><![CDATA[
An <i>abstract interpretation</i> algorithm is a specific kind of interpreter for a programming language: it must always terminate (and, typically, it must run quickly), and it typically provides information about the given program along some dimension of interest (i.e., not the value(s) it produces).
      ]]></text>
      <example required="true" id="f7d60ab22fe211e38cf6ce3f5508acd9">
        <text hooks="math"><![CDATA[
Suppose we are working with a simple general-purpose programming language with the following abstract syntax.
\begin{eqnarray}
program %p & ::= & <b>print</b> %e <b>;</b> %p \\
               & | & <b>for</b> <i>x</i> <b>to</b> <i>n</i> <b>{</b> <i>p</i> <b>}</b> <i>p</i> \\
               & | & <b>procedure</b> <i>x</i> <b>{</b> %p <b>}</b> <i>p</i> \\
               & | & <b>call</b> <i>x</i> <b>;</b> <i>p</i> \\
               & | & \\
expression %e & ::= & %n | %e <b>*</b> %e \\
number %n & ::= & <i>any valid integer</i> \\
variable %x & ::= & <i>any valid variable</i>\\
\end{eqnarray}
We want to define an abstract interpretation over the above language to a language that describes running times of programs. The language for running times has the following syntax:
\begin{eqnarray}
running time %t & ::= & <b style="color:firebrick;">%n</b>  | <b style="color:firebrick;">%t <b>+</b> %t</b> | <b style="color:firebrick;">%t <b>*</b> %t</b> | <b style="color:firebrick;"><b>(</b> %t <b>)</b> </b> 
\end{eqnarray}
We can define the following abstract interpretation of the language:
        ]]></text>
        <inferences hooks="math">
          <inference title="Expression-Number">
            <premises><![CDATA[]]></premises>
            <conclusion><![CDATA[\vdash %n : <b style="color:firebrick;">1</b>]]></conclusion>
          </inference>
          <inference title="Expression-Mult">
            <premises><![CDATA[\vdash %e_1: <b style="color:firebrick;">%t_1</b> %~ %~ \vdash %e_1: <b style="color:firebrick;">%t_2</b>]]></premises>
            <conclusion><![CDATA[\vdash %e_1 <b>*</b> %e_2: <b style="color:firebrick;">%t_1 + %t_2</b>]]></conclusion>
          </inference>
          <inference title="Statement-Print">
            <premises><![CDATA[\Gamma \vdash %p: <b style="color:firebrick;">%t_1</b> %~ %~ \vdash %e: <b style="color:firebrick;">%t_2</b>]]></premises>
            <conclusion><![CDATA[\Gamma \vdash <b>print</b> %e <b>;</b> %p : <b style="color:firebrick;">%t_1 + %t_2</b>]]></conclusion>
          </inference>
          <inference title="Statement-For">
            <premises><![CDATA[\Gamma \vdash %p_1: <b style="color:firebrick;">%t_1</b> %~ %~ \Gamma \vdash %p_2: <b style="color:firebrick;">%t_2</b>]]></premises>
            <conclusion><![CDATA[\Gamma \vdash <b>for</b> %x <b>to</b> %n <b>{</b> %p_1 <b>}</b> %p_2 : <b style="color:firebrick;">(%n * %t_1) + %t_2</b>]]></conclusion>
          </inference>
          <inference title="Statement-Procedure">
            <premises><![CDATA[\Gamma \vdash %p_1: <b style="color:firebrick;">%t_1</b> %~ %~ \Gamma \uplus {%x \mapsto <b style="color:firebrick;">%t_1</b>} \vdash %p_2: <b style="color:firebrick;">%t_2</b>]]></premises>
            <conclusion><![CDATA[\Gamma \vdash <b>procedure</b> <b>{</b> %p_1 <b>}</b> %p_2 : <b style="color:firebrick;">%t_2</b>]]></conclusion>
          </inference>
          <inference title="Statement-Call">
            <premises><![CDATA[\Gamma(%x) = <b style="color:firebrick;">%t_2</b> %~ %~ \Gamma \vdash %p: <b style="color:firebrick;">%t_1</b>]]></premises>
            <conclusion><![CDATA[\Gamma \vdash <b>call</b> %x <b>;</b> %p : <b style="color:firebrick;">%t_1 + %t_2</b>]]></conclusion>
          </inference>
          <inference title="Statement-End">
            <premises><![CDATA[]]></premises>
            <conclusion><![CDATA[\Gamma \vdash <b style="color:gray;">end</b> : <b style="color:firebrick;">0</b>]]></conclusion>
          </inference>
        </inferences>
        <text hooks="math"><![CDATA[
We can implement the above inference rules as an abstract interpretation algorithm.
        ]]></text>
        <code hooks="Python"><![CDATA[
@def timeExpr(e):
    @if type(e) == Node:
        @for label @in e:
            children = e[label]
            @if label == 'Number':
                @return 1
            @elif label == 'Mult':
                [e1,e2] = children
                @return timeExpr(e1) + timeExpr(e2)

@def timeProg(env, s):
    @if @type(s) == Leaf:
        @if s == 'End':
            @return 0
    @elif type(s) == Node:
        @for label @in s:
            @if label == 'Print':
                [e,p] = s[label]
                @return timeExpr(e) + timeProg(env, p)
            @if label == 'For':
                [var, num, p1, p2] = s[label]
                n = num['Number'][0]
                @return n * timeProg(env, p1) + timeProg(env, p2)

                # ...
        ]]></code>
      </example>
      <example required="true" id="f7d60d822fe211e38cf6ce3f5508acd9">
        <text hooks="math"><![CDATA[
Suppose we are working with a simple programming language for reserving cloud computing resources with the following abstract syntax.
\begin{eqnarray}
program %p & ::= & <b>reserve</b> %d <b>;</b> %p \\
           & | & <b>for</b> <i>x</i> <b>to</b> <i>n</i> <b>{</b> <i>p</i> <b>}</b> <i>p</i> \\
           & | & <b>procedure</b> <i>x</i> <b>{</b> %p <b>}</b> <i>p</i> \\
           & | & <b>call</b> <i>x</i> <b>;</b> <i>p</i> \\
           & | & \\
duration %d & ::= & %n <b>minutes</b> \\
            & | & %n <b>hours</b> \\
            & | & %n <b>days</b> \\
number %n & ::= & <i>any valid integer</i> \\
fixed-point real number %r & ::= & <i>any valid real number</i> \\
variable %x & ::= & <i>any valid variable</i>\\
\end{eqnarray}
We want to define an abstract interpretation over the above language to a language that describes the monetary (i.e., dollar) cost of running a program. The language for costs has the following syntax:
\begin{eqnarray}
cost %c & ::= & <b style="color:firebrick;">$%r</b> | <b style="color:firebrick;">%c <b>+</b> %c</b> | <b style="color:firebrick;">%n <b>*</b> %c</b> | <b style="color:firebrick;"><b>(</b> %c <b>)</b> </b> 
\end{eqnarray}
Suppose that a single <b>reserve</b> %d <b>;</b> statement reserves a distinct computing resources for the duration specified, and that the cost of any resource is always $0.60 per hour. We can define the following abstract interpretation of the language:
        ]]></text>
        <inferences hooks="math">
          <inference title="Duration-Minutes">
            <premises><![CDATA[]]></premises>
            <conclusion><![CDATA[\vdash %n <b>minutes</b> : <b style="color:firebrick;">%n \cdot $0.01</b>]]></conclusion>
          </inference>
          <inference title="Duration-Hours">
            <premises><![CDATA[]]></premises>
            <conclusion><![CDATA[\vdash %n <b>hours</b> : <b style="color:firebrick;">%n \cdot $0.60</b>]]></conclusion>
          </inference>
          <inference title="Duration-Days">
            <premises><![CDATA[]]></premises>
            <conclusion><![CDATA[\vdash %n <b>days</b> : <b style="color:firebrick;">%n \cdot $14.40</b>]]></conclusion>
          </inference>
          <inference title="Statement-Reserve">
            <premises><![CDATA[\vdash %d: <b style="color:firebrick;">%c_1</b> %~ %~ \Gamma \vdash %p: <b style="color:firebrick;">%c_2</b>]]></premises>
            <conclusion><![CDATA[\Gamma \vdash <b>reserve</b> %d <b>;</b> %p : <b style="color:firebrick;">%c_1 + %c_2</b>]]></conclusion>
          </inference>
          <inference title="Statement-For">
            <premises><![CDATA[\Gamma \vdash %p_1: <b style="color:firebrick;">%c_1</b> %~ %~ \Gamma \vdash %p_2: <b style="color:firebrick;">%c_2</b>]]></premises>
            <conclusion><![CDATA[\Gamma \vdash <b>for</b> %x <b>to</b> %n <b>{</b> %p_1 <b>}</b> %p_2 : <b style="color:firebrick;">(%n * %c_1) + %c_2</b>]]></conclusion>
          </inference>
          <inference title="Statement-Procedure">
            <premises><![CDATA[\Gamma \vdash %p_1: <b style="color:firebrick;">%c_1</b> %~ %~ \Gamma \uplus {%x \mapsto <b style="color:firebrick;">%c_1</b>} \vdash %p_2: <b style="color:firebrick;">%c_2</b>]]></premises>
            <conclusion><![CDATA[\Gamma \vdash <b>procedure</b> %x <b>{</b> %p_1 <b>}</b> %p_2 : <b style="color:firebrick;">%c_2</b>]]></conclusion>
          </inference>
          <inference title="Statement-Call">
            <premises><![CDATA[\Gamma(%x) = <b style="color:firebrick;">%c_2</b> %~ %~ \Gamma \vdash %p: <b style="color:firebrick;">%c_1</b>]]></premises>
            <conclusion><![CDATA[\Gamma \vdash <b>call</b> %x <b>;</b> %p : <b style="color:firebrick;">%c_1 + %c_2</b>]]></conclusion>
          </inference>
          <inference title="Statement-End">
            <premises><![CDATA[]]></premises>
            <conclusion><![CDATA[\Gamma \vdash <b style="color:gray;">end</b> : <b style="color:firebrick;">$0</b>]]></conclusion>
          </inference>
        </inferences>  
        <text hooks="math"><![CDATA[
We can implement the above inference rules as an abstract interpretation algorithm.
        ]]></text>
        <code hooks="Python"><![CDATA[
@def costDuration(e):
    @if @type(e) == Node:
        @for label @in e:
            children = e[label]
            @if label == 'Minutes':
                [num] = children
                n = num['Number'][0]
                @return n * 0.01
            @if label == 'Hours':
                [num] = children
                n = num['Number'][0]
                @return n * 0.60
            @if label == 'Days':
                [num] = children
                n = num['Number'][0]
                @return n * 14.40

@def costProg(env, s):
    @if @type(s) == Leaf:
        @if s == 'End':
            @return 0
    @elif @type(s) == Node:
        for label in s:
            @if label == 'Reserve':
                [d,p] = s[label]
                 @return costDuration(d) + costProg(env, p)
            @if label == 'For':
                [var, num, p1, p2] = s[label]
                n = num['Number'][0]
                @return n * costProg(env, p1) + costProg(env, p2)

            # ...
        ]]></code>
      </example>
      <example required="true" id="77cacf72f11440bcb8a949bb2a872cce">
        <text hooks="math"><![CDATA[
Suppose we are working with a simple programming language in which the type system tracks whether values are secret or public.
\begin{eqnarray}
program %p & ::= & <b>print</b> %e <b>;</b> %p \\
            & | & <b>secret</b> <i>x</i> <b>:=</b> %e <b>;</b> <i>p</i> \\
            & | & <b>public</b> <i>x</i> <b>:=</b> %e <b>;</b> <i>p</i> \\
            & | & \\
expression %e & ::= & %n | %x | %e <b>+</b> %e \\
number %n & ::= & <i>any valid integer</i> \\
variable %x & ::= & <i>any valid variable</i>\\
\end{eqnarray}
We want to define an abstract interpretation over the above language to a language that describes running times of programs. The language for running times has the following syntax:
\begin{eqnarray}
visibility %t & ::= & <b style="color:firebrick;">secret</b>  | <b style="color:firebrick;">public</b> | <b style="color:firebrick">void</b>
\end{eqnarray}
We can define the following abstract interpretation of the language:
        ]]></text>
        <inferences hooks="math">
          <inference title="Statement-Assign-Secret">
            <premises><![CDATA[
            \Gamma \uplus {%x \mapsto <b style="color:firebrick">secret</b>} \vdash %p: <b style="color:firebrick">void</b> 
            %~ %~ \Gamma \vdash %e: <b style="color:firebrick">secret</b>
            ]]></premises>
            <conclusion><![CDATA[\Gamma \vdash <b>secret</b> %x <b>:=</b> %e <b>;</b> %p : <b style="color:firebrick">void</b>]]></conclusion>
          </inference>
          <inference title="Statement-Assign-Public">
            <premises><![CDATA[
            \Gamma \uplus {%x \mapsto <b style="color:firebrick">public</b>} \vdash %p: <b style="color:firebrick">void</b> 
            %~ %~ \Gamma \vdash %e: <b style="color:firebrick">public</b>
            ]]></premises>
            <conclusion><![CDATA[\Gamma \vdash <b>public</b> %x <b>:=</b> %e <b>;</b> %p : <b style="color:firebrick">void</b>]]></conclusion>
          </inference>
          <inference title="Statement-Print">
            <premises><![CDATA[
            \Gamma \vdash %p: <b style="color:firebrick">void</b> 
            %~ %~ \Gamma \vdash %e: <b style="color:firebrick">public</b>
            ]]></premises>
            <conclusion><![CDATA[\Gamma \vdash <b>print</b> %e <b>;</b> %p : <b style="color:firebrick">void</b>]]></conclusion>
          </inference>
          <inference title="Expression-Variable">
            <premises><![CDATA[\Gamma(%x) = \tau]]></premises>
            <conclusion><![CDATA[\Gamma \vdash <i>x</i>: \tau]]></conclusion>
          </inference>
          <inference title="Expression-Number-Secret">
            <premises><![CDATA[]]></premises>
            <conclusion><![CDATA[\Gamma \vdash %n: <b style="color:firebrick">secret</b>]]></conclusion>
          </inference>
          <inference title="Expression-Number-Public">
            <premises><![CDATA[]]></premises>
            <conclusion><![CDATA[\Gamma \vdash %n: <b style="color:firebrick">public</b>]]></conclusion>
          </inference>
          <inference title="Expression-Plus-Secret-Secret">
            <premises><![CDATA[\Gamma \vdash %e_1: <b style="color:firebrick">secret</b> %~ %~ \Gamma \vdash %e_2: <b style="color:firebrick">secret</b>]]></premises>
            <conclusion><![CDATA[\Gamma \vdash %e_1 <b>+</b> %e_2: <b style="color:firebrick">secret</b>]]></conclusion>
          </inference>
          <inference title="Expression-Plus-Secret-Public">
            <premises><![CDATA[\Gamma \vdash %e_1: <b style="color:firebrick">secret</b> %~ %~ \Gamma \vdash %e_2: <b style="color:firebrick">public</b>]]></premises>
            <conclusion><![CDATA[\Gamma \vdash %e_1 <b>+</b> %e_2: <b style="color:firebrick">secret</b>]]></conclusion>
          </inference>
          <inference title="Expression-Plus-Public-Secret">
            <premises><![CDATA[\Gamma \vdash %e_1: <b style="color:firebrick">public</b> %~ %~ \Gamma \vdash %e_2: <b style="color:firebrick">secret</b>]]></premises>
            <conclusion><![CDATA[\Gamma \vdash %e_1 <b>+</b> %e_2: <b style="color:firebrick">secret</b>]]></conclusion>
          </inference>
          <inference title="Expression-Plus-Public-Public">
            <premises><![CDATA[\Gamma \vdash %e_1: <b style="color:firebrick">public</b> %~ %~ \Gamma \vdash %e_2: <b style="color:firebrick">public</b>]]></premises>
            <conclusion><![CDATA[\Gamma \vdash %e_1 <b>+</b> %e_2: <b style="color:firebrick">public</b>]]></conclusion>
          </inference>
        </inferences>
      </example>
    </subsection>
  </section>
  <midterm title="Programming Languages, Interpreters, and Compilers">
    <instructions>
      <text><![CDATA[<i>This material is no longer available.</i>]]></text>
    </instructions>
  </midterm>
  <section title="Declarative (and Functional) Programming Language Paradigms">
    <text hooks="math"><![CDATA[
In this section we introduce the notion of a programming language paradigm, define several major programming language paradigms, and discuss which paradigms are supported by some widely used modern programming languages (in practice, many languages support more than one paradigm). We assume the reader is already at least somewhat familiar with the imperative and object-oriented programming paradigms; thus, we study in detail the <i>declarative</i> programming paradigm (including an important subset, <i>functional</i> programming).
    ]]></text>
    <subsection title="Programming language paradigms">
      <text hooks="math"><![CDATA[
A programming language's <i>programming paradigm</i> is the collection of abstractions, tools, and techniques it makes available to a programmer. While <a href="http://en.wikipedia.org/wiki/Programming_paradigm">there is some disagreement</a> about what exactly constitutes a programming paradigm and how programming paradigms can be distinguished and categorized, there is wide agreement that at least a few distinct, widely-employed programming paradigms exist. We can enumerate these paradigms, and we can list the programming language features (i.e., abstractions) that can be used to identify and distinguish between them:
      ]]></text>
      <unorderedlist>
        <item><![CDATA[<b>imperative programming:</b>]]>
          <unorderedlist>
            <item>mutable state and side effects:
              <unorderedlist>
                <item>indexed memory regions;</item>
                <item>named, mutable variables;</item>
                <item>ability to interact with other "external" devices (video card, network, etc.); </item>
              </unorderedlist>
            </item>
            <item>sequential execution of statements:
              <unorderedlist>
                <item>one operation per time step (control flow);</item>
                <item>branching and loops (direction of control flow);</item>
              </unorderedlist>
            </item>
            <item><![CDATA[<b><i>procedural programming:</i></b>]]>
              <unorderedlist>
                <item>definition and invocation of named procedures;</item>
              </unorderedlist>
            </item>
            <item>parallelism achieved with forking, threads, and message passing;</item>
          </unorderedlist>
        </item>
        <item><![CDATA[<b>object-oriented programming:</b>]]>
          <unorderedlist>
            <item>data and methods organized into objects;</item>
            <item>multiple instances of objects interacting via method calls:
              <unorderedlist>
                <item>event handling;</item>
              </unorderedlist>
            </item>
            <item>enforcement of encapsulation and modularity;</item>
          </unorderedlist>
        </item>
        <item><![CDATA[<b>declarative programming:</b>]]>
          <unorderedlist>
            <item>static, immutable descriptions of data, models, or problems:
              <unorderedlist>
                <item>user-defined data types:
                  <unorderedlist>
                    <item>algebraic data types;</item>
                  </unorderedlist>
                </item>
                <item>type checking/inference.</item>
              </unorderedlist>
            </item>
            <item>query sublanguage for examining/exploring static descriptions;</item>
            <item><![CDATA[<b><i>functional programming:</i></b>]]>
              <unorderedlist>
                <item>referential transparency;</item>
                <item>support for pattern matching/unification;</item>
                <item><![CDATA[functions as values (<i><a href="http://en.wikipedia.org/wiki/First-class_function">first-class functions</a></i> and <i><a href="http://en.wikipedia.org/wiki/Higher-order_functions">higher-order functions</a></i>).]]></item>
              </unorderedlist>
            </item>
          </unorderedlist>
        </item>
      </unorderedlist>
      <text hooks="math"><![CDATA[
Mathematically, it is possible to identify which paradigms are supported by a programming language by examining its operational semantics. We have already seen many examples of an operational semantics for an imperative language (such as <a href="#cbfa02d3624d42b08704d6a4c4fb9e03">this one</a> and <a href="#c09ab939e50b40428d392867c00b4710">this one</a>).
<br/><br/>
As a result of both historical trends and of practical necessity, most widely-used programming languages support multiple programming paradigms:
<br/><br/>
<table class="fig_table" style="font-size:10px; font-family:Arial,sans-serif;">
 <tr>
  <td></td>
  <td><b>imperative</b></td>
  <td><b>procedural</b></td>
  <td><b>object-<br/>oriented</b></td>
  <td><b>declarative</b></td>
  <td><b>functional</b></td>
  <td style="padding:0px;"></td>
  <td><b>static type<br/>checking</b></td>
  <td><b>garbage<br/>collection</b></td>
  <td><b>side<br/>effects</b></td>
 </tr>
 <tr> 
  <td><b>machine<br/>languages</b></td>
  <td style="background-color:lightyellow;">some support<br/>(indexed<br/>memory,<br/>branching)</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="padding:0px;"></td>
  <td>none</td>
  <td>no</td>
  <td>yes</td>
 </tr>
 <tr> 
  <td><b>FORTRAN<br/>(initial<br/>release)</b></td>
  <td style="background-color:palegreen; border:3px dashed green;">full support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="padding:0px;"></td>
  <td>very<br/>limited</td>
  <td>no</td>
  <td>yes</td>
 </tr>
 <tr> 
  <td><b>C</b></td>
  <td style="background-color:palegreen; border:3px dashed green;">full support</td>
  <td style="background-color:palegreen; border:3px dashed green;">full support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:lightyellow;">some support<br/>(function pointers)</td>
  <td style="padding:0px;"></td>
  <td>very<br/>limited</td>
  <td>no</td>
  <td>yes</td>
 </tr>
 <tr> 
  <td><b>C++</b></td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen; border:3px dashed green;">full support</td>
  <td style="background-color:lightyellow;">class declarations,<br/>some type checking</td>
  <td style="background-color:lightyellow;">function pointers<br/>and some extensions<br/>(e.g., <a href="http://en.wikipedia.org/wiki/Standard_Template_Library">STL</a>)</td>
  <td style="padding:0px;"></td>
  <td>limited</td>
  <td>no</td>
  <td>yes</td>
 </tr>
 <tr> 
  <td><b>Java</b></td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen; border:3px dashed green;">full support</td>
  <td style="background-color:lightyellow;">type system,<br/>class declarations,<br/>abstract classes,<br/>interfaces,<br/>type checking,<br/>and type inference</td>
  <td style="background-color:lightyellow;">generics, interfaces,<br/>objects as wrappers,<br/> anonymous classes</td>
  <td style="padding:0px;"></td>
  <td style="border:3px dashed green;">extensive</td>
  <td style="border:3px dashed green;">yes</td>
  <td>yes</td>
 </tr>
 <tr> 
  <td><b>PHP</b></td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:lightyellow;">some support</td>
  <td style="padding:0px;"></td>
  <td>none</td>
  <td>yes<br/>(\geq 5.3)</td>
  <td>yes</td>
 </tr>
 <tr> 
  <td><b>Python</b></td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="padding:0px;"></td>
  <td>none</td>
  <td>yes</td>
  <td>yes</td>
 </tr>
 <tr> 
  <td><b>JavaScript</b></td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="padding:0px;"></td>
  <td>none</td>
  <td>yes</td>
  <td>yes</td>
 </tr>
 <tr> 
  <td><b>Haskell</b></td>
  <td style="background-color:lightcyan;">meta-support<br/>(monads)</td>
  <td style="background-color:lightcyan;">meta-support<br/>(functions)</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:palegreen;">full support</td>
  <td style="background-color:palegreen; border:3px dashed green;">full support</td>
  <td style="padding:0px;"></td>
  <td style="border:3px dashed green;">extensive</td>
  <td>yes</td>
  <td>some<br/>(IO<br/>monads)</td>
 </tr>
 <tr> 
  <td><b>SQL</b></td>
  <td style="background-color:lightyellow;">some support<br/>(insertion/<br/>deletion;<br/>sequences of<br/>statements in<br/>versions<br/>like MS-SQL)</td>
  <td style="background-color:lightyellow;">some support<br/>(procedures in<br/>versions<br/>like MS-SQL)</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:palegreen; border:3px dashed green;">full support<br/>(definition of<br/>schemas and<br/>tables; ability<br/>to evaluate<br/>queries over<br/>tables)</td>
  <td style="background-color:lightyellow;">some support<br/>(custom map and<br/>aggregation<br/>procedures in<br/>MS-SQL)</td>
  <td style="padding:0px;"></td>
  <td>some</td>
  <td>yes</td>
  <td>some</td>
 </tr>
 <tr> 
  <td><b>Amazon<br/>Web<br/>Services<br/>APIs</b></td>
  <td style="background-color:lightyellow;">some support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:mistyrose;">no support</td>
  <td style="background-color:lightyellow;">some support</td>
  <td style="background-color:lightyellow;">some support</td>
  <td style="padding:0px;"></td>
  <td>none</td>
  <td>n/a</td>
  <td>yes</td>
 </tr>
</table>
<br/>
While most languagues support many paradigms in practice, there is often a historically predominant paradigm that distinguished that programming language at the time it was introduced, that is supported natively by the programming language (i.e., without special extensions, libraries, or idioms), and that is employed by the communities of programmers who use that language. In the above, the paradigm most closely identified with each language is indicated with a dark green outline.
<br/><br/>
A note about the above chart: when it comes to <i>domain-specific</i> languages that have a very narrow purpose (such as the Amazon Web Services API) and are not meant to be general-purpose programming languages, support of a paradigm does not imply that the language supports that paradigm in general; instead, it means the language supports that paradigm insofar as it applies to that particular application domain.
      ]]></text>
    </subsection>
    <subsection title="Substitution and unification">
      <text hooks="math"><![CDATA[
In this course, we will focus on the declarative (and functional) programming language Haskell. The Haskell syntax and operational semantics natively support <i>unification</i> in multiple ways (specifically, <i>pattern matching</i> within expressions and <i>polymorphism</i> within the type system). Unification is a general concept that is applied in some form in all areas of mathematics and computer science. In this subsection, we will define unification.
      ]]></text>
      <definition required="true" hooks="math" id="f7d600442fe211e38cf6ce3f5508acd9"><![CDATA[
Given a set of variables %X and an abstract syntax %A (i.e., a set of abstract syntax trees), a <i>substitution</i> \sigma is a mapping from variables names in %X to abstract syntax trees in %A. Given an abstract syntax tree %a \in %A, we denote the result of substituting all the variables in %a according to \sigma using the notation \sigma(%a).
      ]]></definition>
      <text hooks="math"><![CDATA[
You'll notice that we use the same mathematical object to represent both <a href="#e1a5053a93d54ad4b02da10e4981b810">environments</a> (a.k.a., contexts) and substitutions. Thus, we will use the same notation for representing manipulations involving substitutions.
<ul>
  <li>In this course, we will usually denote a substitution using the symbol \sigma.</li>
  <li>Given a variable name %x \in %X, we denote by \sigma(%x) the abstract syntax tree that the environment \sigma assigns to %x.</li>
  <li>An empty substitution (one that does not map any variable names to any abstract syntax trees) is denoted using \sigma_0.</li>
  <li>We use the notation \dom(\sigma) to represent the set of variables that \sigma maps to abstract syntax trees.</li>
  <li>Given two substitutions \sigma_1 and \sigma_2 such that \dom(\sigma_1) \cap \dom(\sigma_2) = \emptyset (i.e., the two substitutions do not overlap or conflict on any variables), we denote by \sigma_1 \uplus \sigma_2 the substitution that can be obtained by combining the two individual substitutions. Thus, \dom(\sigma_1 \uplus \sigma_2) = \dom(\sigma_1) \cup \dom(\sigma_2).</li>
</ul>
      ]]></text>
      <example required="true" hooks="math" id="f7d622362fe211e38cf6ce3f5508acd9"><![CDATA[
Suppose we have the following abstract syntax (here, <b>node</b> is an infix operator for building tree nodes):
\begin{eqnarray}
tree %t & ::= & <b>leaf</b> | %x | %t <b>node</b> %t \\
variable %x & ::= & <i>any valid variable</i>
\end{eqnarray}
Suppose we are given the following substitution, which maps the variable %u to the tree <b>leaf</b> and the variable %v to the tree <b>leaf</b> <b>node</b> <b>leaf</b>:
\begin{eqnarray}
\sigma & = & { %u \mapsto <b>leaf</b>, %v \mapsto <b>leaf</b> <b>node</b> <b>leaf</b> }
\end{eqnarray}
Applying the above substitution to a tree that does not contain any variable nodes %u or %v has no effect:
\begin{eqnarray}
\sigma(<b>leaf</b>) & = & <b>leaf</b>
\end{eqnarray}
Applying the substitution to a tree containing the variables %u and/or %v would result in those variables being replaced by the corresponding tree inside \sigma (we add parentheses to the result for legibility):
\begin{eqnarray}
\sigma(%u <b>node</b> %v) & = & (<b>leaf</b>) <b>node</b> (<b>leaf</b> <b>node</b> <b>leaf</b>)
\end{eqnarray}
      ]]></example>      
      <definition required="true" hooks="math" id="f7d624202fe211e38cf6ce3f5508acd9"><![CDATA[
Given an abstract syntax %A and two abstract syntax trees %a, %b \in %A, we say that a substitution \sigma <i>unifies</i> %a and %b if the following equation holds:
\begin{eqnarray}
  \sigma(%a) & = & \sigma(%b)
\end{eqnarray}
That is, applying the substitution to both trees produces exactly the same tree. The process of calculating the <i>smallest</i> \sigma that guarantees the above equality is called <i>unification</i>.
      ]]></definition>
      <text hooks="math"><![CDATA[
For those familiar with the concept of a <a href="http://en.wikipedia.org/wiki/Magma_(algebra)">magma</a>, unification corresponds to the process of solving equations on magmas (or, more generally, any algebraic structure without any reduction or cancellation laws).
      ]]></text>
      <fact required="true" hooks="math" id="8dac853e5f3f4f7f88f351fe4e6673aa"><![CDATA[
Suppose we are given an abstract syntax %A and two abstract syntax trees %a, %b \in %A that contain no variables. If %a = %b, then it is true that for all \sigma (including \sigma_0):
\begin{eqnarray}
  \sigma(%a) & = & \sigma(%b)
\end{eqnarray}
If %a \neq %b, then it is true that for all \sigma:
\begin{eqnarray}
  \sigma(%a) & \neq & \sigma(%b)
\end{eqnarray}
      ]]></fact>
      <example required="true" hooks="math" id="3178040e0e304dea97da80368c7741b5"><![CDATA[
Suppose we have the following abstract syntax:
\begin{eqnarray}
%m & ::= & <b>object</b> | %x | %m <b>\oplus</b> %m | %m <b>\otimes</b> %m | <b>(</b> %m <b>)</b> \\
variable %x & ::= & <i>any valid variable</i>
\end{eqnarray}
Unify the following two abstract syntax trees, if possible (i.e., solve the following equation):
\begin{eqnarray}
  <b>(</b>%z<b> \otimes object) \oplus</b> %x & = & <b>(object \otimes </b>%y<b>) \oplus (object \otimes object)</b>
\end{eqnarray}
We can proceed by breaking the problem down. Since the root nodes of both abstract syntax trees are \oplus, we can turn the above into two equations:
\begin{eqnarray}
  %z<b> \otimes object</b> & = & <b>object \otimes </b>%y  \\
  %x & = & <b>object \otimes object</b> \\
\end{eqnarray}
The first equation can be broken down further:
\begin{eqnarray}
  %z& = & <b>object</b>  \\
  <b>object</b> & = & %y \\
  %x & = & <b>object \otimes object</b> \\
\end{eqnarray}
At this point, we can build up the substitution using the above information:
\begin{eqnarray}
   \sigma & = & { %x \mapsto <b>object \otimes object</b>, %y \mapsto <b>object</b>, %z \mapsto <b>object</b> } \\
\end{eqnarray}
Thus, \sigma as defined above unifies the two sides of the equation; the equation has a solution.
      ]]></example>
      <text hooks="math"><![CDATA[
The equality algorithm on abstract syntax trees is a degenerate version of a unification algorithm in which substitutions must always remain empty. This algorithm is implemented natively within Python (we have been using it every time we checked whether two trees represented as nested dictionaries are equivalent using the <code>==</code> operator), and Haskell supports the automatic derivation of this algorithm for any data type (using the <code>deriving Eq</code> directive).
      ]]></text>
      <algorithm required="true" title="equality" id="788d70ecb3ab4acaa98a9355657fca3d">
        <text hooks="math"><![CDATA[
The following algorithm can determine whether two trees are equivalent. 
<ol style="list-style-type:none;">
 <li><b>equal(<b>%a</b>, <b>%b</b>):</b> two abstract syntax trees %a and %b</li>
 <li>
   <ol style="list-style-type:none; margin-left:-20px;">
     <li><b>if</b> both %a <b>and</b> %b are leaf nodes and are equivalent
       <ol style="list-style-type:none; margin-left:-20px;">
         <li><b>return</b> <b>true</b></li>
       </ol>
     </li>
     <li><b>if</b> both %a and %b have the same label <b>and</b> the same number of children
       <ol style="list-style-type:none; margin-left:-20px;">
         <li>in order from left to right, check each pair of corresponding children of %a and %b for equality</li>
         <li><b>return</b> <b>true</b> if all the subtrees are equivalent</li>
         <li><b>return</b> <b>false</b> otherwise</li>
       </ol>
     </li>
   </ol>
 </li>
</ol>
        ]]></text>
      </algorithm>
      <algorithm required="true" title="pattern matching unification" id="95e800c8e74e4991a2ddb48668b544e0">
        <text hooks="math"><![CDATA[
Whether unification can be computed efficiently, or at all, depends on the subset of the abstract syntax from which inputs are drawn (i.e., it depends on what restrictions are placed on the abstract syntax trees that may need to be unified). The following algorithm, which we will call <i>pattern matching</i> unification, is guaranteed to terminate quickly (i.e., polynomial time) as long as at least one side of the equation contains no variables. It is guaranteed to quickly find a solution if it exists, as long as all variables occur exactly once.
<ol style="list-style-type:none;">
 <li><b>unify(<b>%a</b>, <b>%b</b>):</b> two abstract syntax trees %a and %b</li>
 <li>
   <ol style="list-style-type:none; margin-left:-20px;">
     <li><b>if</b> both %a <b>and</b> %b are leaf nodes and are equivalent
       <ol style="list-style-type:none; margin-left:-20px;">
         <li><b>return</b> the empty substitution \sigma_0</li>
       </ol>
     </li>
     <li><b>if</b> %a is a variable node representing a variable %x
       <ol style="list-style-type:none; margin-left:-20px;">
         <li><b>return</b> the substitution {%x \mapsto %b}</li>
       </ol>
     </li>
     <li><b>if</b> %b is a variable node representing a variable %x
       <ol style="list-style-type:none; margin-left:-20px;">
         <li><b>return</b> the substitution {%x \mapsto %a}</li>
       </ol>
     </li>
     <li><b>if</b> both %a and %b have the same label <b>and</b> the same number of children
       <ol style="list-style-type:none; margin-left:-20px;">
         <li>in order from left to right, unify each pair of corresponding children of %a and %b</li>
         <li>as long as they do not overlap on any variables, combine the substitutions obtained above</li>
         <li><b>return</b> the combined substitution</li>
       </ol>
     </li>
   </ol>
 </li>
</ol>
        ]]></text>
      </algorithm>
      <example required="true" hooks="math" id="8b5c8d33b508470088319ea3bb8db343">
        <text hooks="math"><![CDATA[
The Python operational semantics (and interpreter) employ a pattern matching unification algorithm in some cases. For example, it is possible to assign to arbitrarily deep tree of nested tuples.
        ]]></text>
        <code hooks="Python"><![CDATA[
>>> (a,(b,c),(d,(e,f),g)) = (1,(2,3),(4,(5,6),7))
>>> (a,b,c,d,e,f,g)
(1,2,3,4,5,6,7)
        ]]></code>
      </example>
    </subsection>
    <subsection title="Declarative programming languages">
      <text hooks="math"><![CDATA[
Any programming language that allows users to provide a static, immutable description of data, a model, or a problem supports the declarative programming paradigm to at least some degree. For example, languages that allow users to specify types and relationships between those types (e.g., Haskell types, Java classes, and so on) support a declarative programming paradigm for types.
<br/><br/>
In this course we will focus on declarative languages that allow users to specify data types, relationships between data types, and pure mathematical functions over those data types. In particular, we will look at the Haskell programming language.
<br/><br/>
In order to define the operational semantics for a declarative language, we must slightly modify the way in which we define an operational semantics by extending the premises and conclusions with an additional parameter representing the data, model, or problem description. We will adopt the convention of calling this parameter %M. Thus, an intepreter for a declarative programming language first <i>builds</i> data, a model, or a problem description by parsing and collecting into a single structure all the declarations in a program. It then allows the user to <i>query</i> that structure.
<br/><br/>
In the Haskell programming language, a <i>module</i> is a collection of declarations (that can occur in any order) of variables, functions, and types. For example:
      ]]></text>
      <code hooks="Haskell"><![CDATA[
@module Example @where

c = 5;

g (0) = 0;
g (x) = f(x) + f(x);

f (x) = 2 * x + 1;
      ]]></code>
      <text hooks="math"><![CDATA[
A Haskell interpreter first assembles the module without performing any evaluation, and then allows users to make queries about that module. Queries take the form of expressions, and the response to a query is the evaluation of that expression with respect to the entire module (i.e., all the definitions in the module).
      ]]></text>
      <code hooks="Haskell"><![CDATA[
*> c + c
10
*> f(4)
9
      ]]></code>
      <text hooks="math"><![CDATA[
Haskell natively supports lists and tuples, and the evaluation algorithm employs the <a href="95e800c8e74e4991a2ddb48668b544e0">pattern matching unification</a> algorithm. Suppose we have the following module:
      ]]></text>
      <code hooks="Haskell"><![CDATA[
@module AnotherExample @where

f (-1) = 1;
f (0) = 0;
f (1) = -1;

(a,(b,(c,d),e)) = (1,(2,(3,4),5));

g([x,y,z]) = [z,y,x];
      ]]></code>
      <text hooks="math"><![CDATA[
We can query the above module as follows:
      ]]></text>
      <code hooks="Haskell"><![CDATA[
*> f(-1)
1
*> d
4
*> g([1,2,3])
[3,2,1]
      ]]></code>
    </subsection>
    <subsection title="Algebraic data types">
      <text hooks="math"><![CDATA[
Some declarative languages natively support abstract mathematical, logical, and algebraic structures such as BNF notation, abstract syntaxes, logical formulas and predicates, and inference rules. Haskell natively supports user-defined <i>algebraic data types</i>. An algebraic data type is effectively a user-defined abstract syntax; the Haskell syntax for defining algebraic data types corresponds closely to BNF notation. In the module below, we define an algebraic data type for representing binary trees.
      ]]></text>
      <code hooks="Haskell"><![CDATA[
@module Tree @where

@data Tree = Leaf | Node Tree Tree;
      ]]></code>
      <text hooks="math"><![CDATA[
Most Haskell interpreters and compilers support infix notation in data type definitions as well.
      ]]></text>
      <code hooks="Haskell"><![CDATA[
@data Tree = Leaf | Tree `Node` Tree;
      ]]></code>
      <text hooks="math"><![CDATA[
Once the above module is parsed and built, the user is allowed to construct instances of the <code>Tree</code> algebraic data type. However, in order to actually display instances of the data type, it is necessary to ask the Haskell interpreter to derive a definition of a <code>show</code> function automatically from the definition of the algebraic data type (something that is done implicitly in, for example, Python). Haskell requires that this be requested explicitly because it also allows users to define their own variants of such functions.
      ]]></text>
      <code hooks="Haskell"><![CDATA[
@module Tree @where

@data Tree = 
    Leaf 
  | Node Tree Tree 
  @deriving Show;
      ]]></code>
      <text hooks="math"><![CDATA[
We can now try building trees using this algebraic data type.
      ]]></text>
      <code hooks="Haskell"><![CDATA[
*> Leaf           -- We represented this using "Leaf" in Python.
Leaf

*> Node Leaf Leaf -- We represented this using {"Node":["Leaf", "Leaf"]} in Python.
Node Leaf Leaf

*> Leaf `Node` Leaf
Node Leaf Leaf

*> Leaf `Node` ((Leaf `Node` Leaf) `Node` (Leaf `Node` Leaf))
Node Leaf (Node (Node Leaf Leaf) (Node Leaf Leaf))
      ]]></code>
      <text hooks="math"><![CDATA[
Haskell's native support for pattern matching unification makes it possible to write concise definitions for functions that are defined over trees.
      ]]></text>
      <code hooks="Haskell"><![CDATA[
-- Count the number of nodes in a tree that have exactly one non-leaf child.
-- The spaces between the ( ... ) are just for legibility.
nodesWithOneLeaf (Node Leaf Leaf) = 0;
nodesWithOneLeaf (Node Leaf t   ) = 1 + nodesWithOneLeaf(t);
nodesWithOneLeaf (Node t    Leaf) = 1 + nodesWithOneLeaf(t);
nodesWithOneLeaf (Node t1   t2  ) = nodesWithOneLeaf(t1) + nodesWithOneLeaf(t2);
nodesWithOneLeaf (Leaf          ) = 0;
      ]]></code>
      <text hooks="math"><![CDATA[
Algebraic data types are very well-suited for represented abstract syntaxes of languages, and pattern matching unification makes it possible to define concise implementations of the operational semantics of languages (as well as any other transformations over abstract syntax trees, including optimization algorithms, static analysis algorithms, and compilation algorithms).
      ]]></text>
      <example required="true" id="beb651b8549a4706a411ce0af3cd0010">
        <text hooks="math"><![CDATA[
Suppose we want to define an abstract syntax and simple interpreter for formulas. We can use the declarations below to do so.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
@module Formula @where

@data Formula = 
    T
  | F
  | Not Formula
  | And Formula Formula
  | Or Formula Formula
  @deriving Show;

vNot (T) = F;
vNot (F) = T;

vAnd (T, T) = T;
vAnd (T, F) = F;
vAnd (F, T) = F;
vAnd (F, F) = F;

vOr (T, T) = T;
vOr (T, F) = T;
vOr (F, T) = T;
vOr (F, F) = F;

eval (T        ) = T;
eval (F        ) = F;
eval (Not f    ) = vNot (eval f);
eval (And f1 f2) = vAnd (eval f1, eval f2);
eval (Or  f1 f2) = vOr (eval f1, eval f2);
      ]]></code>
        <text hooks="math"><![CDATA[
Using wildcards (written using the underscore <code>_</code>) in patterns makes it possible to write even more concise definitions.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
vAnd (T, T) = T;
vAnd _      = F;

vOr (F, F) = F;
vOr _      = T;

eval (Not f    ) = vNot (eval f);
eval (And f1 f2) = vAnd (eval f1, eval f2);
eval (Or  f1 f2) = vOr (eval f1, eval f2);
eval (f)         = f;
        ]]></code>
        <text hooks="math"><![CDATA[
To check equality of algebraic data type instances, it is necessary to either implement or derive the equality function <code>==</code>. To have the Haskell interpreter or compiler derive it automatically, you can use <code>deriving Eq</code>. These can be combined with other <code>deriving</code> directives, such as in the example below.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
@data Formula = 
    T
  | F
  | Not Formula
  | And Formula Formula
  | Or Formula Formula
  @deriving (Eq, Show);
        ]]></code>
      </example>
    </subsection>
    <assignment title="Declarative Programming Languages">
      <instructions>
        <text><![CDATA[
In this assignment you will implement an interpreter using Python for a declarative language, and you will practice using the declarative programming language Haskell. You must submit four files:
<ul>
  <li><code><a href="hw4/parse.py">hw4/parse.py</a></code> (there is no need to modify this file);</li>
  <li><code><a href="hw4/interpret.py">hw4/interpret.py</a></code>;</li>
  <li><code><a href="hw4/Tree.hs">hw4/Tree.hs</a></code>;</li>
  <li><code><a href="hw4/Term.hs">hw4/Term.hs</a></code>.</li>
</ul>
Please follow the <a href="#A">gsubmit</a> directions and remember to put your files in the <code>hw4</code> directory.
        ]]></text>
        <paragraph><![CDATA[
Your solutions to each of the problem parts below will be graded on their correctness, concision, and mathematical legibility. The different problems and problem parts rely on the lecture notes and on each other; carefully consider whether you can use functions from the lecture notes, or functions you define in one part within subsequent parts.
        ]]></paragraph>
        <paragraph><![CDATA[
<b style="color:green;">A testing script with several test cases is available for download: <a href="hw4-tests.py"><code>hw4-tests.py</code></a>. You should be able to place it in the same directory with the other assignment files and run it. Feel free to modify or extend it as you see fit.</b>
        ]]></paragraph>
      </instructions>
      <problems>
        <problem>
          <text><![CDATA[
In this problem you will implement helper functions for performing substitution and unification. Your solutions should be included in the file <code><a href="hw4/interpret.py">hw4/interpret.py</a></code>.
          ]]></text>
          <parts>
            <part>
              <text><![CDATA[
Implement a function <code>subst(s, a)</code> that takes two arguments: a substitution <code>s</code> (represented as a Python dictionary), and an abstract syntax tree <code>a</code>. The function should return a new abstract syntax tree in which every variable in the tree that is in the domain of <code>s</code> has been substituted according to the substitution <code>s</code>. You may assume that variables are always represented using a subtree of the form <code>{"Variable":[ ... ]}</code>, as in all previous examples and assignments.
              ]]></text>
            </part>
            <part>
              <text><![CDATA[
Implement a function <code>unify(a, b)</code> that takes two arguments: two syntax trees <code>a</code> and <code>b</code>. The function should return the smallest substitution <code>s</code> that satisfies the following equation:
              ]]></text>
              <code hooks="Python"><![CDATA[
subst(s, a) == subst(s, b)
              ]]></code>
              <text><![CDATA[
You should implement the <a href="#95e800c8e74e4991a2ddb48668b544e0">pattern matching unification</a> algorithm for this assignment.
              ]]></text>
            </part>
          </parts>
        </problem>
        <problem>
          <text hooks="math"><![CDATA[
In this problem, you will implement an interactive interpreter for a declarative language (a small, untyped version of a subset of Haskell). All the functions you define should be included in the file <code><a href="hw4/interpret.py">hw4/interpret.py</a></code>. The abstract syntax for the language is presented below; a complete parser that parses the concrete syntax for this language into the abstract syntax below can be found in <code><a href="hw4/parse.py">hw4/parse.py</a></code>. Notice that in the concrete syntax, constructor names always begin with an uppercase letter, while variable names always begin with a lowercase letter.
\begin{eqnarray}
declaration %d & ::= & %f <b>(</b> %p <b>)</b> <b>=</b> %e <b>;</b> %d \\
                 & | & \\
pattern %p & ::= & %c %p %p \\
             & | & %c \\
             & | & %n \\
             & | & %x \\
             & | & <b>(</b> %p <b>)</b> \\
expression %e & ::= & %c %e %e \\
             & | & %c \\
             & | & %n \\
             & | & %x \\
             & | & <b>(</b> %e <b>)</b> \\
             & | & %e <b>+</b> %e \\
             & | & %f <b>(</b> %e <b>)</b> \\
number %n & ::= & <code>0|[1-9][0-9]*</code> \\
constructor %c & ::= & <code>[A-Z][A-Za-z]*</code> \\
variable %x, %f & ::= & <code>[a-z][A-Za-z]*</code>
\end{eqnarray}
The relevant portions of the operational semantics are provided below:
        ]]></text>
          <parts>
            <part>
              <text><![CDATA[
Implement a function <code>build(m, d)</code> that takes a finite map <code>m</code> (i.e., a Python dictionary mapping names to lists of (<i>pattern</i>, <i>expression</i>) tuples) and a <i>declaration</i> parse tree <code>d</code>. The function should return the finite map <code>m</code> that represents the module definition that is assembled according to the operational semantics presented below:
              ]]></text>
              <inferences hooks="math">
                <inference title="Declaration-Function-First">
                  <premises><![CDATA[
                    %f \not\in \dom(%M_1) 
                    %~ %~ %M_1 \uplus {%f \mapsto {(%p, %e)}} %d \Downarrow %M_2
                  ]]></premises>
                  <conclusion><![CDATA[
                    %M_1, %f <b>(</b> %p <b>)</b> <b>=</b> %e <b>;</b> %d \Downarrow %M_2
                  ]]></conclusion>
                </inference>
                <inference title="Declaration-Function-More">
                  <premises><![CDATA[
                    %f \in \dom(%M_1)
                    %~ %~ %M_1 \uplus {%f \mapsto (%M_1(%f) \uplus {(%p, %e)})} %d \Downarrow %M_2
                  ]]></premises>
                  <conclusion><![CDATA[
                    %M_1, %f <b>(</b> %p <b>)</b> <b>=</b> %e <b>;</b> %d \Downarrow %M_2
                  ]]></conclusion>
                </inference>
                <inference title="Declaration-End">
                  <premises><![CDATA[]]></premises>
                  <conclusion><![CDATA[%M, <b style="color:gray;">end</b> \Downarrow %M]]></conclusion>
                </inference>
              </inferences>
            </part>
            <part>
              <text hooks="math"><![CDATA[
The abstract syntax for values is defined as follows:
\begin{eqnarray}
value %v & ::= & %c %v %v \\
             & | & %c \\
             & | & %n
\end{eqnarray}
              ]]></text>    
              <text hooks="math"><![CDATA[
Implement a function <code>evaluate(m, env, e)</code> that takes a module <code>m</code>, an environment <code>env</code>, and an <i>expression</i> abstract syntax tree <code>e</code> as its three arguments. The function should return the value that corresponds to the evaluation of the abstract syntax tree <code>e</code>, as determined by the operational semantics presented below. Note that the <span style="font-variant:small-caps;">[Expression-Apply]</span> requires using a unification algorithm to obtain a substitution \sigma that unifies %p and %v_1.
              ]]></text>
              <inferences hooks="math">
                <inference title="Expression-Constructor-Args">
                  <premises><![CDATA[%M, \Sigma, %e_1 \Downarrow %v_1 %~ %~ %M, \Sigma, %e_2 \Downarrow %v_2]]></premises>
                  <conclusion><![CDATA[%M, \Sigma, %c %e_1 %e_2 \Downarrow %c %v_1 %v_2]]></conclusion>
                </inference>
                <inference title="Expression-Constructor-No-Args">
                  <premises><![CDATA[]]></premises>
                  <conclusion><![CDATA[%M, \Sigma, %c \Downarrow %c]]></conclusion>
                </inference>
                <inference title="Expression-Number">
                  <premises><![CDATA[]]></premises>
                  <conclusion><![CDATA[%M, \Sigma, %n \Downarrow %n]]></conclusion>
                </inference>
                <inference title="Expression-Variable">
                  <premises><![CDATA[\Sigma(%x) = %v]]></premises>
                  <conclusion><![CDATA[%M, \Sigma, %x \Downarrow %v]]></conclusion>
                </inference>
                <inference title="Expression-Plus">
                  <premises><![CDATA[%M, \Sigma, %e_1 \Downarrow %n_1 %~ %~ %M, \Sigma, %e_2 \Downarrow %n_2]]></premises>
                  <conclusion><![CDATA[%M, \Sigma, %e_1 <b>+</b> %e_2 \Downarrow %n_1 + %n_2]]></conclusion>
                </inference>
                <inference title="Expression-Apply">
                  <premises><![CDATA[
                    %M, \Sigma, %e_1 \Downarrow %v_1
                    %~ %~ (%p, %e_2) \in %M(%f)
                    %~ %~ \sigma(%p) = \sigma(%v_1)
                    %~ %~ %M, \Sigma \uplus \sigma, %e_2 \Downarrow %v_2
                  ]]></premises>
                  <conclusion><![CDATA[
                    %M, \Sigma , %f <b>(</b> %e_1 <b>)</b> \Downarrow %v_2
                  ]]></conclusion>
                </inference>
              </inferences>
            </part>
          </parts>
          <text><![CDATA[
Once <code>build()</code> and <code>evaluate()</code> are implemented, you can use the <code>interact()</code> function in <code><a href="hw4/interpret.py">hw4/interpret.py</a></code> to query modules.
          ]]></text>
        </problem>
        <problem>
          <text><![CDATA[
In this problem you will practice using algebraic data types in the Haskell programming language. All your definitions should be included in the file <code><a href="hw4/Tree.hs">hw4/Tree.hs</a></code>. You will be working with the following data type definition, which has already been included in the file:
          ]]></text>
          <code hooks="Haskell"><![CDATA[
@data Tree = Leaf | Twig | Branch Tree Tree Tree
          ]]></code>
          <text><![CDATA[
You may not import any additional modules or libraries.
          ]]></text>
          <parts>
            <part>
              <text><![CDATA[
Modify the data type definition for <code>Tree</code> in <code>Tree.hs</code> so that the functions <code>(==)</code> and <code>show</code> are automatically generated for this data type.
              ]]></text>
            </part>
            <part>
              <text><![CDATA[
Implement a function <code>twigs :: Tree -> Integer</code> that returns an integer representing the total number of <code>Twig</code> values in the input tree.
              ]]></text>
              <code hooks="Haskell"><![CDATA[
*> twigs (Branch (Branch Twig Leaf Leaf) Twig Twig)
3
              ]]></code>
            </part>
            <part>
              <text><![CDATA[
Implement a function <code>branches :: Tree -> Integer</code> that returns an integer representing the total number of branches in the input tree.
              ]]></text>
              <code hooks="Haskell"><![CDATA[
*> branches (Branch Leaf (Branch Twig Leaf Leaf) Leaf)
2
              ]]></code>
            </part>
            <part>
              <text><![CDATA[
Implement a function <code>height :: Tree -> Integer</code> that returns an integer representing the height of the input tree. Trees consisting of a <code>Leaf</code> are defined to have height <code>0</code>, while trees consisting of a <code>Twig</code> are defined to have height <code>1</code>.
              ]]></text>
              <code hooks="Haskell"><![CDATA[
*> height (Branch (Branch Leaf Leaf Twig) (Branch Leaf Leaf Leaf) Leaf)
3
              ]]></code>
            </part>
            <part>
              <text><![CDATA[
A tree is <i>perfect</i> if all the leaves of the tree are at the same depth and it has no twigs. Define a function <code>perfect :: Tree -> Bool</code> that returns <code>True</code> if the input tree is perfect and <code>False</code> otherwise.
              ]]></text>
              <code hooks="Haskell"><![CDATA[
*> perfect (Branch (Branch Leaf Leaf Leaf) Leaf Leaf)
False
*> perfect (Branch Twig Twig Twig)
False
*> perfect (Branch (Branch Leaf Leaf Leaf) (Branch Leaf Leaf Leaf) (Branch Leaf Leaf Leaf))
True
              ]]></code>
            </part>
            <part>
              <text><![CDATA[
A tree is <i>degenerate</i> if all the branches are part of a single path. Equivalently, a tree is degenerate if all nodes have at <b style="color:green;">least two non-node children</b>. Define a function <code>degenerate :: Tree -> Bool</code> that returns <code>True</code> if the tree supplied is degenerate, and <code>False</code> otherwise.
              ]]></text>
              <code hooks="Haskell"><![CDATA[
*> degenerate (Branch (Branch Twig Leaf Leaf) Twig Leaf)
True
*> degenerate (Branch (Branch Leaf Leaf Leaf) Leaf (Branch Leaf Leaf Leaf))
False
              ]]></code>
            </part>
            <part>
              <text><![CDATA[
Define a tree <code>infinite :: Tree</code> that has no leaves and no twigs.
              ]]></text>
            </part>
          </parts>
        </problem>
        <problem>
          <text><![CDATA[
In this problem you will implement a very simple interpreter using the Haskell programming language. All your definitions should be included in the file <code><a href="hw4/Term.hs">hw4/Term.hs</a></code>.
          ]]></text>
          <text><![CDATA[
Implement the <code>evaluate :: Term -> Integer</code> function so that it evaluates abstract syntax trees of the type <code>Term</code> to obtain values (i.e., integers).
          ]]></text>
              <code hooks="Haskell"><![CDATA[
*> evaluate (Plus (Number 1) (Number 2))
3
*> evaluate (Mult (Number 4) (Abs (Plus (Number (-1)) (Number (-2)))))
12
              ]]></code>
        </problem>
      </problems>
    </assignment>
    <subsection title="Type system of the typed declarative language Haskell">
      <text hooks="math"><![CDATA[
Haskell natively supports defining and using algebraic data types, tuples, lists, and functions. The Haskell type system provides a good way to organize and document these data structures, and governs how they can be combined. The abstract syntax for a portion of the Haskell type system is provided below.
\begin{eqnarray}
Haskell type \tau & ::= & <code>Bool</code> \\
                 & | & <code>Int</code> \\
                 & | & <code>Integer</code> \\
                 & | & <code>Char</code> \\
                 & | & <code>()</code> \\
                 & | & <code>(</code> \tau <code>,</code> \tau <code>)</code> \\
                 & | & <code>(</code> \tau <code>,</code> \tau <code>,</code> \tau <code>)</code> \\
                 & \vdots & \\
                 & | & <code>(</code> \tau <code>,</code> ... <code>,</code> \tau <code>)</code> \\
                 & | & <code>[</code> \tau <code>]</code> \\
                 & | & \tau <code>-></code> \tau\\
                 & \vdots & \\
\end{eqnarray}
Haskell allows users to define their own algebraic data types as well as their own type synonyms. Every Haskell module has two distinct namespaces for identifiers, and these two namespaces are completely disjoint: there is a namespace for identifiers that correspond to variable, functions, and constructors, and there is a namespace for identifiers that correspond to types. The concrete syntax determines to which namespace a given variable belongs, and there is never any ambiguity in the concrete syntax in this regard. Note that this is unlike Python, where types can appear in any expression within a program. The following example illustrates the distinct namespaces for <span style="background-color:lightgreen">expressions</span> and <span style="background-color:pink">types</span>:
<div class="code"><div class="source">
<br/>module Example where
<br/>
<br/><span style="background-color:lightgreen">f</span> :: <span style="background-color:pink">Integer</span> -> <span style="background-color:pink">Integer</span>
<br/><span style="background-color:lightgreen">f</span> (<span style="background-color:lightgreen">x</span>) = <span style="background-color:lightgreen">x</span> + <span style="background-color:lightgreen">x</span>
<br/>
<br/>data <span style="background-color:pink">Tree</span> = <span style="background-color:lightgreen">Leaf</span> | <span style="background-color:lightgreen">Node</span> <span style="background-color:pink">Tree</span> <span style="background-color:pink">Tree</span>
<br/>
<br/>type <span style="background-color:pink">AnotherNameForInteger</span> = <span style="background-color:pink">Integer</span>
<br/>
<br/>type <span style="background-color:pink">AnotherNameForTree</span> = <span style="background-color:pink">Tree</span>
<br/>
<br/><span style="background-color:lightgreen">isLeaf</span> :: <span style="background-color:pink">AnotherNameForTree</span> -> <span style="background-color:pink">Bool</span>
<br/><span style="background-color:lightgreen">isLeaf</span> (<span style="background-color:lightgreen">Leaf</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;) = <span style="background-color:lightgreen">True</span>
<br/><span style="background-color:lightgreen">isLeaf</span> (<span style="background-color:lightgreen">Node</span> <span style="background-color:lightgreen">t1</span> <span style="background-color:lightgreen">t2</span>) = <span style="background-color:lightgreen">False</span>
<br/><br/></div></div>
      ]]></text>
      <text hooks="math"><![CDATA[
Haskell lists have a list type in Haskell. For example, a list of integers has the type <code>[Integer]</code>.
      ]]></text>
      <code hooks="Haskell"><![CDATA[
list :: [Integer]
list = [1,2,3]
      ]]></code>
      <text hooks="math"><![CDATA[
Haskell lists are actually represented using an algebraic data type that is similar to the <code>Tree</code> data type <a href="#7.4">that we have already seen</a>. If we were to define our own algebraic data type for lists in Haskell, for example, we could do so as follows (the terms "nil" and "cons" are commonly used in the functional language community for the empty list and for the list node constructor, respectively):
      ]]></text>
      <code hooks="Haskell"><![CDATA[
@data List = Nil | Cons Integer List

example :: List
example = Cons 1 (Cons 2 (Cons 3 Nil))
      ]]></code>
      <text hooks="math"><![CDATA[
The built-in list type has its own special names for the two constructors: the empty list is denoted <code>[]</code>, and the list node constructor is the operator <code>(:)</code>, which can also be written as an infix operator <code>:</code>. The following three syntaxes are equivalent, and evaluate to the same list <code>[1,2,3]</code>:
      ]]></text>
      <code hooks="Haskell"><![CDATA[
example1 :: [Integer]
example1 = (:) 1 ((:) 2 ((:) 3 []))

example2 :: [Integer]
example2 =  1 : (2 : (3 : []))

example3 :: [Integer]
example3 =  [1,2,3]
      ]]></code>
      <text hooks="math"><![CDATA[
There is also a syntax for defining lists that contain ranges of integers:
      ]]></text>
      <code hooks="Haskell"><![CDATA[
*> [1..4]
[1,2,3,4]
      ]]></code>
      <text hooks="math"><![CDATA[
Haskell supports user-defined type synonyms. These are simply substituted and have no restrictive effects.
      ]]></text>
      <code hooks="Haskell"><![CDATA[
@type Distance = Integer
      ]]></code>
      <text hooks="math"><![CDATA[
There are some default type synonym definitions, such as <code>String</code>; strings in Haskell are just lists of characters:
      ]]></text>
      <code hooks="Haskell"><![CDATA[
@type String = [Char]

example1 :: String
example1 = "abcdefg"

example2 :: String
example2 = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
      ]]></code>
      <text hooks="math"><![CDATA[
Type synonyms can be assigned any valid type, no matter how complex it may be. In the below example, the type synonym <code>GameStrategyAlgorithm</code> is equivalent to the type <code>[[(Integer, Integer)]] -> String</code> (i.e., the type for functions that take lists of lists of integer pairs and return a string):
      ]]></text>
      <code hooks="Haskell"><![CDATA[
@type GameState = [(Integer, Integer)]
@type Game = [GameState]
@type Strategy = String
@type GameStrategyAlgorithm = Game -> Strategy
      ]]></code>
    </subsection>
    <subsection title="Defining and working with infinite data type instances using lazy evaluation">
      <text hooks="math"><![CDATA[
Since Haskell expressions are only evaluated when a query is made, a Haskell module can safely describe recursively defined, potentially infinitely large values. For example, we can define an infinite list containing the integer <code>1</code> in every position:
      ]]></text>
      <code hooks="Haskell"><![CDATA[
infinite :: [Integer]
infinite = [1] ++ infinite
      ]]></code>
      <text hooks="math"><![CDATA[
Equivalently, we can use the <code>(:)</code> list node constructor:
      ]]></text>
      <code hooks="Haskell"><![CDATA[
infinite :: [Integer]
infinite = 1 : infinite
      ]]></code>
      <text hooks="math"><![CDATA[
Haskell also allows infinite lists containing ranges to be declared using the list range notation:
      ]]></text>
      <code hooks="Haskell"><![CDATA[
*> take 10 [5..]
[5,6,7,8,9,10,11,12,13,14]
      ]]></code>
      <text hooks="math"><![CDATA[
The Haskell operational semantics is based on pattern matching unification, but it doesn't work exactly like the operational semantics we implemented in <a href="#assignment4">Assignment #4</a>. Haskell supports <i>lazy evaluation</i>. Intuitively, when trying to evaluate a function application of the form %f(%e), Haskell will only evaluate the expression %e using substitutions until it is sufficiently deep to try all the patterns in the definition of %f (e.g., if the patterns associated with %f are all of depth at most 3, the expression %e will be evaluated until the constructors up to depth 3 are known, and no further).
<br/><br/>
Haskell lazy evaluation operational semantics make it possible to perform queries on infinite values without running into an infinite recursion or infinite loop. For example, suppose we define the following function on lists, which takes only the first <code>n</code> elements of a list (note that this function is already included in the <code>Prelude</code>; we use <code>take_</code> for our examples to avoid a name collision).
      ]]></text>
      <code hooks="Haskell"><![CDATA[
take_ :: (Integer, [Integer]) -> [Integer]
take_ (0, xs    ) = []
take_ (n, (x:xs)) = x : take (n-1, xs)
      ]]></code>
      <text hooks="math"><![CDATA[
Querying the infinite list is not a problem if we use <code>take</code>.
      ]]></text>
      <code hooks="Haskell"><![CDATA[
*> take (10, infinite)
[1,1,1,1,1,1,1,1,1,1]
      ]]></code>
      <text hooks="math"><![CDATA[
Using pattern matching unification and lazy evaluation, it is also possible to define algorithm that can operate on infinite lists. For example, we can define a function that adds all the corresponding elements of two infinite lists. Notice that there is no case for the empty list in this definition because infinite lists are never empty.
      ]]></text>
      <code hooks="Haskell"><![CDATA[
addInfiniteLists :: ([Integer], [Integer]) -> [Integer]
addInfiniteLists (x:xs, y:ys) = (x + y) : addInfiniteLists (xs, ys)
      ]]></code>
      <text hooks="math"><![CDATA[
We can now use the <code>addInfiniteLists</code> function to add two infinite lists. Suppose we have the following definitions:
      ]]></text>
      <code hooks="Haskell"><![CDATA[
ones = 1 : ones
twos = 2 : twos
      ]]></code>
      <text hooks="math"><![CDATA[
We can then define an infinite list in which all entries are <code>3</code>:
      ]]></text>
      <code hooks="Haskell"><![CDATA[
*> take 10 (addInfiniteLists (ones, twos))
[3,3,3,3,3,3,3,3,3,3]
      ]]></code>
    </subsection>
    <subsection title="Logic programming">
      <text hooks="math"><![CDATA[
Declarative languages are well-suited for describing logical models and then examining them by making queries. Declarative languages like Prolog and Datalog are designed specifically to support logic programming. In Haskell, it is possible to use functions that return boolean values to represent logical predicates, and boolean expressions to represent the formulas that define them.
      ]]></text>
      <example required="true" id="c24e8ebd33174a6bae403a96c4512c99">
        <text hooks="math"><![CDATA[ 
Suppose we want to model a simple access control system (e.g., for a file system). Notice that we can view functions like <code>user()</code> and <code>owns()</code> either as tables in a database (with each declaration for the function acting as a row in the table) or as logical predicates.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
@data Constant = Alice | Bob | X | Y | Z @deriving (Eq, Show)

-- Define which constants are a file.
file (X) = True
file (Y) = True
file (Z) = True
file (_) = False

-- Define which constants are a user.
user (Alice) = True
user (Bob)   = True
user (_)     = False

-- Specify which users are administrators.
admin(Alice) = True
admin(Bob)   = False

-- Specify file ownership relation.
owns (Alice, X) = True
owns (Bob,   Y) = True
owns (Bob,   Z) = True
owns (_,     _) = False

-- Only owners and administrators can write files.
write (user', file') = 
     ( owns(user', file') || admin(user'))
  && user(user')
  && file(file')

-- Anyone can read files.
read (user, file) = True
        ]]></code>
        <text hooks="math"><![CDATA[ 
In the above example, we needed to define predicates that distinguished different types of constants. However, this means that every call to <code>file()</code> and <code>user()</code> must take place when the program is running. We can make the code more efficient by instead declaring distinct types. Since type checking is performed only at compile time in Haskell, this will still ensure that there are no type errors, but it will be more efficient because fewer function invocations will occur when the program is running.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
@data User = Alice | Bob @deriving (Eq, Show)
@data File = X | Y | Z @deriving (Eq, Show)

admin :: User -> Bool
admin (Alice) = True
admin (Bob)   = False

owns :: (User, File) -> Bool
owns (Alice, X) = True
owns (Bob,   Y)   = True
owns (Bob,   Z)   = True
owns (_,     _)   = False

write :: (User, File) -> Bool
write (user, file) = owns(user, file) || admin(user)

read :: (User, File) -> Bool
read (user, file) = True
        ]]></code>
      </example>
    </subsection>
    <subsection title="Functions and higher-order functions in a typed functional language">
      <text hooks="math"><![CDATA[
Haskell is a functional language; functional languages are distinguished by their ability to allow users to define and use <i>higher-order function</i>: functions that can take other function as arguments, and that can return functions as results. Many other languages have native support for higher-order functions, including JavaScript and Python; we say that these languages support the functional programming paradigm.
<br/><br/>
To start become familiar with the concept of a higher-order function, we can consider the following example:
      ]]></text>
      <code hooks="Haskell"><![CDATA[
f :: Integer -> Integer
f (x) = x + 1

g :: Integer -> (Integer -> Integer)
g (y) = f
      ]]></code>
      <text hooks="math"><![CDATA[
Notice that <code>g</code> is a function that takes an integer as an argument. It then throws this argument away and returns the function <code>f</code>. Its type reflects this. Thus, the result of evaluating an expression such as <code>g(4)</code> is a function of type <code>Integer -> Integer</code>, and this function can be applied to another argument.
      ]]></text>
      <code hooks="Haskell"><![CDATA[
*> :t g(1)
g(1) :: Integer -> Integer
*> :t g(1)(5)
g(1)(5) :: Integer
*> g(1)(5)
6
      ]]></code>
      <text hooks="math"><![CDATA[
What if we want to define a function like <code>g</code> that can be partially applied to only some of its arguments, but that still uses all of its arguments? We can do so by listing multiple, space-separated parameters in the definition of <code>g</code>.
      ]]></text>
      <code hooks="Haskell"><![CDATA[
g :: Integer -> (Integer -> Integer)
g (y) (x) = y + x
      ]]></code>
      <text hooks="math"><![CDATA[
It is then possible to apply <code>g</code> to arguments one at a time, as before.
      ]]></text>
      <code hooks="Haskell"><![CDATA[
*> :t g(3)
g(3) :: Integer -> Integer
*> :t g(3)(4)
g(3)(4) :: Integer
*> g(3)(4)
7
      ]]></code>
      <text hooks="math"><![CDATA[
Notice the relationship between application of functions to arguments, and the types of each intermediate result. Suppose we have the following definitions.
      ]]></text>
      <code hooks="Haskell"><![CDATA[
@data A = A
@data B = B
@data C = C
@data D = D
@data E = E

f :: A -> (B -> (C -> (D -> E)))
f a b c d = E
      ]]></code>
      <text hooks="math"><![CDATA[
Then we have the following types for each of the following expressions (spacing adjusted for legibility):
      ]]></text>
      <code hooks="Haskell"><![CDATA[
*> :t f
f             :: A -> (B -> (C -> (D -> E)))

*> :t f(A)
f(A)          :: B -> (C -> (D -> E))

*> :t f(A)(B)
f(A)(B)       :: C -> (D -> E)

*> :t f(A)(B)(C)
f(A)(B)(C)    :: D -> E

*> :t f(A)(B)(C)(D)
f(A)(B)(C)(D) :: E
      ]]></code>
      <example required="true" id="1bdc6c8725eb468894c900da3baaa814">
        <text hooks="math"><![CDATA[ 
We want to write a higher-order function that takes any function <code>f</code> of type <code>Integer -> Integer</code> and returns a function <code>f'</code> that is its reflection across the %x-axis (i.e., for all <code>x</code>, <code>f(x)</code> = <code>-f'(x)</code>).
        ]]></text>
        <code hooks="Haskell"><![CDATA[
reflect :: (Integer -> Integer) -> Integer -> Integer
reflect (f) (x) = - f(x) 
        ]]></code>
        <text hooks="math"><![CDATA[ 
Notice that we could also write the type as <code>(Integer -> Integer) -> (Integer -> Integer)</code> because <code>-></code> is right-associative. This makes it more obvious that <code>reflect</code> takes a function of type <code>Integer -> Integer</code> as an input and returns a function of type <code>Integer -> Integer</code> as an output.
        ]]></text>
      </example>
      <example required="true" id="939b3bd03b6c4835ab93b81eec793179">
        <text hooks="math"><![CDATA[ 
We want to write a higher-order function that takes any function <code>f</code> of type <code>Integer -> Integer</code> and returns an integer approximation of its definite integral starting at %x = 0.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
integral :: (Integer -> Integer) -> Integer -> Integer
integral (f) (x) = sum [ f(k) | k <- [0..x] ]
        ]]></code>
        <text hooks="math"><![CDATA[ 
We could also write a higher-order function that takes any function <code>f</code> of type <code>Double -> Integer</code> and returns an approximation of its definite integral starting at %x = 0 for a given precision.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
integral :: Double -> (Double -> Double) -> Double -> Double
integral (i) (f) (x) = sum [ f(k*i)*i | k <- [0..(x/i)] ]
        ]]></code>
      </example>
      <example required="true" id="b881f643ee054befa099c21d8d46390a">
        <text hooks="math"><![CDATA[ 
We want to write a higher-order function that takes any function <code>f</code> of type <code>Double -> Double</code> and returns an approximation of its derivative.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
derivative :: Double -> (Double -> Double) -> Double -> Double
derivative (h) (f) (x) = (f(x + h) - f(x)) / h
        ]]></code>
      </example>
    </subsection>    
    <subsection title="Data encapsulation using algebraic data types">
      <text hooks="math"><![CDATA[
Typed languages that support algebraic data types make it possible to implement and enforce a kind of data encapsulation. For example, suppose we want to represent distances in various units (such as Imperial and metric units) in our program. There are well-known examples of expensive software failures (such as the crash of the <a href="http://en.wikipedia.org/wiki/Mars_Climate_Orbiter">Mars Climate Orbiter</a>) that occurred because one component assumed that numerical data was in Imperial units, while another component assumed it was metric units.
      ]]></text>
      <code hooks="Haskell"><![CDATA[
@data Meters = Meters Integer
@data Feet = Feet Integer
      ]]></code>
      <text hooks="math"><![CDATA[
Given the above, it is now possible to enforce which type of measurement is supported by a function. For example:
      ]]></text>
      <code hooks="Haskell"><![CDATA[
@data Action = KeepGoing | SlowDown

updateVelocity :: Feet -> Action
updateVelocity (Feet n) = @if n < 100 @then SlowDown @else KeepGoing
      ]]></code>
    </subsection>
    <subsection title="Predefined Haskell type classes, user-defined operators, and embedded languages">
      <text hooks="math"><![CDATA[
Haskell allows programmers to define their own functions for converting algebraic data type values to strings (e.g., for displaying them in the interactive interface), and it allows programmers to provide custom definitions for numeric literals (i.e., <code>0</code>, <code>1</code>, <code>2</code>, and so on) and built-in operators (such as <code>+</code>, <code>*</code>, and so on).
      ]]></text>
      <code hooks="Haskell"><![CDATA[
@instance Num Meters @where
  fromInteger n = Meters n
  (Meters x) + (Meters y) = Meters (x + y)
      ]]></code>
      <text hooks="math"><![CDATA[
The above definitions allow us to use the numeric liters and built-in operators to work with values of type <code>Meters</code>.
      ]]></text>
      <code hooks="Haskell"><![CDATA[
*> 1 + 2 + 3 :: Meters
Meters 6
      ]]></code>
      <text hooks="math"><![CDATA[
It is also possible to provide a user-defined function for converting values of type <code>Meters</code> to strings.
      ]]></text>
      <code hooks="Haskell"><![CDATA[
@instance Show Meters @where
  show (Meters n) = show n ++ " meters"
      ]]></code>
      <text hooks="math"><![CDATA[
Then, we have the following behavior:
      ]]></text>
      <code hooks="Haskell"><![CDATA[
*> 1 + 2 + 3 :: Meters
6 meters
      ]]></code>
      <text hooks="math"><![CDATA[
The Haskell features that support algebraic data types, multiple ways to apply higher-order functions to arguments, user-defined infix operators, and user-defined definitions of built-in literals and functions can be used in concert to easily define new programming languages <i>within</i> Haskell itself. This makes it much easier to build parse trees directly within Haskell, thus obviating the need for a parser.
      ]]></text>
      <definition required="true" hooks="math" id="6c93307257d142a09a6927e0ecd8603a"><![CDATA[
An <i>embedded language</i> is a subset of the concrete syntax of a programming language (the <i>host</i> language) that is treated as its own separate, self-contained language. Libraries can often be viewed as embedded languages.
      ]]></definition>
      <example required="true" id="334b004be37343b3b190ddd3fd9ca116">
        <text hooks="math"><![CDATA[ 
Suppose we define the following algebraic data types, corresponding to an abstract syntax for an imperative programming language. This definition, along with some of Haskell's other features, will allow us to turn this into an <a href="#6c93307257d142a09a6927e0ecd8603a"><i>embedded language</i></a> within Haskell. We can then use Haskell's concrete syntax to write the concrete syntax for this language, and Haskell's evaluation algorithm will also act as the parser for this language (with the Haskell evaluation algorithm producing an abstract syntax tree representation of whatever is written).
        ]]></text>
        <code hooks="Haskell"><![CDATA[
@data Term =
    Number Integer
  | Plus Term Term
  @deriving Show
      
@data Formula = 
    T 
  | F 
  | Not Formula 
  | And Formula Formula
  | Or Formula Formula
  | Equal Term Term
  | LessThan Term Term
  @deriving Show

@data Statement =
    Print Term Statement
  | If Formula Statement Statement
  | End
  @deriving Show
        ]]></code>
        <text hooks="math"><![CDATA[ 
We also introduce some user-defined infix operators, and add user-specified definitions for some built-in Haskell operators:
        ]]></text>
        <code hooks="Haskell"><![CDATA[
(<<<) :: Term -> Term -> Formula
(<<<) t1 t2 = LessThan t1 t2

(===) :: Term -> Term -> Formula
(===) t1 t2 = Equal t1 t2

(&&&) :: Formula -> Formula -> Formula
(&&&) f1 f2 = And f1 f2

(|||) :: Formula -> Formula -> Formula
(|||) f1 f2 = Or f1 f2

@instance Num Term @where
  fromInteger n = Number n
  t1 + t2 = Plus t1 t2
        ]]></code>
        <text hooks="math"><![CDATA[ 
We can now use all of the above together with the <code>$</code> syntax to easily write down abstract syntax trees.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
parseTree =
   Print 5 $
   Print 6 $
   If ((5 <<< 6) &&& (6 <<< 7)) (
     Print 6 $
     Print 7 $
     End
   ) $
   End
        ]]></code>
        <text hooks="math"><![CDATA[ 
Evaluating the definition of <code>parseTree</code> will yield the actual algebraic data type instance (i.e., a parse tree).
        ]]></text>
        <code hooks="Haskell"><![CDATA[
*> parseTree
Print (Number 5) (Print (Number 6) (
  If
    (And (LessThan (Number 5) (Number 6)) (LessThan (Number 6) (Number 7))) 
    (Print (Number 6) (Print (Number 7) End)) End)
  )
        ]]></code>
      </example>
    </subsection>
   <subsection title="Additional useful Haskell language features and examples">
      <text hooks="math"><![CDATA[ 
Like Java/C/C++, Haskell provides a built-in ternary operator <code>if ... then ... else ...</code> for writing conditional expressions:
      ]]></text>
      <code hooks="Haskell"><![CDATA[
*> @if True @then 1 @else 2
1
*> @if False && True @then "Yes" @else "No"
"No"
      ]]></code>
      <text hooks="math"><![CDATA[ 
However, this is only a convenience; a user can easily implement his or her own syntax for this purpose. The support for pattern matching unification and lazy evaluation that Haskell's operational semantics provides is sufficient. Two example implementations are provided below.
      ]]></text>
      <code hooks="Haskell"><![CDATA[
if' :: (Bool, Integer, Integer) -> Integer
if' (True,  trueBranch, falseBranch) = trueBranch
if' (False, trueBranch, falseBranch) = falseBranch

if'' :: Bool -> Integer -> Integer -> Integer
if'' True  trueBranch _           = trueBranch
if'' False _          falseBranch = falseBranch
      ]]></code>
      <text hooks="math"><![CDATA[ 
The <code>if ... then ... else ...</code> syntax (or function, as we have seen above) can be useful in certain situations.
      ]]></text>
      <example required="true" id="cb9d023417604b6eafe52b06e26f35fb">
        <text hooks="math"><![CDATA[ 
Suppose we are trying to represent an <a href="#e1a5053a93d54ad4b02da10e4981b810">environment</a> or <a href="#f7d600442fe211e38cf6ce3f5508acd9">substitution</a> using a data structure in Haskell. We might do so by using a list of tuples, where each tuple is a pair consisting of a <code>String</code> and a value (e.g., an <code>Integer</code>). For example:
        ]]></text>
        <code hooks="Haskell"><![CDATA[
[("x",1), ("y", 2)] :: [(String, Integer)]
        ]]></code>
        <text hooks="math"><![CDATA[ 
Then, we would need a function that can help us retrieve a value associated with a particular variable name.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
lookup' :: String -> [(String, Integer)] -> Integer
lookup' x ((x',i) : rest) = @if x == x' @then i @else lookup' x rest
        ]]></code>
        <text hooks="math"><![CDATA[ 
In fact, Haskell's <a href="http://hackage.haskell.org/package/base">base</a> library contains a similar function, <code>lookup</code>. However, since it returns a result that is wrapped in a <code>Maybe</code> constructor, we can unwrap it using, e.g.:
        ]]></text>
        <code hooks="Haskell"><![CDATA[
unwrap :: Maybe Integer -> Integer
unwrap (Just n) = n
        ]]></code>
      </example>
      <example required="true" id="9ea7dc92b52b4098b358eb45fec68a2a">
        <text hooks="math"><![CDATA[ 
Suppose we want to write a simple interpreter for formulas (similar to the one in <a href="#beb651b8549a4706a411ce0af3cd0010">this example</a>), except we also want to support variables in the language. The data type corresponding to the abstract syntax might then look as follows:
        ]]></text>
        <code hooks="Haskell"><![CDATA[
@data Formula =
    T
  | F
  | Variable String
  | Xor Formula Formula
  @deriving Show
      ]]></code>
        <text hooks="math"><![CDATA[ 
We can then write a simple interpreter that uses environments (as defined in <a href="#cb9d023417604b6eafe52b06e26f35fb">this example</a>) in the following way (notice that the logical operation <b>xor</b> can be represented with the inequality operator <code>/=</code> on booleans):
        ]]></text>
        <code hooks="Haskell"><![CDATA[
eval :: [(String, Bool)] -> Formula -> Bool
eval env (T         ) = True
eval env (F         ) = False
eval env (Variable x) = lookup' x env
eval env (Xor f1 f2 ) = eval env f1 /= eval env f2
        ]]></code>
        <text hooks="math"><![CDATA[ 
We can then run the evaluation algorithm above on a given environment and expression containing variables:
        ]]></text>
        <code hooks="Haskell"><![CDATA[
*> eval [("x", True), ("y", False), ("z", True)] (Xor (Variable "x") (Variable "y"))
True
        ]]></code>
      </example>
      <example required="true" id="a97e8ebd22174a6bae403a96c4511c67">
        <text hooks="math"><![CDATA[ 
Suppose we want to represent our own totally ordered set. For example, suppose we have the following data type for representing a discrete subset of the color spectrum:
        ]]></text>
        <code hooks="Haskell"><![CDATA[
@data Color = Red | Green | Blue
        ]]></code>
        <text hooks="math"><![CDATA[ 
Since <code>Red</code> has the lowest frequency and <code>Blue</code> has the highest frequency, we can define an ordering on all instances of this data type by making the <code>Color</code> type a member of the <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html"><code>Ord</code></a> type class. Note that we could use wildcards (<code>_</code>) to make the definition more concise.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
@instance Ord Color @where
  Red   <= Red   = True
  Red   <= Green = True
  Red   <= Blue  = True
  Green <= Green = True
  Green <= Blue  = True
  Blue  <= Blue  = True
  _     <= _     = False
        ]]></code>
        <text hooks="math"><![CDATA[
It is now possible to use the built-in operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> to compare colors, as well as library functions such as <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#v:max"><code>max :: Color -> Color -> Color</code></a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#v:min"><code>min :: Color -> Color -> Color</code></a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#v:maximum"><code>maximum :: [Color] -> Color</code></a>, and <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#v:minimum"><code>minimum :: [Color] -> Color</code></a>.
        ]]></text>
      </example>
      <example required="true" id="21ae535d73b54e0283c6bec5cecb8565">
        <text hooks="math"><![CDATA[ 
Suppose we have a data type that allows us to build trees that contain integer constants in their leaves.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
@data IntegerTree = Node IntegerTree IntegerTree | Leaf Integer
        ]]></code>
        <text hooks="math"><![CDATA[ 
We can define a recursive function that assembles all the integers in the leaves in a single list.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
ints :: IntegerTree -> [Integer]
ints (Node t1 t2) = ints t1 ++ ints t2
ints (Leaf n    ) = [n]
        ]]></code>
      </example>
      <example required="true" id="35e16e3052bf4683856ee61eda628366">
        <text hooks="math"><![CDATA[ 
Suppose we want to write a function that composes two functions on integers. We might define a type synonym for such functions:
        ]]></text>
        <code hooks="Haskell"><![CDATA[
type Function = Integer -> Integer
        ]]></code>
        <text hooks="math"><![CDATA[ 
We then know that one possible type for a composition function might be as follows (it takes two function arguments, and returns a new composed function as a result):
        ]]></text>
        <code hooks="Haskell"><![CDATA[
compose :: Function -> Function -> Function
        ]]></code>
        <text hooks="math"><![CDATA[ 
However, how do we actually implement <code>compose</code>?
        ]]></text>
        <code hooks="Haskell"><![CDATA[
compose f g = ?
        ]]></code>
        <text hooks="math"><![CDATA[ 
To understand how we can do so, we must first expand the type of <code>compose</code>; let's substitute one the right-most <code>Function</code> synonym with its definition:
        ]]></text>
        <code hooks="Haskell"><![CDATA[
compose :: Function -> Function -> (Integer -> Integer)
        ]]></code>
        <text hooks="math"><![CDATA[ 
Now recall that the <code>-&gt;</code> type operator is right-associative; this means we can remove the right-most set of parentheses without changing the meaning of the type:
        ]]></text>
        <code hooks="Haskell"><![CDATA[
compose :: Function -> Function -> Integer -> Integer
        ]]></code>
        <text hooks="math"><![CDATA[ 
It is now clear how to implement <code>compose</code>: it takes two <code>Function</code> arguments, and one <code>Integer</code> argument:
        ]]></text>
        <code hooks="Haskell"><![CDATA[
compose :: Function -> Function -> Integer -> Integer
compose f g x = f(g(x))
        ]]></code>
        <text hooks="math"><![CDATA[ 
Note that this function is already available in the Haskell <a href="http://hackage.haskell.org/package/base">base</a> library, and it is called <code>(.)</code>. So we could also have defined <code>compose</code> as follows:
        ]]></text>
        <code hooks="Haskell"><![CDATA[
compose :: Function -> Function -> Function
compose f g = f . g
        ]]></code>
        <text hooks="math"><![CDATA[ 
The above is an example of <a href="http://en.wikipedia.org/wiki/Tacit_programming"><i>point-free</i></a> programming, because we never explicitly gave names to the individual inputs (i.e., "points") on which the functions operate.
        ]]></text>
      </example>
    </subsection>
    <subsection title="List comprehensions and pattern matching unification">
      <text hooks="math"><![CDATA[ 
Haskell list comprehension syntax can be combined with Haskell's built-in pattern matching unification capabilities.
      ]]></text>
      <example required="true" id="d9e61a21e7744b51be660bbe84b3c798">
        <text hooks="math"><![CDATA[ 
In Haskell, list comprehensions make it possible to build up a list by iterating over the elements of one or more other lists (possibly filtering entries using one or more formulas).
        ]]></text>
        <code hooks="Haskell"><![CDATA[
*> [x+1 | x <- [0..4]]
[1,2,3,4,5]

*> [(x,y) | x <- [1..3], y <- [1..2]]
[(1,1),(1,2),(2,1),(2,2),(3,1),(3,2)]

*> [(x,y) | x <- [1..3], y <- [1..2], x + y == 3, x >= 1]
[(1,2),(2,1)]
        ]]></code>
      </example>
      <example required="true" id="8ea8d6f6fc774cacb27951777d64a94f">
        <text hooks="math"><![CDATA[ 
In Haskell list comprehensions, the left-hand side of the membership operator <code>&;lt-</code> can be any pattern. If a pattern appears on the left-hand side of <code>&;lt-</code>, then each element in the list on the right-hand side will be checked against the pattern. Only those elements that unify with the pattern will be considered, and for each of them, the subsequent conditions in the comprehension, as well as the body of the comprehension, will be evaluated.
        ]]></text>
        <paragraph hooks="math"><![CDATA[ 
Suppose a module contains a data type definition for a simple tree data structure, and a list of trees.
        ]]></paragraph>
        <code hooks="Haskell"><![CDATA[
@data Tree =
    Node Tree Tree
  | Leaf
  @deriving Show

example :: [Tree]
example = [
    Node Leaf Leaf,
    Node (Node Leaf Leaf) Leaf,
    Node Leaf (Node Leaf Leaf),
    Node Leaf (Node (Node Leaf Leaf) Leaf)
  ]
        ]]></code>
        <text hooks="math"><![CDATA[ 
Then we can evaluate comprehensions such as the following. The first expression builds a list of the right subtrees of all the trees in <code>example</code>. The second expression builds a list containing the right subtrees that are not leaves. The last expression builds a list of subtree pairs for each non-leaf tree.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
*> [r | Node _ r <- example]
[Leaf, Leaf, Node Leaf Leaf, Node (Node Leaf Leaf) Leaf]

*> [r | Node _ r <- example, r /= Leaf]
[Node Leaf Leaf, Node (Node Leaf Leaf) Leaf]

*> [(l,r) | Node l r <- example]
[(Leaf, Leaf), (Node Leaf Leaf, Leaf), (Leaf, Node Leaf Leaf), (Leaf, Node (Node Leaf Leaf) Leaf)]
        ]]></code>
        <text hooks="math"><![CDATA[ 
We can also easily check whether a particular kind of tree is in the list (such as a non-leaf tree) by adding a value of type <code>()</code> for each matching entry and then checking the length of the list resulting from the comprehension, or by comparing it to the empty list.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
*> length [() | Node _ _ <- example] > 0
True

*> [() | Node _ _ <- example] /= []
True
        ]]></code>
      </example>
    </subsection>
    <subsection title="Modeling and exploring state spaces in a typed declarative/functional language">
      <text hooks="math"><![CDATA[ 
In many artificial intelligence and optimization problems, the collection of possible actions an algorithm, agent, or player can take can be modelled as a state space tree or graph (also sometimes called a decision tree or decision graph) which may or may not be infinite, depending on the length of the process or game being modeled. Algebraic data types and lazy evaluation make it easy to model such graphs.
      ]]></text>
      <example required="true" id="472f945cb582464b91a86bd814acade5">
        <text hooks="math"><![CDATA[ 
Suppose we want to model a <a href="http://en.wikipedia.org/wiki/Tic-tac-toe">Tic-tac-toe</a> game, with the eventual goal of writing an AI algorithm that can play the game well. We can first settle on a representation for the board.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
@data Cell = E | X | O @deriving (Eq, Show)
@type Pos = (Integer, Integer)
@data Board = Board [(Pos, Cell)] @deriving Eq

@instance Show Board @where
  show (Board pcs) = show [c | (p,c) <- pcs]

start :: Board
start = Board [((r,c),E) | r <- [1..3], c <- [1..3]]
        ]]></code>
        <text hooks="math"><![CDATA[ 
Notice that the starting board consists of all empty cells.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
*> start
[E,E,E,E,E,E,E,E,E]
        ]]></code>
        <text hooks="math"><![CDATA[ 
When a player moves, they place an <code>X</code> or <code>O</code> somewhere on the board. We can model this using a function that, given a move, transforms one board into another board. We use a list comprehension that updates only the cell with the corresponding position.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
move :: ((Pos, Cell), Board) -> Board
move ((pos', cell'), Board pcs) = Board [(pos, @if pos' == pos @then cell' @else cell) | (pos, cell) <- pcs]
        ]]></code>
        <text hooks="math"><![CDATA[ 
Suppose we want to make a state space graph that captures all possible paths a Tic-tac-toe game can take from a given starting position, and given a player's current turn. Let us assume that turns can be modelled using an infinite list. For example, here is an infinite list for game in which the <code>X</code> and <code>O</code> players take alternating turns.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
turns :: [Cell]
turns = X:O:turns
        ]]></code>
        <text hooks="math"><![CDATA[ 
We first define a data structure for representing the possible paths a game can take. The data structure is a tree graph in which each node represents a game state (i.e., a <code>Board</code>), and can have any number of child trees (including zero).
        ]]></text>
        <code hooks="Haskell"><![CDATA[
@data DecisionTree = Move Board [DecisionTree] @deriving (Eq, Show)
        ]]></code> 
        <text hooks="math"><![CDATA[ 
Now, we can define a function that builds a decision tree given a starting game state and the player turn sequence. Notice that <code>nextMoves</code> takes a <code>Board</code> and a <code>Cell</code> (to indicate which player is taking a turn), and uses a list comprehension to choose only the board cells that are empty. For each empty cell, it adds a new board state to the list in which that position is filled with the specified player's symbol.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
nextMoves :: (Board, Cell) -> [Board]
nextMoves (Board pcs, cell) = [move ((p, cell), Board pcs) | (p, E) <- pcs]
        ]]></code> 
        <text hooks="math"><![CDATA[ 
Given a starting board and turn sequence, we can now build the tree of state spaces for the entire game.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
tree :: Board -> [Cell] -> DecisionTree
tree b (turn:turns) = Move b [tree b' turns | b' <- nextMoves (b, turn)]
        ]]></code>
        <text hooks="math"><![CDATA[ 
Suppose we have a function <code>win :: Cell -> Board -> Bool</code> that checks if a given board is already a win for a particular player. We can then add an <code>Ord</code> instance to compare boards from player <code>X</code>'s perspective: a board is "greater" (or "better") than another board if either the board is a win for <code>X</code>, or the other board is a loss for <code>O</code>.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
@instance Ord Board @where
  b <= b' = win b' X || win b O
        ]]></code>
        <text hooks="math"><![CDATA[ 
It is now possible to use the built-in operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> to compare boards, as well as library functions such as <code>max :: Board -> Board -> Board</code> and <code>maximum :: [Board] -> Board</code> to choose the "best" boards.
        ]]></text>
      </example>
    </subsection>
    <subsection title="Ad Hoc and Parametric Polymorphism">
      <definition required="true" hooks="math" id="7065360f071a42b1b02e4cb7b73caee8"><![CDATA[
A language supports <i>ad hoc polymorphism</i> if it allows programmers to specify multiple definitions for the same constant or variable (which could be a literal, an operator symbol, a function name, a type, and so on). An interpreter or compiler then choose the appropriate definition to use based on the context (usually, the types of the argument expressions and/or the surrounding expressions and statements in the abstract syntax tree).
<br/><br/>
Common examples of language features that support ad hoc polymorphism include operator overloading in C++, C#, and Python (operator overloading is not supported in Java), method overloading in Java subclasses, Java interfaces, and type classes in Haskell.
      ]]></definition>
      <definition required="true" hooks="math" id="e9497e2275f347cbbc569f810cb58c2d"><![CDATA[
A language supports <i>parametric polymorphism</i> if it allows programmers to specify a single definition for a function or procedure that can then be applied to values of multiple types (typically, a large range of types, or even all types). Typically, the function or procedure will operate on a container type, or some other parameterized or generic type. Thus, languages that support parametric polymorphism usually allow programmers to define data structures that can be parameterized by other data structures. 
<br/><br/>
Common examples of language features that support parametric polymorphism include Java generics and the Haskell type system (the latter uses an extension of the <a href="http://en.wikipedia.org/wiki/Hindley-Milner_type_system">Hindley-Milner type inference algorithm</a> that is also used by the programming language <a href="http://en.wikipedia.org/wiki/ML_(programming_language)">ML</a>).
      ]]></definition>
      <text hooks="math"><![CDATA[ 
Note an important distinction between ad hoc polymorphism and parametric polymorphism: ad hoc polymorphism allows programmers to continue adding new definitions for a given variable or constant within the same scope, while parametric polymorphism only permits a single, albeit generic, definition for a function or procedure within any given scope.
      ]]></text>
      <example required="true" id="e00c647a3e9f4f26b831db647d7c8a78">
        <text hooks="math"><![CDATA[ 
Suppose we define a function <code>len</code> for computing lengths of lists of integers.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
len :: [Integer] -> Integer
len []         = 0
len ((:) x xs) = 1 + len xs
        ]]></code>
        <text hooks="math"><![CDATA[ 
Unfortunately, we cannot use the above function to compute the length of a list of, e.g., <code>Bool</code> values because the type <code>[Integer]</code> does not unify with the type <code>[Bool]</code>. We could write an alternative type to address this.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
len :: [Bool] -> Integer
len []         = 0
len ((:) x xs) = 1 + len xs
        ]]></code>
        <text hooks="math"><![CDATA[ 
We can now use <code>len</code> on lists of type <code>[Bool]</code>, but we can no longer use it on lists of type <code>[Integer]</code>. Notice that the only thing that has changed is the type of the function; the body is the same in both cases. Haskell allows us to take advantage of this by employing a <i>type variable</i>.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
len :: [a] -> Integer
len []         = 0
len ((:) x xs) = 1 + len xs
        ]]></code>
        <text hooks="math"><![CDATA[ 
With the above declaration, it is now possible to apply the <code>len</code> function to a list containing any type of element. This is because the type variable <code>a</code> unifies with any other type (including <code>Bool</code> and <code>Integer</code>), so the input type <code>[a]</code> will unify with both <code>[Integer]</code> and <code>[Bool]</code>, as well as types such as <code>[String -> String]</code> (a list of functions that take <code>String</code> inputs and return <code>String</code> outputs).
        ]]></text>
        <code hooks="Haskell"><![CDATA[
*> len [True, False, True]
3
*> len [1, 2, 3, 4, 5]
5
*> len [\s -> s ++ ".", \t -> t ++ ";"]
2
        ]]></code>
        <text hooks="math"><![CDATA[ 
Since <code>len</code> is a function that can be applied to different input types, but has only a single definition that works for all input types, it is an example of <i>parametric</i> polymorphism.
        ]]></text>
      </example>
      <example required="true" id="b8adf3fedafc40648a90e89dcce10f8c">
        <text hooks="math"><![CDATA[ 
We can define a <code>Set</code> data structure for holding sets of <code>Integer</code> values that has an underlying list implementation.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
@module IntegerSet @where
  
@data Set =
    Empty
  | Set [Integer]
  @deriving Show   
 
insert :: Set -> Integer -> Set
insert (Set l) x = Set (x:l)
insert (Empty) x = Set [x]

contains :: Integer -> Set -> Bool
contains x (Empty) = False
contains x (Set l) = x `elem` l
        ]]></code>
        <text hooks="math"><![CDATA[ 
However, what if we also want user to have the option of using a data structure for sets that uses an underlying binary search tree implementation? We can first define a class for set data structures that specifies the signatures of the functions that a set data structure must support. We can even define new functions that rely only on the signature.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
@module SetClass @where

@class IsSet s @where
  empty :: s
  insert :: s -> Integer -> s
  contains :: Integer -> s -> Bool
  
  inserts :: s -> [Integer] -> s
  inserts s (x:xs) = inserts (insert s x) xs
  inserts s []     = s
        ]]></code>
        <text hooks="math"><![CDATA[ 
This makes it possible to provide two different implementations that are both members of this class.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
@module IntegerSetList @where

@import SetClass
  
@data IntegerSetList =
    Empty
  | Set [Integer]
  @deriving Show   

@instance IsSet IntegerSetList @where
  empty = Empty

  insert (Set l) x = Set (x:l)
  insert (Empty) x = Set [x]

  contains x (Empty) = False
  contains x (Set l) = x `elem` l
        ]]></code>
        <code hooks="Haskell"><![CDATA[
@module IntegerSetTree @where

@import SetClass

@data IntegerSetTree =
    Leaf
  | Node Integer IntegerSetTree IntegerSetTree
  @deriving Show   

@instance IsSet IntegerSetTree @where
  empty = Leaf

  insert (Leaf       ) x = Node x Leaf Leaf
  insert (Node y s s') x =
    @if x < y @then 
      Node y (insert s x) s' 
    @else
      Node y s (insert s' x)

  contains x (Leaf       ) = False
  contains x (Node y s s') =
    @if y == x @then
      True
    @else @if x < y @then
      contains x s
    @else
      contains x s'
        ]]></code>
      </example>
      <text hooks="math"><![CDATA[ 
Haskell type classes need not contain types; they can also contain type constructors (i.e., functions in the type system that can be used to construct a type given a type, i.e., type constructors with kind <code>Type -> Type</code>, and so on).
      ]]></text>
      <example required="true" id="1dade7b3338943cebc188d3b4b9890ba">
        <text hooks="math"><![CDATA[ 
We can define a <code>Set</code> data structure for holding sets of values of any type <code>a</code>.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
@module Set @where
  
@data Set a =
    Empty
  | Set [a]
  @deriving Show   
 
insert :: Set a -> a -> Set a
insert (Set l) x = Set (x:l)
insert (Empty) x = Set [x]

contains :: Eq a => a -> Set a -> Bool
contains x (Empty) = False
contains x (Set l) = x `elem` l
        ]]></code>
        <text hooks="math"><![CDATA[ 
However, what if we also want user to have the option of using a data structure for sets that uses an underlying binary search tree implementation? We can first define a class for set data structures that specifies the signatures of the functions that a set data structure must support. We can even define new functions that rely only on the signature.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
@module SetClass @where

@class IsSet s @where
  empty :: s a
  insert :: Ord a => s a -> a -> s a
  contains :: (Ord a, Eq a) => a -> s a -> Bool
  
  inserts :: Ord a => s a -> [a] -> s a
  inserts s (x:xs) = inserts (insert s x) xs
  inserts s []     = s
        ]]></code>
        <text hooks="math"><![CDATA[ 
This makes it possible to provide two different implementations of polymorphic set data structures that are both members of this class. Notice that we added the <code>Ord a</code> constraint on the element type <code>a</code> in case we want to compare them (e.g., if we are using a binary search tree implementation of sets).
        ]]></text>
        <code hooks="Haskell"><![CDATA[
@module SetList @where

@import SetClass
  
@data SetList a =
    Empty
  | Set [a]
  @deriving Show   

@instance IsSet SetList @where
  empty = Empty

  insert (Set l) x = Set (x:l)
  insert (Empty) x = Set [x]

  contains x (Empty) = False
  contains x (Set l) = x `elem` l
        ]]></code>
        <code hooks="Haskell"><![CDATA[
@module SetTree @where

@import SetClass

@data SetTree a =
    Leaf
  | Node a (SetTree a) (SetTree a)
  @deriving Show   

@instance IsSet SetTree @where
  empty = Leaf

  insert (Leaf       ) x = Node x Leaf Leaf
  insert (Node y s s') x =
    @if x < y @then 
      Node y (insert s x) s' 
    @else
      Node y s (insert s' x)

  contains x (Leaf       ) = False
  contains x (Node y s s') =
    @if y == x @then
      True
    @else @if x < y @then
      contains x s
    @else
      contains x s'
        ]]></code>
      </example>
      <example required="true" id="a881f643ee054befa199c31d8d46390a">
        <text hooks="math"><![CDATA[ 
Suppose we have a <code>Set</code> data structure for holding sets of values of any type <code>a</code> that has a corresponding <code>size :: Set a -> Int</code> function.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
@module Set @where
  
@data Set a =
    Empty
  | Set [a]
  @deriving (Eq, Show)   
 
size :: Set a -> Int
size (Set l) = length l
size (Empty) = 0
        ]]></code>
        <text hooks="math"><![CDATA[ 
We can make it possible to order sets by their size using the <code>&lt;</code> operator by making the type <code>Set a</code> (for any possible <code>a</code>) a member of the <code>Ord</code> type class.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
@instance Eq a => Ord (Set a) @where
  s < s' = size s < size s'
        ]]></code>
        <text hooks="math"><![CDATA[ 
Note that the instance declaration is prepended with the condition that the type <code>a</code> must be in the <code>Eq</code> type class. This is because the definition of <code>Set a</code> contains a <code>deriving Eq</code> clause, which means that a type <code>Set a</code> can only be used in a module if the parameter type <code>a</code> is a member of the <code>Eq</code> type class (otherwise, Haskell would not be able to compare two sets for equality using the automatically derived definition of <code>(==)</code> generated by the <code>deriving Eq</code> clause).
        ]]></text>
      </example>
    </subsection>
    <subsection title="Folds, Unfolds, and Algebraic Properties of Functional Programs">
      <text><![CDATA[
We have seen that the operational semantics of declarative and functional languages support an approach to problem solving that involves first defining a model of some system, and then querying that model to answer questions about that system or explore its properties. We can define this approach to programming with more consistency and mathematical rigor by identifying the mathematical transformations that are typically employed and composed when using this approach. In particular, most component operations fall into two categories:
<ul>
  <li><i><b>unfold</b></i> (or <i>anamorphism</i>) operations are used to define or construct a data value;</li>
  <li><i><b>fold</b></i> (or <i>catamorphism</i>) operations are used to reduce, simplify, break down, or transform a data value.</li>
</ul>
      ]]></text>
      <text><![CDATA[
A few special cases of the composition of a <b>fold</b> followed by an <b>unfold</b> are commonly used, as well (these are commonly implemented using comprehensions when the data value being transformed is a set or list):
      ]]></text>
      <text><![CDATA[
<ul>
  <li><i><b>map</b></i> (sometimes known as <i>metamorphism</i>) operations are used to modify all the components of a data value using a single, often local transformation that is applied to all the components across the entire data value;</li>
  <li><i><b>filter</b></i> operations are used to remove (or select) only some of the components of a data value.</li>
</ul>
<br/>
The ability to describe an algorithm using a composition of <b>unfold</b>, <b>fold</b>, <b>map</b>, and <b>filter</b> operations imposes fewer restrictions on how that computation can be carried out (when compared to a description of the same algorithm using a sequential list of operations). A description using <b>fold</b>, <b>map</b>, and so on may still impose some <i>hierarchical</i> dependencies on the computation, but the operational semantics of such a description allows an implementation (or a compiled version) of the algorithm to perform operations in parallel <i>unless</i> such parallelization is explicitly forbidden by the algorithm itself through explicit sequential dependencies introduced by the programmer. In other words, <b>the default interpretation of such an algorithm definition is inherently parallelizable</b>.
<br/><br/>
Defining the above operations on algebraic data types (including polymorphic algebraic data types) is often a straightforward process (in fact, it can often be automated). The Haskell <a href="http://hackage.haskell.org/package/base">base</a> library provides functions for all of the above operations on Haskell lists, and many library functions are implemented using these functions; the Haskell compiler is optimized to compile these functions into efficient machine code. Most of the above functions are also supported by languages such as Python.
      ]]></text>
      <example required="true" id="e99b09b7d7054dcd8603ae063fae8fb7">
        <text hooks="math"><![CDATA[ 
We can begin by implementing a <b>fold</b> operation on Haskell <code>Integer</code> lists that does nothing.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
fold :: [Integer] -> [Integer]
fold []     = []
fold (x:xs) = x : fold xs
        ]]></code>
        <text hooks="math"><![CDATA[ 
We can modify the above to replace the two list constructors (i.e., <code>(:)</code> and <code>[]</code>) in the input list with a binary operator and a base case (in this case, <code>(+)</code> and <code>0</code>). This way, the <code>fold</code> function now computes the sum of the elements in the list.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
fold :: [Integer] -> Integer
fold []     = 0
fold (x:xs) = x + fold xs
        ]]></code>
        <text hooks="math"><![CDATA[ 
We can further generalize the above so that it takes the two replacement functions as arguments. The two functions are a replacement for <code>(:)</code>, so it must be of type <code>Integer -> Integer -> Integer</code>, and a replacement for <code>[]</code>, which must be of type <code>Integer</code>.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
fold :: (Integer -> Integer -> Integer) -> Integer -> [Integer] -> Integer
fold f b []     = b
fold f b (x:xs) = f x (fold f b xs)
        ]]></code>
        <text hooks="math"><![CDATA[ 
We can now use the above <code>fold</code> implementation to define many common functions on lists of integers.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
sum :: [Integer] -> Integer
sum = fold (+) 0

product :: [Integer] -> Integer
product = fold (*) 1

maximum :: [Integer] -> Integer
maximum = fold max 0 -- Assumes non-negative integers.

minimum :: [Integer] -> Integer
minimum l = fold min (fold max 0 l) l
        ]]></code>
      </example>
      <example required="true" id="173d61a62368428bb5f7bfc393d45ab8">
        <text hooks="math"><![CDATA[ 
The fold function for the default right-associative list implementation supported by Haskell (i.e., with the built-in constructors <code>(:)</code> and <code>[]</code>) is called <code>foldr</code>.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f base []     = base
foldr f base (x:xs) = f x (foldr f base xs)
        ]]></code>
        <text hooks="math"><![CDATA[ 
The <code>foldr</code> function can be used to implement many of the usual library functions one might find useful when working with lists, and this is what is done in the Haskell libraries. Below are some examples (some of these are simplified versions of what is actually found in the libraries).
        ]]></text>
        <code hooks="Haskell"><![CDATA[
sum :: Num a -> [a] -> a
sum xs = foldr (+) 0 xs

max :: Ord a => a -> a -> a
max x y = if x > y then x else y

maximum :: Ord a => [a] -> a
maximum xs = foldr max 0 xs
        ]]></code>
      </example>
      <example required="true" id="cc555577086f4c8bae8ba7fae4d62c8b">
        <text hooks="math"><![CDATA[ 
We can implement any <b>map</b> operation as a fold. Suppose we want to add the constant <code>1</code> to every element in an <code>Integer</code> list. For example, we want to achieve the following using a call to <code>foldr</code>:
        ]]></text>
        <code hooks="Haskell"><![CDATA[
*> [x + 1 | x <- [1,2,3,4,5]]
[2,3,4,5,6]
        ]]></code>
        <text hooks="math"><![CDATA[ 
We can accomplish this by defining a modified list node constructor function that adds <code>1</code> to its first argument, then builds the list node:
        ]]></text>
        <code hooks="Haskell"><![CDATA[
addOneThenCons :: Integer -> [Integer] -> [Integer]
addOneThenCons x xs = (x + 1) : xs
        ]]></code>
        <text hooks="math"><![CDATA[ 
We can now use the above together with <code>foldr</code>:
        ]]></text>
        <code hooks="Haskell"><![CDATA[
*> foldr addOneThenCons [] [1,2,3,4,5]
[2,3,4,5,6]
        ]]></code>
        <text hooks="math"><![CDATA[ 
Using \lambda abstractions, we can avoid having to explicitly define <code>addOneThenCons</code>:
        ]]></text>
        <code hooks="Haskell"><![CDATA[
*> foldr (\x xs -> (x+1) : xs) [] [1,2,3,4,5]
[2,3,4,5,6]
        ]]></code>
      </example>
      <example required="true" id="7e489ac9ffdb41c7b295ea16c0255ebc">
        <text hooks="math"><![CDATA[ 
We can implement any <b>filter</b> operation as a fold. For example, suppose we want to only keep positive integers from an integer list:
        ]]></text>
        <code hooks="Haskell"><![CDATA[
*> [x | x <- [-3,-2,-1,0,1,2,3], x > 0]
[1,2,3]
        ]]></code>
        <text hooks="math"><![CDATA[ 
We can accomplish this by defining a modified list node constructor function that only adds a new list node if the data inside it is a positive integer:
        ]]></text>
        <code hooks="Haskell"><![CDATA[
consIfPositive :: Integer -> [Integer] -> [Integer]
consIfPositive x xs = @if x > 0 @then x : xs @else xs
        ]]></code>
        <text hooks="math"><![CDATA[ 
We can now use the above together with <code>foldr</code>:
        ]]></text>
        <code hooks="Haskell"><![CDATA[
*> foldr consIfPositive [] [-3,-2,-1,0,1,2,3]
[1,2,3]
        ]]></code>
        <text hooks="math"><![CDATA[ 
Using \lambda abstractions, we can avoid having to explicitly define <code>consIfPositive</code>:
        ]]></text>
        <code hooks="Haskell"><![CDATA[
*> foldr (\x xs -> @if x > 0 @then x : xs @else xs) [] [-3,-2,-1,0,1,2,3]
[1,2,3]
        ]]></code>
      </example> 
      <example required="true" id="cec4b16ab14e4db49fb478aef9bd846b">
        <text hooks="math"><![CDATA[ 
We can implement an easily parallelizable version of quicksort using <b>filter</b> operations:
        ]]></text>
        <code hooks="Haskell"><![CDATA[
qsort :: [Integer] -> [Integer]
qsort []     = []
qsort (x:xs) = qsort [y | y <- xs, y < x] ++ [x] ++ qsort [y | y <- xs, y >= x]
        ]]></code>
      </example>
      <example required="true" id="2cc51f6d51e54601a95b14a30fe459a3">
        <text hooks="math"><![CDATA[ 
We can implement a <b>fold</b> operation that works for associative binary operators that recursively splits the problem into two parts over and over until a base case is reached.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
fold :: (a -> a -> a) -> a -> [a] -> a
fold f b []  = b
fold f b [x] = x
fold f b xs  =
  fold f b (take (length xs `div` 2) xs)
    `f` 
  fold f b (drop (length xs `div` 2) xs)
        ]]></code>
        <text hooks="math"><![CDATA[ 
If each recursive invocation were run on a separate thread, processor, server, and so on, this would maximum the amount of parallelization that can be achieved in performing this <b>fold</b> operation.
        ]]></text>
      </example>
      <example title="filter, map, and fold operations in SQL-like languages" required="true" id="7e489ac9ffdb41c7b295ea16c0255ebc">
        <text hooks="math"><![CDATA[ 
SQL-like languages (as well as the <a href="http://en.wikipedia.org/wiki/Relational_algebra">relational algebra</a> on which they are based) can be viewed as supporting fold, map, and filter operations (and compositions thereof) on a particular data structure: a table. This allows databases to be distributed across multiple storage devices, and it makes it possible to simultaneously query different portions of a database, stored on different devices, using multiple computational devices (processors, virtual machines, servers, and so on) running in parallel.
<br/><br/>
For example, suppose an SQL table consists of some number of rows, and each row has an entry of the form <code>(Name, Age)</code>:
        ]]></text>
        <code hooks="Haskell"><![CDATA[
+---------------+
|    People     |
+---------------+
| Name  |  Age  |
+-------+-------+
| Alice |  20   |
| Bob   |  17   |
| Carl  |  23   |
+-------+-------+
        ]]></code>
        <text hooks="math"><![CDATA[ 
The following SQL query allows a user to retrieve only the <code>Name</code> entries in the table; this query amounts to a <b>map</b> operation:
        ]]></text>
        <code hooks="SQL"><![CDATA[
> @SELECT Name @FROM People

+-------+
| Name  |
+-------+
| Alice |
| Bob   |
| Carl  |
+-------+
        ]]></code>
        <text hooks="math"><![CDATA[ 
The following SQL query allows a user to retrieve only the entries within a certain <code>Age</code> range; this query amounts to a <b>filter</b> operation:
        ]]></text>
        <code hooks="SQL"><![CDATA[
> @SELECT * @FROM People @WHERE Age >= 18

+---------------+
| Name  |  Age  |
+-------+-------+
| Alice |  20   |
| Carl  |  23   |
+-------+-------+
        ]]></code>
        <text hooks="math"><![CDATA[ 
The following SQL query allows a user to retrieve the sum of the <code>Age</code> fields of all the entries; this query amounts to <b>fold</b> operation (it is often called an aggregation operation):
        ]]></text>
        <code hooks="SQL"><![CDATA[
> @SELECT @SUM(Age) @FROM People

+-------+
|  Age  |
+-------+
|  60   |
+-------+
        ]]></code>
        <text hooks="math"><![CDATA[ 
We can easily simulate all of the above capabilities using another language that supports the declarative and functional programming paradigms, such as Haskell. Suppose we have the following definitions:
        ]]></text>
        <code hooks="Haskell"><![CDATA[
@type Name = String
@type Age = Integer
@type Table = [(Name, Age)]

people = [("Alice", 20), ("Bob", 17), ("Carl", 23)]
        ]]></code>
        <text hooks="math"><![CDATA[ 
We can then perform the following queries:
        ]]></text>
        <code hooks="Haskell"><![CDATA[
*> [name | (name, age) <- people]
["Alice", "Bob", "Carl"]

*> [(name, age) | (name, age) <- people, age >= 18]
[("Alice", 20), ("Carl", 23)]

*> foldr (+) 0 [age | (name, age) <- people]
60
        ]]></code>
        <text hooks="math"><![CDATA[ 
Equivalently, we can use <code>map</code>, <code>filter</code>, <code>foldr</code>, and \lambda abstractions instead of list comprehensions (the Haskell compiler simply converts list comprehensions into some combination of these during compilation):
        ]]></text>
        <code hooks="Haskell"><![CDATA[
*> map (\(name, age) -> name) people
["Alice", "Bob", "Carl"]

*> map fst people
["Alice", "Bob", "Carl"]

*> filter (\(name, age) -> age >= 18) people]
[("Alice", 20), ("Carl", 23)]

*> foldr (+) 0 (map snd people)
60
        ]]></code>
        <text hooks="math"><![CDATA[ 
All of the above can also be done using Python list comprehensions:
        ]]></text>
        <code hooks="Python"><![CDATA[
>>> People = [("Alice", 20), ("Bob", 17), ("Carl", 23)]

>>> [name @for (name, age) @in People]
["Alice", "Bob", "Carl"]

>>> [(name, age) @for (name, age) @in People @if age >= 18]
[('Alice', 20), ('Carl', 23)]

>>> @sum([age @for (name, age) @in People])
60
        ]]></code>
        <text hooks="math"><![CDATA[ 
Python also supports <code>map</code>, <code>filter</code>, <code>reduce</code> (similar to Haskell's <code>foldr</code>), and lambda abstractions:
        ]]></text>
        <code hooks="Python"><![CDATA[

>>> @list(@map((@lambda person: person[0]), People))
['Alice', 'Bob', 'Carl']

>>> @list(@filter((@lambda person: person[1] >= 18), People))
[('Alice', 20), ('Carl', 23)]

>>> @from functools @import reduce
>>> reduce(@lambda x,y: x + y, [age @for (name, age) @in People])
60
        ]]></code>
      </example>
      <example title="filter and map operations in JavaScript libraries" required="true" id="6235f5ed98124301bb2a7cac0f08cd03">
        <text hooks="math"><![CDATA[
Many JavaScript libraries, such as <a href="http://jquery.com/">jQuery</a>/<a href="http://jqueryui.com/">jQuery UI</a>, <a href="http://nodejs.org/">node.js</a>, <a href="http://d3js.org/">d3</a>, and others support an abstraction for manipulating web documents (which are often used as application components on the web today) that is organized around <b>filter</b> and <b>map</b> operations.
<br/><br/>
In jQuery, it is possible to select all the elements with a certain tag in an HTML document and then to specify a function that will be applied to each element selected. This corresponds to the composition of a <b>filter</b> and <b>map</b> operation.
<br/><br/>
For example, the following code selects all the <code>li</code> elements and updates the text content of each to indicate the item number corresponding to that element. Notice that the <code>.text()</code> function takes a function as an argument (the function supplied as an argument takes an index as an input and returns a string):
        ]]></text>
        <code hooks="JavaScript"><![CDATA[
$("ul li").text(
  @function( index ) {
    @return "item number " + ( index + 1 );
  }
);
        ]]></code>
        <text hooks="math"><![CDATA[
More generally, it's possible to update individual document elements using the <a href="http://api.jquery.com/each/"><code>.each()</code></a> function.
        ]]></text>
      </example>
    </subsection>
    <assignment title="Embedded Languages and State Space Search">
      <instructions>
        <text><![CDATA[
In this assignment you will practice using the declarative and functional programming language Haskell by implementing a small embedded language, and by building a library of algorithms for solving an optimization problem. You must submit two files:
<ul>
  <li><code><a href="hw5/Database.hs">hw5/Database.hs</a></code>;</li>
  <li><code><a href="hw5/Allocation.hs">hw5/Allocation.hs</a></code>.</li>
</ul>
Please follow the <a href="#A">gsubmit</a> directions and remember to put your files in the <code>hw5</code> directory.
        ]]></text>
        <paragraph><![CDATA[
Your solutions to each of the problem parts below will be graded on their correctness, concision, and mathematical legibility. The different problems and problem parts rely on the lecture notes and on each other; carefully consider whether you can use functions from the lecture notes, or functions you define in one part within subsequent parts.
        ]]></paragraph>
        <paragraph><![CDATA[
<b style="color:green;">A testing script with several test cases is available for download: <a href="hw5-tests.hs"><code>hw5-tests.hs</code></a>. You should be able to place it in the same directory with the other assignment files and load it. Feel free to modify or extend it as you see fit.</b>
<!--<br/><br/>
<b style="color:green;">A full solution to this assignment is now available here: <a href="hw5/solutions/"><code>/hw5/solutions</code></a>.</b>
-->
        ]]></paragraph>
      </instructions>
      <problems>
        <problem>
          <text><![CDATA[
In this problem you will implement an interpreter for a small embedded programming language. Your solutions should be included in the file <code><a href="hw5/Database.hs">hw5/Database.hs</a></code>.
          ]]></text>
          <paragraph><![CDATA[
The module <code>Database</code> already contains data type definitions below for representing the syntax of the embedded language.
          ]]></paragraph>
          <code hooks="Haskell"><![CDATA[
@type Column = String
@data User = User String @deriving (Eq, Show)
@data Table = Table String @deriving (Eq, Show)
@data Command =
    Add User
  | Create Table
  | Allow (User, Table)
  | Insert (Table, [(Column, Integer)])
  @deriving (Eq, Show)
          ]]></code>
          <text><![CDATA[
A program in this language will consist of a list of elements of values (i.e., a value of type <code>[Command]</code>) such as the following example.
          ]]></text>
          <code hooks="Haskell"><![CDATA[
example :: [Command]
example = [
    Add (User "Alice"),
    Add (User "Bob"),
    Create (Table "Revenue"),
    Insert (Table "Revenue", [("Day", 1), ("Amount", 2400)]),
    Insert (Table "Revenue", [("Day", 2), ("Amount", 1700)]),
    Insert (Table "Revenue", [("Day", 3), ("Amount", 3100)]),
    Allow (User "Alice", Table "Revenue")
  ]
          ]]></code>
          <parts>
            <part>
              <text><![CDATA[
Implement a function <code>select :: [Command] -> User -> Table -> Column -> Maybe [Integer]</code> that takes four arguments: a list of commands describing the current state of the database, the user evaluating the query, the table on which the query is being evaluated, and the name of the column the user wants to select. <b>Hint:</b> use <a href="#7.13">list comprehensions with pattern matching</a>.
              ]]></text>
              <paragraph><![CDATA[
If the specified user has permission to query the table, the function should return a list of integers corresponding to the values in the specified column of the specified table (wrapped with the <code>Just</code> constructor). If the user or table do not exist, or if the specified user does not have permission to query the specified table, the function should return <code>Nothing</code>.
              ]]></paragraph>
              <code hooks="Haskell"><![CDATA[
*Database> select example (User "Alice") (Table "Revenue") "Day"
Just [1,2,3]

*Database> select example (User "Alice") (Table "Revenue") "Amount"
Just [2400,1700,3100]

*Database> select example (User "Bob") (Table "Revenue") "Amount"
Nothing
              ]]></code>
            </part>
            <part>
              <text><![CDATA[
Implement a function <code>aggregate :: [Command] -> User -> Table -> Column -> Operator -> Integer -> Maybe Integer</code> that takes six arguments: a list of commands describing the current state of the database, the user evaluating the query, the table on which the query is being evaluated, the name of the column to aggregate, an operator (of type <code>Integer -> Integer -> Integer</code>) to use when aggregating the values in the specified column, and a base integer to use with that operation. <b>Hint:</b> use <code>foldr</code>.
              ]]></text>
              <paragraph><![CDATA[
If the specified user has permission to query the table, the function should return the aggregate (with respect to the supplied aggregator function) of the integers corresponding to the values in the specified column of the specified table (wrapped with the <code>Just</code> constructor). If the user or table do not exist, or if the specified user does not have permission to query the specified table, the function should return <code>Nothing</code>.
              ]]></paragraph>
              <code hooks="Haskell"><![CDATA[
*Database> aggregate example (User "Alice") (Table "Revenue") "Amount" (+) 0
Just 7200
              ]]></code>
            </part>
            <part>
              <text><![CDATA[
Implement a function <code>validate :: [Command] -> Bool</code> that checks that every command in the list refers to a table that has already been created and a user that has already been added earlier in the list of commands. If every command is valid, it should return <code>True</code>; otherwise, it should return <code>False</code>. <b>Hint</b>: write a helper function and call it on a reversed list of commands, then check each command against the rest of the list.
              ]]></text>
            </part>
          </parts>
        </problem>
        <problem>
          <text hooks="math"><![CDATA[   
In this problem, you will implement a small library for representing and working with a state space graph for an optimization problem. All the functions you define should be included in the file <code><a href="hw5/Allocation.hs">hw5/Allocation.hs</a></code>.
<br/><br/>
The optimization problem we are addressing is defined as follows: given a list of items, each of a certain integer size, put each item into one of two bins so that once all items have been allocated, the sum of the sizes of the items in the first bin is as close as possible to the sum of the items in the second bin (note that this optimization problem is NP-complete and is equivalent to the <a href="http://en.wikipedia.org/wiki/Subset_sum_problem">subset sum problem</a>, so no efficient solution for the problem is believed to exist).
        ]]></text>
          <parts>
            <part>
              <text><![CDATA[
We will represent an allocation of items (either in the midst of running an optimization algorithm or within a final result) using the data type <code>Alloc</code>:
              ]]></text>
              <code hooks="Haskell"><![CDATA[
@data Alloc = Alloc Bin Bin @deriving (Eq, Show)
              ]]></code>
              <text><![CDATA[
We will represent the graph of possible states that an algorithm can traverse given a starting allocation and a list of tasks using the <code>Graph a</code> data type:
              ]]></text>
              <code hooks="Haskell"><![CDATA[
@data Graph a =
    Branch a (Graph a) (Graph a) 
  | Finish a
  @deriving (Eq, Show)
              ]]></code>
              <text><![CDATA[
Define a function <code>graph :: Alloc -> [Item] -> Graph Alloc</code> that takes a starting allocation and a list of items, and returns the full graph of all possible state space traversals available to an algorithm given the list of items. An example is provided below (spacing has been adjusted for legibility):
              ]]></text>
              <code hooks="Haskell"><![CDATA[
*> graph (Alloc 0 0) [1,2]
Branch (Alloc 0 0) 
  (Branch (Alloc 1 0) 
    (Finish (Alloc 3 0)) 
    (Finish (Alloc 1 2))
  )
  (Branch (Alloc 0 1) 
    (Finish (Alloc 2 1)) 
    (Finish (Alloc 0 3))
  )
              ]]></code>
              <text><![CDATA[
The definition must work even if the supplied list of items is infinite.
              ]]></text>
            </part>
            <part>
              <text><![CDATA[
Define a parametric polymorphic function <code>contents :: Graph a -> a</code> that makes it easy to retrieve the value of type <code>a</code> stored within the root node of a particular graph of type <code>Graph a</code>.
              ]]></text>
              <code hooks="Haskell"><![CDATA[
*> contents (Finish "abc")
"abc"
*> contents (Branch True (Finish False) (Finish True))
True
*> contents (Finish (Alloc 0 0))
Alloc 0 0
              ]]></code>
            </part>
            <part>
              <text><![CDATA[
One allocation <code>b :: Alloc</code> is <i>better</i> than another allocation <code>c :: Alloc</code> if the difference between the two bin totals in <code>b</code> is less than the difference between the two bin totals in <code>c</code>. Add an instance declaration for the <code>Alloc</code> type so that it is possible to use the built-in Haskell infix operators <code>&lt;</code> and <code>&lt;=</code> to compare two allocations according to their differences. You may use the Haskell library function <code>abs :: Integer -> Integer</code> to compute the absolute value of an integer. <b style="color:green;">If you're getting a stack overflow when testing <code>&lt;</code>, make sure you also define <code>&lt;=</code> explicitly.</b>
              ]]></text>
              <code hooks="Haskell"><![CDATA[
*> (Alloc 1 4) < (Alloc 5 10)
True
*> (Alloc 10 4) < (Alloc 1 3)
False
              ]]></code>
            </part>
            <part>
              <text><![CDATA[
One graph <code>g :: Graph a</code> is <i>better</i> (i.e., <i>less than</i>) than another graph <code>g' :: Graph a</code> if according to the ordering on the node contents, the contents of <code>g</code> are <i>less than</i> the contents of <code>g'</code>. Add an instance declaration for the <code>Graph a</code> type so that it is possible to use the built-in Haskell infix operator <code>&lt;</code> to compare two graphs (regardless of what the type <code>a</code> of the content of the graph might be).
              ]]></text>
              <code hooks="Haskell"><![CDATA[
*> (Finish (Alloc 1 4)) < (Finish (Alloc 5 10))
True
*> (Finish "a") < (Finish "b")
True
              ]]></code>
            </part>
            <part>
              <text><![CDATA[
Define a parametric polymorphic function <code>final :: Graph a -> [a]</code> that returns an aggregate list of the contents within <i>all</i> the leaf nodes of the supplied state space graph.
              ]]></text>
            </part>
            <part>
              <text><![CDATA[
Define a parametric polymorphic function <code>depth :: Integer -> Graph a -> [a]</code> that returns the contents within the state space graph nodes that are at depth exactly <code>n</code> within the state space graph (the root node is at depth <code>0</code>).
              ]]></text>
            </part>
          </parts>
        </problem>
        <problem>
          <text><![CDATA[
In this problem, you will implement a small library of algorithms for solving the bin packig optimization problem we defined above. All the functions you define should be included in the file <code><a href="hw5/Allocation.hs">hw5/Allocation.hs</a></code>.
<br/><br/>
A <i>strategy</i> is an algorithm that can traverse the state space graph; given an existing graph, it chooses some descendant node in the graph and returns the subgraph for which that descendant node is the root.
          ]]></text>
          <code hooks="Haskell"><![CDATA[
@type Strategy = Graph Alloc -> Graph Alloc
          ]]></code>
          <parts>
            <part>
              <text><![CDATA[
Define a strategy <code>greedy :: Strategy</code> that takes a graph as an input. It should choose and return the <i>better</i> child of the two children of the root of the graph.
              ]]></text>
            </part>
            <part>
              <text><![CDATA[
Define a strategy <code>patient :: Integer -> Strategy</code> that takes an integer argument <code>n</code> and a graph as its two inputs, and chooses and returns the <i>best</i> descendant of the supplied graph that can be found at depth <code>n</code> (an allocation is <i>best</i> if it is better than all others at that depth). If <code>n</code> is <code>0</code>, the function should simply return the graph supplied to it as an input.
              ]]></text>
            </part>
            <part>
              <text><![CDATA[
Define a strategy <code>optimal :: Strategy</code> that takes a state space graph, and returns the leaf node in the state space graph that has the <i>best</i> allocation. <b>Hint:</b> you can define this function in two lines; look carefully over the functions already available to you.
              ]]></text>
            </part>
            <part>
              <text><![CDATA[
Define a metastrategy <code>metaCompose :: Strategy -> Strategy -> Strategy</code> that takes two strategies as arguments. It should apply the first strategy to obtain a new subgraph, and then it should apply the second strategy to that subgraph and return the result.
              ]]></text>
              <code hooks="Haskell"><![CDATA[
*> (metaCompose greedy greedy) (graph (Alloc 0 0) [1,2,3])
Branch (Alloc 2 1) (Finish (Alloc 5 1)) (Finish (Alloc 2 4))
*> (metaCompose (patient 2) greedy) (graph (Alloc 0 0) [1,2,3,4])
Branch (Alloc 2 4) (Finish (Alloc 6 4)) (Finish (Alloc 2 8))
              ]]></code>
            </part>
            <part>
              <text><![CDATA[
Define a metastrategy <code>metaRepeat :: Integer -> Strategy -> Strategy</code> that repeats a given strategy a specified number of times. Your definition of <code>metaRepeat</code> should take an <code>Integer</code> and a <code>Graph</code> argument. If the integer is <code>0</code>, it should simply return the graph unchanged. If the integer is positive, it should apply the strategy the specified number of times to the graph and then return the result.
              ]]></text>
            </part>
            <part>
              <text><![CDATA[
Define a metastrategy <code>metaGreedy :: Strategy -> Strategy -> Strategy</code> that takes two strategies as its inputs. It should apply the two strategies to its input graph and should return the <i>better</i> of the two results that it obtains.
              ]]></text>
            </part>
            <part>
              <text><![CDATA[
Consider the following strategy:
              ]]></text>
              <code hooks="Haskell"><![CDATA[
impatient :: Integer -> Strategy
impatient n g = (metaRepeat n greedy) g
              ]]></code>
              <text><![CDATA[
Describe one way in which <code>impatient</code> is superior to <code>patient</code>, and one way in which it is inferior. 
              ]]></text>
            </part>
          </parts>
        </problem>
        <problem>
          <text><![CDATA[
<b>Extra credit:</b> Define a metastrategy <code>fit :: Graph -> [Strategy] -> Strategy</code> that takes a graph and a list of strategies as inputs; this metastrategy should choose the strategy in the list of strategies that has the best performance on the given graph, and return it. <b>Hint:</b> define a way to compare strategies and use <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-List.html#v:minimumBy"><code>minimumBy</code></a>.
          ]]></text>
        </problem>
      </problems>
    </assignment>
    <subsection title="Folds, Monads, and Algebraic Properties of Programs">
      <text><![CDATA[
In this section we introduce several consequences of viewing programs as a collection of functions (possibly assembled from building blocks such as folds and unfolds) that can be composed.
      ]]></text>
      <example required="true" id="90686c651b844976b9c69e2ab6e1064c">
        <text hooks="math"><![CDATA[ 
Suppose we have the following definition for a polymorphic data type <code>Tree a</code>:
        ]]></text>
        <code hooks="Haskell"><![CDATA[
@data Tree a =
    Node a (Tree a) (Tree a)
  | Leaf
  @deriving Show
        ]]></code>
        <text hooks="math"><![CDATA[ 
To determine how to put together a <code>foldTree</code> function for values of type <code>Tree a</code>, we first list all the constructors for <code>Tree a</code> (we could also get this information using the <code>:t</code> command in GHCi):
        ]]></text>
        <code hooks="Haskell"><![CDATA[
Node :: a -> Tree a -> Tree a -> Tree a
Leaf :: Tree a
        ]]></code>
        <text hooks="math"><![CDATA[ 
A fold function will simply replace all instances of <code>Node</code> and <code>Leaf</code> in a tree with different value or function (for example, let's call <code>Node</code>'s replacement <code>n</code> and <code>Leaf</code>'s replacement <code>l</code>); this means that the replacement values and functions must have a type that has the same structure (i.e., they must take the same number of arguments) as the constructors they replace. However, they will fold into some new type of value <code>b</code>, so we replace every instance of <code>Tree a</code> with the new result type <code>b</code>:
        ]]></text>
        <code hooks="Haskell"><![CDATA[
n :: a -> b -> b -> b
l :: b
        ]]></code>
        <text hooks="math"><![CDATA[ 
We can now write our <code>foldTree</code> function to take the above two arguments, and then the tree that is being folded as the last argument. Every <code>Node</code> will be replaced with <code>n</code> and every <code>Leaf</code> will be replaced with <code>l</code>. Notice that in the case of <code>Node</code>, we also recursively fold the trees, since we need to turn them into the result type <code>b</code> before we can apply <code>n :: a -> b -> b -> b</code>.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
foldTree :: (a -> b -> b -> b) -> b -> Tree a -> b
foldTree n l (Node x t1 t2) = n x (foldTree n l t1) (foldTree n l t2)
foldTree n l Leaf           = l
        ]]></code>
        <text hooks="math"><![CDATA[ 
Notice that a <code>mapTree</code> function is just a special case of fold in which <code>n x t1 t2 = Node (f x) t1 t2</code> for some function <code>f</code>, and where <code>l = Leaf</code>, since we want to change each value of type <code>a</code> inside the tree, but not the nodes of the tree themselves. This also means we no longer need <code>n</code> and <code>l</code> as arguments; we only need <code>f</code>.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
mapTree :: (a -> c) -> (Tree a -> Tree c)
mapTree f (Node x t1 t2) = Node (f x) (mapTree f t1) (mapTree f t2)
mapTree f Leaf           = Leaf
        ]]></code>
        <text hooks="math"><![CDATA[ 
To reiterate, notice that the relationship between the two function is <code>mapTree f = foldTree (\x -> Node (f x)) Leaf</code> (and we could have defined <code>mapTree</code> in this way):
        ]]></text>
        <code hooks="Haskell"><![CDATA[
mapTree f = foldTree (\x -> Node (f x)) Leaf
        ]]></code>
        <text hooks="math"><![CDATA[ 
In the above, we are taking advantage of Haskell's support for partially applying functions, since <code>Node</code> is partially applied to its result, which means <code>Node (f x)</code> is a function still waiting for two more arguments (the two subtrees). Alternatively but equivalently, we could have written the below definition:
        ]]></text>
        <code hooks="Haskell"><![CDATA[
mapTree f t = foldTree (\x t1 t2 -> Node (f x) t1 t2) Leaf t
        ]]></code>
      </example>
      <example required="true" id="5d4b1d495c5f4c03827519c53ad95ee2">
        <text hooks="math"><![CDATA[
Common operations on abstract syntax trees (such as evaluation and execution) can also be represented as fold operations. Suppose we have the following implementation for an abstract syntax for formulas (which we have seen in <a href="#beb651b8549a4706a411ce0af3cd0010">previous examples</a>):
        ]]></text>
        <code hooks="Haskell"><![CDATA[
@data Formula = 
    T
  | F
  | Not Formula
  | And Formula Formula
  | Or Formula Formula
  @deriving Show
        ]]></code>
        <text hooks="math"><![CDATA[ 
We first list all the constructors for <code>Formula</code> (we could also get this information using the <code>:t</code> command in GHCi):
        ]]></text>
        <code hooks="Haskell"><![CDATA[
T :: Formula
F :: Formula
Not :: Formula -> Formula
And :: Formula -> Formula -> Formula
Or :: Formula -> Formula -> Formula
        ]]></code>
        <text hooks="math"><![CDATA[ 
A fold function will simply replace all instances of each constructor in a tree with different value or function (for example, let's call <code>And</code>'s replacement <code>a</code> and <code>T</code>'s replacement <code>t</code>); this means that the replacement values and functions must have a type that has the same structure (i.e., they must take the same number of arguments) as the constructors they replace. However, they will fold into some new type of value <code>b</code>, so we replace every instance of <code>Formula</code> with the new result type <code>b</code>:
        ]]></text>
        <code hooks="Haskell"><![CDATA[
t :: b
f :: b
n :: b -> b
a :: b -> b -> b  
o :: b -> b -> b
        ]]></code>
        <text hooks="math"><![CDATA[ 
We can now write our <code>foldFormula</code> function to take the above five arguments, and then the formula tree that is being folded as the last argument.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
foldFormula :: b -> b -> (b -> b) -> (b -> b -> b) -> (b -> b -> b) -> Formula -> b
foldFormula t f n a o (T          ) = t
foldFormula t f n a o (F          ) = f
foldFormula t f n a o (Not formula) = n (foldFormula t f n a o formula) 
foldFormula t f n a o (And f1 f2  ) = a (foldFormula t f n a o f1) (foldFormula t f n a o f2)
foldFormula t f n a o (Or  f1 f2  ) = o (foldFormula t f n a o f1) (foldFormula t f n a o f2)
        ]]></code>
        <text hooks="math"><![CDATA[ 
We can now implement two evaluation algorithms easily: one that evaluates the tree as a native Haskell <code>Bool</code> result, and one that evaluates the tree as a native Haskell <code>Int</code> result:
        ]]></text>
        <code hooks="Haskell"><![CDATA[
evalAsBool :: Formula -> Bool
evalAsBool = foldFormula True False not (&&) (||) 

evalAsInt :: Formula -> Int
evalAsInt = foldFormula 1 0 ((-) 1) (*) max
        ]]></code>
        <text hooks="math"><![CDATA[ 
Notice that the <code>foldFormula</code> function acts as a form of encapsulation for the <code>Formula</code> data structure. Suppose we want to change the data type definition to the following (using a terminology for formulas that corresponds to terminology from the study of logic):
        ]]></text>
        <code hooks="Haskell"><![CDATA[
@data Formula = 
    Top
  | Bottom
  | Neg Formula
  | Conj Formula Formula
  | Disj Formula Formula
  @deriving Show
        ]]></code>
        <text hooks="math"><![CDATA[ 
We could then change the definition of <code>foldFormula</code> once, and would not need to change our implementations of <code>evalAsBool</code> and <code>evalAsInt</code> at all.
        ]]></text>
        <code hooks="Haskell"><![CDATA[
foldFormula :: b -> b -> (b -> b) -> (b -> b -> b) -> (b -> b -> b) -> Formula -> b
foldFormula t f n a o (Top         ) = t
foldFormula t f n a o (Bottom      ) = f
foldFormula t f n a o (Neg formula ) = n (foldFormula t f n a o formula) 
foldFormula t f n a o (Conj f1 f2  ) = a (foldFormula t f n a o f1) (foldFormula t f n a o f2)
foldFormula t f n a o (Disj  f1 f2 ) = o (foldFormula t f n a o f1) (foldFormula t f n a o f2)
        ]]></code>
      </example>
    </subsection>
  </section>
  <review title="Programming Language Concepts">
    <text><![CDATA[
This section contains a collection of review problems going over all the course material. These problems are an accurate representation of the kinds of problems you may see on a quiz or exam.
    ]]></text>
    <exercise required="true" id="d31915c941d848449c7fc5f7e6618355">
      <text hooks="math"><![CDATA[
Suppose you are given the following type definitions for representing simple English sentences:
      ]]></text>
      <code hooks="Haskell"><![CDATA[
@type Noun = String
@type Adjective = String
@type Verb = String
@type Adverb = String

@data NounPhrase = AN Adjective NounPhrase | N Noun
@data VerbPhrase = AV Adverb VerbPhrase | V Verb
@data Sentence = S NounPhrase VerbPhrase
      ]]></code>
      <orderedlist style="list-style-type:lower-alpha">
        <item>
          <text hooks="math"><![CDATA[
Determine the minimal substitution that solves the following equation under pattern-matching unification, or explain why no solution can exist (by demonstrating what base case causes an issue):
\begin{eqnarray}
<code>S (AN a (N "cat")) (V b)</code> & = & <code>S (AN "yellow" (N "cat")) (V "runs")</code>
\end{eqnarray}
          ]]></text>
        </item>
        <item>
          <text hooks="math"><![CDATA[
Determine the minimal substitution that solves the following equation under pattern-matching unification, or explain why no solution can exist (by demonstrating what base case causes an issue):
\begin{eqnarray}
<code>S (AN a (AN b (N "cat"))) (V c)</code> & = & <code>S (AN "yellow" (N "cat")) (V "runs")</code>
\end{eqnarray}
          ]]></text>
        </item>
        <item>
          <text hooks="math"><![CDATA[
Given the above data type definition, is it possible to write a single Haskell function pattern that will match any sentence in which <code>"cat"</code> is the subject?
          ]]></text>
        </item>
      </orderedlist>
    </exercise>
    <exercise required="true" id="2f9c5a17c5044724bfa04089a3f97d3d">
      <text hooks="math"><![CDATA[
Adjust the following grammar definition so that it accepts exactly the same set of token sequences, but is not left-recursive:
\begin{eqnarray}
number %n & ::= & <b>0</b> | <b>1</b> | ... | <b>9</b> \\
             & | & <b>%-</b> <b>(</b> %n <b>)</b> \\
             & | & %n <b>*</b> %n
\end{eqnarray}
      ]]></text>
    </exercise>
    <exercise required="true" id="2a357ccdb6414725b96f52e71d55f40e">
      <text hooks="math"><![CDATA[
Suppose you are given the following grammar definition and operational semantics:
\begin{eqnarray}
actor %r & ::= & <b>foo</b> 
            |  <b>bar</b> \\
action %a & ::= & <b>change</b> %r | <b>is</b> %r\\
\end{eqnarray}
      ]]></text>
      <inferences hooks="math">
        <inference>
          <premises><![CDATA[]]></premises>
          <conclusion><![CDATA[<b>is</b> %r \Downarrow <b>is</b> %r]]></conclusion>
        </inference>
        <inference>
          <premises><![CDATA[]]></premises>
          <conclusion><![CDATA[<b>change</b> <b>foo</b> \Downarrow <b>is</b> <b>bar</b>]]></conclusion>
        </inference>
        <inference>
          <premises><![CDATA[]]></premises>
          <conclusion><![CDATA[<b>change</b> <b>bar</b> \Downarrow <b>is</b> <b>foo</b>]]></conclusion>
        </inference>
      </inferences>
      <text hooks="math"><![CDATA[
According to the above operational semantics, to what should <b>change foo</b> evaluate?
      ]]></text>
    </exercise>
    <exercise required="true" id="e8146595d4df4e1fbc19b0f001af8dc8">
      <text hooks="math"><![CDATA[
Answer the following questions by drawing diagrams (your diagrams may need to incorporate self-loops).
      ]]></text>
      <orderedlist style="list-style-type:lower-alpha">
        <item>
          <text hooks="math"><![CDATA[
Determine which of the following terms refer to <b>data structures</b>, and which terms refer to <b>algorithms</b>. Draw a flow chart incorporating all of the above components that demonstrates how they might interact in an actual implementation (there may be more than one correct answer, but the way they interact must be reasonable):
<ul>
  <li>input file;</li>
  <li>abstract syntax trees;</li>
  <li>parser;</li>
  <li>compiler;</li>
  <li>type checker;</li>
  <li>error message;</li>
  <li>loop unroller;</li>
  <li>machine instruction sequences.</li>
</ul>
          ]]></text>
          <solution hooks="math"><![CDATA[
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:powderblue;">input<br/>file</td>
    <td></td>
    <td class="box" style="background-color:lightyellow;">loop<br/>unroller</td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td class="box" style="background-color:powderblue;">machine<br/>instruction<br/>sequences</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td></td>
    <td><span style="font-size:20px;">&uArr; &dArr;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td><span style="font-size:20px;">&uArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">parser</td>
    <td><span style="font-size:20px;">&rArr;</span></td>
    <td class="box" style="background-color:powderblue;">abstract<br/>syntax<br/>trees</td>
    <td><span style="font-size:20px;">&rArr;</span></td>
    <td class="box" style="background-color:lightyellow;">type<br/>checker</td>
    <td><span style="font-size:20px;">&rArr;</span></td>
    <td class="box" style="background-color:powderblue;">abstract<br/>syntax<br/>trees</td>
    <td><span style="font-size:20px;">&rArr;</span></td>
    <td class="box" style="background-color:lightyellow;">compiler</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td class="box" style="background-color:powderblue;">error<br/>messages</td>
    <td></td>
    <td></td>
    <td></td>
    <td class="box" style="background-color:powderblue;">error<br/>messages</td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
</table>
</div>
          ]]></solution>
        </item>
        <item>
          <text hooks="math"><![CDATA[
Draw a flow chart incorporating all of the below components that demonstrates how they might interact in an actual implementation:
<ul>
  <li>exhaustive case generator;</li>
  <li>abstract syntax trees;</li>
  <li>compiler;</li>
  <li>interpreter;</li>
  <li>machine instruction sequences;</li>
  <li>simulator;</li>
  <li>outputs;</li>
  <li>output comparison function.</li>
</ul>
          ]]></text>
          <solution hooks="math"><![CDATA[
<div class="diagram">
<table class="container">
  <tr>
    <td colspan="3" class="box" style="background-color:lightyellow;">exhaustive<br/>case<br/>generator</td>
    <td colspan="2"></td>
  </tr>
  <tr>
    <td colspan="3"><span style="font-size:20px;">&dArr;</span></td>
    <td colspan="2"></td>
  </tr>
  <tr>
    <td colspan="3" class="box" style="background-color:powderblue;">abstract<br/>syntax<br/>trees</td>
    <td colspan="2"></td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td></td>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td colspan="2"></td>
  </tr>
  <tr>
    <td class="box" style="background-color:lightyellow;">interpreter</td>
    <td></td>
    <td class="box" style="background-color:lightyellow;">compiler</td>
    <td><span style="font-size:20px;">&rArr;</span></td>
    <td class="box" style="background-color:powderblue;">machine<br/>instruction<br/>sequences</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td></td>
    <td></td>
    <td></td>
    <td><span style="font-size:20px;">&dArr;</span></td>
  </tr>
  <tr>
    <td class="box" style="background-color:powderblue;">outputs</td>
    <td></td>
    <td class="box" style="background-color:powderblue;">outputs</td>
    <td><span style="font-size:20px;">&lArr;</span></td>
    <td class="box" style="background-color:lightyellow;">simulator</td>
  </tr>
  <tr>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td></td>
    <td><span style="font-size:20px;">&dArr;</span></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td colspan="3" class="box" style="background-color:lightyellow;">output<br/>comparison<br/>function</td>
    <td></td>
    <td></td>
  </tr>
</table>
</div>
          ]]></solution>
        </item>
      </orderedlist>
    </exercise>
  </review>
  <final title="Programming Language Concepts">
    <instructions>
      <text><![CDATA[<i>This material is no longer available.</i>]]></text>
    </instructions>
  </final>
  <appendix title="Using gsubmit">
    <text><![CDATA[
In this course, you will submit your assignments using <code><a href="http://www.cs.bu.edu/teaching/hw/gsubmit/">gsubmit</a></code>. This section reproduces and extends some of the <a href="http://www.cs.bu.edu/teaching/hw/gsubmit/">instructions</a> already made available by the BU Computer Science Department.
    ]]></text>
    <subsection title="Register for a CS account">
      <text><![CDATA[
You must obtain a CS account to use the <code>csa</code> machines maintained by the CS Dept. You will need to physically visit the <a href="http://www.bu.edu/cs/resources/laboratories/undergraduate-lab/">undergraduate computing lab</a> located at 730 Commonwealth Avenue, on the third floor in room 302.
      ]]></text>
    </subsection>
    <subsection title="Download SSH/SCP client software">
      <text><![CDATA[
You will need an SCP or SFTP client (such as <a href="http://winscp.net/eng/index.php)">WinSCP</a> for Windows or <a href="http://cyberduck.ch/">CyberDuck</a> for OS X) to copy files from your local computer to your <code>csa</code> home directory. If you are using Windows, you will also need an SSH client (such as <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html">PuTTY</a>).
      ]]></text>
    </subsection>
    <subsection title="Submitting assignments using gsubmit">
      <text><![CDATA[
A typical workflow can be described as follows.
      ]]></text>
      <orderedlist>
        <item><![CDATA[
You assemble your assignment solution file(s) on your own computer or device.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:#EFEFEF;">
      local<br/>device
      <table class="container">
        <tr>
          <td class="box" style="background-color:lightyellow;">
            hw1
            <table class="container">
              <tr>
                <td class="box" style="background-color:powderblue;">hw1.py</td>
              </tr>
            </table>
          </td>
       </tr>
      </table>
    </td>
    <td><span style="font-size:20px;">&nbsp;&nbsp;&nbsp;</span></td>
    <td class="box" style="background-color:#EFEFEF;">
      your <code>csa2</code>/<code>csa3</code><br/>home directory
    </td>
    <td><span style="font-size:20px;">&nbsp;&nbsp;&nbsp;</span></td>
    <td class="box" style="background-color:#EFEFEF;">
      your <code>gsubmit</code><br/>directory for CS 320
    </td>
  </tr>
</table>
</div>
        ]]></item>
        <item>
          <text><![CDATA[
You log into <code>csa2</code> or <code>csa3</code> using an SCP or SSH client and create a directory for your submission in your CS account home directory. Note that in the examples below <code>%&gt;</code> represents a terminal prompt, which may look different on your system.
          ]]></text>
          <code hooks="Python"><![CDATA[
%> cd ~
%> mkdir hw1
          ]]></code>
          <text><![CDATA[
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:#EFEFEF;">
      local<br/>device
      <table class="container">
        <tr>
          <td class="box" style="background-color:lightyellow;">
            hw1
            <table class="container">
              <tr>
                <td class="box" style="background-color:powderblue;">hw1.py</td>
              </tr>
            </table>
          </td>
       </tr>
      </table>
    </td>
    <td><span style="font-size:20px;">&nbsp;&nbsp;&nbsp;</span></td>
    <td class="box" style="background-color:#EFEFEF;">
      your <code>csa2</code>/<code>csa3</code><br/>home directory
      <table class="container">
        <tr>
          <td class="box" style="background-color:lightyellow;">
            hw1<br/><br/><br/>
          </td>
       </tr>
      </table>
    </td>
    <td><span style="font-size:20px;">&nbsp;&nbsp;&nbsp;</span></td>
    <td class="box" style="background-color:#EFEFEF;">
      your <code>gsubmit</code><br/>directory for CS 320
    </td>
  </tr>
</table>
</div>
          ]]></text>
        </item>
        <item>
          <text><![CDATA[
If you have not already done so (e.g., if you were using an SSH client in the previous step), you log into <code>csa2</code> or <code>csa3</code> using an SCP client and copy your completed file(s) into that directory.
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:#EFEFEF;">
      local<br/>device
      <table class="container">
        <tr>
          <td class="box" style="background-color:lightyellow;">
            hw1
            <table class="container">
              <tr>
                <td class="box" style="background-color:powderblue;">hw1.py</td>
              </tr>
            </table>
          </td>
       </tr>
      </table>
    </td>
    <td><span style="font-size:20px;">&rArr;</span></td>
    <td class="box" style="background-color:#EFEFEF;">
      your <code>csa2</code>/<code>csa3</code><br/>home directory
      <table class="container">
        <tr>
          <td class="box" style="background-color:lightyellow;">
            hw1
            <table class="container">
              <tr>
                <td class="box" style="background-color:powderblue;">hw1.py</td>
              </tr>
            </table>
          </td>
       </tr>
      </table>
    </td>
    <td><span style="font-size:20px;">&nbsp;&nbsp;&nbsp;</span></td>
    <td class="box" style="background-color:#EFEFEF;">
      your <code>gsubmit</code><br/>directory for CS 320
    </td>
  </tr>
</table>
</div>
          ]]></text>
        </item>
        <item>
          <text><![CDATA[
If you have not already done so, you log into <code>csa2</code> or <code>csa3</code> using an SSH client and run the <code>gsubmit</code> commands to copy the files from your CS account home directory to the <code>gsubmit</code> directories to which the course staff has access.
          ]]></text>
          <code hooks="Python"><![CDATA[
%> cd ~
%> gsubmit cs320 hw1
          ]]></code>
          <text><![CDATA[
<div class="diagram">
<table class="container">
  <tr>
    <td class="box" style="background-color:#EFEFEF;">
      local<br/>device
      <table class="container">
        <tr>
          <td class="box" style="background-color:lightyellow;">
            hw1
            <table class="container">
              <tr>
                <td class="box" style="background-color:powderblue;">hw1.py</td>
              </tr>
            </table>
          </td>
       </tr>
      </table>
    </td>
    <td><span style="font-size:20px;">&rArr;</span></td>
    <td class="box" style="background-color:#EFEFEF;">
      your <code>csa2</code>/<code>csa3</code><br/>home directory
      <table class="container">
        <tr>
          <td class="box" style="background-color:lightyellow;">
            hw1
            <table class="container">
              <tr>
                <td class="box" style="background-color:powderblue;">hw1.py</td>
              </tr>
            </table>
          </td>
       </tr>
      </table>
    </td>
    <td><span style="font-size:20px;">&rArr;</span></td>
    <td class="box" style="background-color:#EFEFEF;">
      your <code>gsubmit</code><br/>directory for CS 320
      <table class="container">
        <tr>
          <td class="box" style="background-color:lightyellow;">
            hw1
            <table class="container">
              <tr>
                <td class="box" style="background-color:powderblue;">hw1.py</td>
              </tr>
            </table>
          </td>
       </tr>
      </table>
    </td>
  </tr>
</table>
</div>
          ]]></text>
        </item>
        <item>
          <text><![CDATA[
To view your submitted files, you can use the following command:
          ]]></text>
          <code hooks="Python"><![CDATA[
%> gsubmit cs320 -ls
          ]]></code>
          <text><![CDATA[
To look at a file that has already been submitted, you can use:
          ]]></text>
          <code hooks="Python"><![CDATA[
%> gsubmit cs320 -cat hw1/hw1.py
          ]]></code>
          <text><![CDATA[
<i>After</i> grades are posted (normally, this will be announced on the mailing list and in lecture), you can check your grade using:
          ]]></text>
          <code hooks="Python"><![CDATA[
%> gsubmit cs320 -cat grade.hw1.txt
          ]]></code>
        </item>
      </orderedlist>
    </subsection>
  </appendix>
  <appendix title="Python">
    <text><![CDATA[
The Python programming language will be among the languages we use in this course. This language supports the object-oriented, imperative, and functional programming paradigms, has automatic memory managememt, and natively supports common high-level data structures such as lists and sets. Python is often used as an interpreted language, but it can also be compiled.
    ]]></text>
    <subsection title="Obtaining Python">
      <text><![CDATA[
The latest version of Python 3 can be downloaded at: <b><a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a></b>. In this course, we will require the use if <b>Python 3</b>, which has been installed on all the <a href="http://www.bu.edu/cs/resources/laboratories/undergraduate-lab/">CS Department's undergraduate computing lab</a> machines, as well as on <code>csa2/csa3</code>.
      ]]></text>
    </subsection>
    <subsection title="Assembling a Python module">
      <text><![CDATA[
The simplest Python program is a single file (called a <i>module</i>) with the file extension <code>.py</code>. For example, suppose the following is contained within a file called <code>example.py</code>:
      ]]></text>
      <code hooks="Python">
# This is a comment in "example.py".
# Below is a Python statement.
@print("Hello, world.")
      </code>
      <text><![CDATA[
Assuming Python is installed on your system, to run the above program from the command line you can use the following (you may need to use <code>python3</code>, <code>python3.2</code>, <code>python3.3</code>, etc. depending on the Python installation you're using). Note that in the examples below <code>%&gt;</code> represents a terminal prompt, which may look different on your system.
      ]]></text>
      <code hooks="Python">
%> python example.py
Hello, world.
      </code>
      <text><![CDATA[
If you run Python without an argument on the command line, you will enter Python's interactive prompt. You can then evaluate expressions and execute individual statements using this prompt; you can also load and execute a Python module file:
      ]]></text>
      <code hooks="Python">
%> python
Python 3.2 ...
Type "help", "copyright", "credits" or "license" for more information.
>>> @exec(@open("example.py").read()) # Load "example.py" module.
Hello, world.
>>> x = "Hello." # Execute an assignment statement.
>>> @print(x)     # Execute a "print" statement.
Hello.
>>> x            # Evaluate a string expression.
'Hello.'
>>> 1 + 2        # Evaluate a numerical expression.
3
      </code>
    </subsection>
    <subsection title="Common data structures (i.e., Python expressions)">
      <text><![CDATA[
Python provides native support for several data structures that we will use throughout this course: integers, strings, lists, tuples, sets, and dictionaries (also known as finite maps). In this subsection, we present how instances of these data structures are represented in Python, as well as the most common operations and functions that can be applied to these data structure instances.
      ]]></text>
      <unorderedlist>
        <item>
          <text><![CDATA[<b>Booleans</b> consist of two constants: <code>True</code> and <code>False</code>.]]></text>
          <unorderedlist>
            <item><![CDATA[The usual logical operations are available using the operators <code>and</code>, <code>or</code>, and <code>not</code>.]]></item>
          </unorderedlist>
          <code hooks="Python">
>>> @True                                      # A boolean constant.
@True
>>> @False                                     # A boolean constant.
@False
>>> @True @and @False @or @True @and (@not @False)    # A boolean expression.
@True
          </code>
        </item>
        <item>
          <text><![CDATA[<b>Integers</b> are written as in most other programming languages (i.e., as a sequence of digits).]]></text>
          <unorderedlist>
            <item><![CDATA[The usual arithmetic operations are available using the operators <code>+</code>, <code>*</code>, <code>-</code>, and <code>/</code>. The infix operator <code>//</code> represents integer division, and the infix operators <code>**</code> represents exponentiation. Negative integers are prefixed with the negation operator <code>-</code>.]]></item>
            <item><![CDATA[The usual relational operators <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> are available.]]></item>
            <item><![CDATA[The <code>int()</code> function can convert a string that looks like an integer into an integer.]]></item>
          </unorderedlist>
          <code hooks="Python">
>>> 123                                       # An integer constant.
123
>>> 1 * (2 + 3) // 4 - 5                      # An integer expression.
-4
>>> 4 * 5 >= 19                               # A boolean expression involving integers.
@True
>>> @int("123")                                # A string being converted into an integer
123
          </code>
        </item>
        <item>
          <text><![CDATA[<b>Strings</b> are delimited by either <code>'</code> or <code>"</code> characters. Strings can be treated as lists of single-character strings. Another way to look at this is that there is no distinction between a character and a string: all characters are just strings of length 1. Multiline strings can be delimited using <code>"""</code> or <code>'''</code> (i.e., three quotation mark characters at the beginning and end of the string literal).]]></text>
          <unorderedlist>
            <item><![CDATA[The empty string is denoted using <code>''</code> or <code>""</code>.]]></item>
            <item><![CDATA[Two strings can be concatenated using <code>+</code>.]]></item>
            <item><![CDATA[The function <code>len()</code> returns the length of a string.]]></item>
            <item><![CDATA[Individual characters in a string can be accessed using the bracketed index notation (e.g., <code>s[i]</code>). These characters are also strings themselves.]]></item>
          </unorderedlist>
          <code hooks="Python">
>>> 'Example.'                                # A string.
'Example.'
>>> "Example."                                # Alternate notation for a string.
'Example.'
>>> @len("ABCD")                               # String length.
4
>>> "ABCD" + "EFG"                            # String concatenation.
'ABCDEFG'
>>> "ABCD"[2]                                 # Third character in the string.
'C'
          </code>
        </item>
        <item>
          <text><![CDATA[<b>Lists</b> are similar to arrays: they are ordered sequences of objects and/or values. The entries of a list can be of a mixture of different types, and lists containing one or more objects are delimited using <code>[</code> and <code>]</code>, with the individual list entries separated by commas. Lists cannot be members of sets.]]></text>
          <unorderedlist>
            <item><![CDATA[The empty list is denoted using <code>[]</code>.]]></item>
            <item><![CDATA[Two lists can be concatenated using <code>+</code>.]]></item>
            <item><![CDATA[The function <code>len()</code> returns the length of a list.]]></item>
            <item><![CDATA[Individual entries in a list can be accessed using the bracketed index notation (e.g., <code>a[i]</code>).]]></item>
            <item><![CDATA[To check if a value is in a list, use the <code>in</code> relational operator.]]></item>
          </unorderedlist>
          <code hooks="Python">
>>> [1,2,"A","B"]                             # A list.
[1, 2, 'A', 'B']
>>> [1, 2] + ['A','B']                        # Concatenating lists.
[1, 2, 'A', 'B']
>>> @len([1,2,"A","B"] )                       # List length.
4
>>> [1,2,"A","B"][0]                          # First entry in the list.
1
>>> 1 @in [1, 2]                               # List containment check.
@True
          </code>
        </item>
        <item>
          <text><![CDATA[<b>Tuples</b> are similar to lists (they are ordered, and can contain objects of different types), except they are delimited by parentheses <code>(</code> and <code>)</code>, with entries separated by commas. The main distinction between lists and tuples is that tuples are hashable (i.e., they can be members of sets).]]></text>
          <unorderedlist>
            <item><![CDATA[The empty tuple is denoted using <code>()</code>.]]></item>
            <item><![CDATA[A tuple containing a single object <code>x</code> is denoted using <code>(x, )</code>.]]></item>
            <item><![CDATA[Two tuples can be concatenated using <code>+</code>.]]></item>
            <item><![CDATA[A tuple can be turned into a list using the <code>list()</code> function.]]></item>
            <item><![CDATA[A list can be turned into a tuple using the <code>tuple()</code> function.]]></item>
            <item><![CDATA[The function <code>len()</code> returns the length of a tuple.]]></item>
            <item><![CDATA[Individual entries in a tuple can be accessed using the bracketed index notation (e.g., <code>t[i]</code>).]]></item>
            <item><![CDATA[To check if a value is in a tuple, use the <code>in</code> relational operator.]]></item>
          </unorderedlist>
          <code hooks="Python">
>>> (1,2,"A","B")                             # A tuple.
(1, 2, 'A', 'B')
>>> (1,)                                      # Another tuple.
(1,)
>>> (1, 2) + ('A','B')                        # Concatenating tuples.
(1, 2, 'A', 'B')
>>> @list((1, 2, 'A','B'))                     # A tuple being converted into a list.
[1, 2, 'A', 'B']
>>> @tuple([1, 2, 'A','B'])                    # A list being converted into a tuple.
(1, 2, 'A', 'B')
>>> @len((1,2,"A","B"))                        # Tuple length.
4
>>> (1,2,"A","B")[0]                          # First entry in the tuple.
1
>>> 1 @in (1, 2)                               # Tuple containment check.
@True
          </code>
        </item>
        <item>
          <text><![CDATA[<b>Sets</b> are unordered sequences that cannot contain duplicates. They are a close approximation of mathematical sets. Sets cannot be members of sets.]]></text>
          <unorderedlist>
            <item><![CDATA[The empty set is denoted using <code>set()</code>.]]></item>
            <item><![CDATA[The methods <code>.union()</code> and <code>.intersect</code> correspond to the standard set operations.]]></item>
            <item><![CDATA[A list or tuple can be turned into a set using the <code>set()</code> function.]]></item>
            <item><![CDATA[A set can be turned into a list or tuple using the <code>list()</code> or <code>list()</code> function, respectively.]]></item>
            <item><![CDATA[The function <code>len()</code> returns the size of a set.]]></item>
            <item><![CDATA[To access individual entries in a set, it is necessary to turn the set into a list or tuple.]]></item>
            <item><![CDATA[To check if a value is in a set, use the <code>in</code> relational operator.]]></item>
          </unorderedlist>
          <code hooks="Python">
>>> {1,2,"A","B"}                             # A set.
{1, 2, 'A', 'B'}
>>> ({1,2}.union({3,4})).intersection({4,5})  # Set operations.
{4}
>>> @set([1, 2]).union(@set(('A','B')))         # Converting a list and a tuple to sets.
{'A', 1, 2, 'B'}
>>> @len({1,2,"A","B"})                        # Set size.
4
>>> 1 @in {1,2,"A","B"}                        # Tuple containment check.
@True
          </code>
        </item>
        <item>
          <text><![CDATA[<b>Frozen sets</b> are like sets, except they can be members of other sets. A set can be turned into a frozen set using the <code>frozenset()</code> function.]]></text>
          <code hooks="Python">
>>> @frozenset({1,2,3})                        # A frozen set.
@frozenset({1, 2, 3})
>>> {@frozenset({1,2}), @frozenset({3,4})}      # Set of frozen sets.
{@frozenset({3, 4}), @frozenset({1, 2})}
          </code>
        </item>
        <item>
          <text><![CDATA[<b>Dictionaries</b> are unordered collections of associations between some set of keys and some set of values. Dictionaries are also known as finite maps.]]></text>
          <unorderedlist>
            <item><![CDATA[The empty dictionary is denoted using <code>{}</code>.]]></item>
            <item><![CDATA[The list of keys that the dictionary associates with values can be obtained using <code>list(d.keys())</code>.]]></item>
            <item><![CDATA[The list of values that the dictionary contains can be obtained using <code>list(d.values())</code>.]]></item>
            <item><![CDATA[The function <code>len()</code> returns the number of entries in the dictionary.]]></item>
            <item><![CDATA[Individual entries in a dictionary can be accessed using the bracketed index notation (e.g., <code>d[key]</code>).]]></item>
          </unorderedlist>
          <code hooks="Python">
>>> {"A":1, "B":2}                            # A dictionary.
{'A': 1, 'B': 2}
>>> @list({"A":1, "B":2}.keys())               # Dictionary keys.
['A', 'B']
>>> @list({"A":1, "B":2}.values())             # Dictionary values.
[1, 2]
>>> @len({"A":1, "B":2})                       # Dictionary size.
2
>>> {"A":1, "B":2}["A"]                       # Obtain a dictionary value using a key.
1
          </code>
        </item>
      </unorderedlist>
    </subsection>
    <subsection title="Function, procedure, and method invocations">
      <text><![CDATA[
Python provides a variety of ways to supply parameter arguments when invoking functions, procedures, and methods.
      ]]></text>
      <unorderedlist>
        <item>
          <text><![CDATA[
 <b>Function calls and method/procedure invocations</b> consist of the function, procedure, or method name followed by a parenthesized, comma-delimited list of arguments. For example, suppose a function or procedure <code>example()</code> is defined as follows:
          ]]></text>
          <code hooks="Python">
@def example(x, y, z):
  @print("Invoked.")
  @return x + y + z
          </code>
          <text><![CDATA[
    To invoke the above definition, we can use one of the following techniques.
          ]]></text>
          <unorderedlist>
            <item>
              <text><![CDATA[
<b>Passing arguments directly</b> involves listing the comma-delimited arguments directly between parentheses.
              ]]></text>
              <code hooks="Python">
>>> example(1,2,3)
Invoked.
6
              </code>
            </item>
            <item>
              <text><![CDATA[
<b>The argument unpacking operator</b> (also known as the <code>*</code>-operator, the <b>scatter</b> operator, or the <b>splat</b> operator) involves providing a list to the function, preceded by the <code>*</code> symbol; the arguments will be drawn from the elements in the list.
              ]]></text>
              <code hooks="Python">
>>> args = [1,2,3]
>>> example(*args)
Invoked.
6
              </code>
            </item>
           <item>
              <text><![CDATA[
<b>The keyword argument unpacking operator</b> (also known as the <code>**</code>-operator) involves providing a dictionary to the function, preceded by the <code>**</code> symbol; each named paramter in the function definition will be looked up in the dictionary, and the value associated with that dictionary key will be used as the argument passed to that parameter.
              ]]></text>
              <code hooks="Python">
>>> args = {'z':3, 'x':1, 'y':2}
>>> example(**args)
Invoked.
6
              </code>
            </item>
          </unorderedlist>
        </item>
        <item>
          <text><![CDATA[
<b>Default parameter values</b> can be specified in any definition. Suppose the following definition is provided.
          ]]></text>
          <code hooks="Python">
@def example(x = 1, y = 2, z = 3):
  @return x + y + z
          </code>
          <text><![CDATA[
The behavior is then as follows: if an argument corresponding to a parameter is not supplied, the default value found in the definition is used. If an argument is supplied, the supplied argument value is used.
          ]]></text>
          <code hooks="Python">
>>> example(0, 0)
3
>>> example(0)
5
>>> example()
6
          </code>
        </item>
      </unorderedlist>
    </subsection>
    <subsection title="Comprehensions">
      <text><![CDATA[
Python provides concise notations for defining data structures and performing logical computations. In particular, it support a comprehension notation that can be used to build lists, tuples, sets, and dictionaries.
      ]]></text>
      <unorderedlist>
        <item>
          <text><![CDATA[<b>List comprehensions</b> make it possible to construct a list by iterating over one or more other data structure instances (such as a list, tuple, set, or dictionary) and performing some operation on each element or combination of elements. The resulting list will contain the result of evaluating the body for every combination.]]></text>
          <code hooks="Python">
>>> [ x @for x @in [1,2,3] ]
[1, 2, 3]
>>> [ 2 * x @for x @in {1,2,3} ]
[2, 4, 6]
>>> [ x + y @for x @in {1,2,3} @for y @in (1,2,3) ]
[2, 3, 4, 3, 4, 5, 4, 5, 6]
          </code>
          <text><![CDATA[It is also possible to add conditions anywhere after the first <code>for</code> clause. This will filter which combinations are actually used to add a value to the resulting list.]]></text>
          <code hooks="Python"><![CDATA[
>>> [ x @for x @in {1,2,3} @if x < 3 ]
[1, 2]
>>> [ x + y @for x @in {1,2,3} @for y @in (1,2,3) @if x > 2 @and y > 1 ]
[5, 6]
          ]]></code>
        </item>
        <item>
          <text><![CDATA[<b>Set comprehensions</b> make it possible to construct a set by iterating over one or more other data structure instances (such as a list, tuple, set, or dictionary) and performing some operation on each element or combination of elements. The resulting list will contain the result of evaluating the body for every combination. Notice that the result will contain no duplicates because the result is a set.]]></text>
          <code hooks="Python">
>>> { x @for x @in [1,2,3,1,2,3] }
{1, 2, 3}
          </code>
        </item>
        <item>
          <text><![CDATA[<b>Dictionary comprehensions</b> make it possible to construct a dictionary by iterating over one or more other data structure instances (such as a list, tuple, set, or dictionary) and performing some operation on each element or combination of elements. The resulting dictionary will contain the result of evaluating the body for every combination.]]></text>
          <code hooks="Python">
>>> { key : 2 @for key @in ["A","B","C"] }
{'A': 2, 'C': 2, 'B': 2}
          </code>
        </item>
      </unorderedlist>
    </subsection>
    <subsection title="Other useful built-in functions">
      <text><![CDATA[
The built-in function <code>type()</code> can be used to determine the type of a value. Below, we provide examples of how to check whether a given expression has one of the common Python types:
      ]]></text>
      <code hooks="Python">
>>> @type(@True) == @bool
@True
>>> @type(123) == @int
@True
>>> @type("ABC") == @str
@True
>>> @type([1,2,3]) == @list
@True
>>> @type(("A",1,{1,2})) == @tuple
@True
>>> @type({1,2,3}) == @set
@True
>>> @type({"A":1, "B":2}) == @dict
@True
      </code>
    </subsection>
    <subsection title="Common Python definition and control constructs (i.e., Python statements)">
      <text><![CDATA[
A Python program is a sequence of Python statements. Each statement is either a function definition, a variable assignment, a conditional statement (i.e., <code>if</code>, <code>else</code>, and/or <code>elif</code>), an iteration construct (i.e., a <code>for</code> or <code>while</code> loop), a <code>return</code> statement, or a <code>break</code> or <code>continue</code> statement.
      ]]></text>
      <unorderedlist>
        <item>
          <text><![CDATA[<b>Variable assignments</b> make it possible to assign a value or object to a variable.]]></text>
          <code hooks="Python">
x = 10
          </code>
          <text><![CDATA[It is also possible to assign a tuple (or any computation that produces a tuple) to another tuple:]]></text>
          <code hooks="Python">
(x, y) = (1, 2)
          </code>
        </item>
        <item>
          <text><![CDATA[<b>Function and procedure definitions</b> consist of the <code>def</code> keyword, followed by the name of the function or procedure, and then by one or more arguments (delimited by parentheses and separated by commas).]]></text>
          <code hooks="Python">
@def example(a, b, c):
    @return a + b + c
          </code>
        </item>
        <item>
          <text><![CDATA[<b>Conditional statements</b> consist of one or more branches, each with its own boolean expression as the condition (with the exception of <code>else</code>). The body of each branch is an indented sequence of statements.]]></text>
          <code hooks="Python"><![CDATA[
@def fibonacci(n):
    # Computes the nth Fibonacci number.
    @if n <= 0:
        @return 0
    @elif n <= 2:
        @return 1
    @else:
        @return fibonacci(n-1) + fibonacci(n-2)
          ]]></code>
        </item>
        <item>
          <text><![CDATA[<b>Iteration constructs</b> make it possible to repeat a sequence of statements over and over. The body of an iteration construct is an indented sequence of statements.]]></text>
          <unorderedlist>
            <item>
              <text><![CDATA[The <b>while</b> construct has a boolean expression as its condition (much like <code>if</code>). The body is executed over and over until the expression in the condition evaluates to <code>False</code>, or a <code>break</code> statement is encountered.]]></text>
              <code hooks="Python"><![CDATA[
@def example1(n):
    # Takes an integer n and returns the sum of
    # the integers from 1 to n-1.
    i = 0
    sum = 0
    @while i < n:
        sum = sum + i
        i = i + 1
    @return sum

@def example2(n):
    # Takes an integer n and returns the sum of
    # the integers from 1 to n-1.
    i = 0
    sum = 0
    @while True:
        sum = sum + i
        i = i + 1
        @if i == n:
            @break
    @return sum
              ]]></code>
            </item>
            <item>
              <text><![CDATA[The <b>for</b> construct makes it possible to repeat a sequence of statements once for every object in a list, tuple, or set, or once for every key in a dictionary.]]></text>
              <code hooks="Python"><![CDATA[
@def example3(n):
    # Takes an integer n and returns the sum of
    # the integers from 1 to n-1.
    sum = 0
    @for i @in @range(0,n):
        sum = sum + i
    @return sum

@def example4(d):
    # Takes a dictionary d that maps keys to
    # integers and returns the sum of the integers.
    sum = 0
    @for key @in d:
        sum = sum + d[key]
    @return sum
              ]]></code>
            </item>
          </unorderedlist>
        </item>
      </unorderedlist>
    </subsection>
  </appendix>
  <appendix title="Haskell">
    <text><![CDATA[
The Haskell programming language will be among the languages we use in this course. This language supports the functional programming paradigm, has automatic memory managememt, and natively supports algebraic data types. Haskell is both an interpreted and compiled language.
    ]]></text>
    <subsection title="Obtaining Haskell">
      <text><![CDATA[
The latest version of Haskell can be downloaded with the Haskell Platform: <b><a href="http://www.haskell.org/platform/">http://www.haskell.org/platform/</a></b>. The Haskell Platform has been installed on all the <a href="http://www.bu.edu/cs/resources/laboratories/undergraduate-lab/">CS Department's undergraduate computing lab</a> machines, as well as on <code>csa2/csa3</code>.
      ]]></text>
    </subsection>    
    <subsection title="Haskell modules and declarations">
      <text><![CDATA[
Haskell code is organized into <i>modules</i>. There is one named module per Haskell file, and the file name should match the module name (e.g., the file <code>Example.hs</code> should contain the <code>Example</code> module definition). The module body consists of a series of declarations, which can appear in any order; the only exception is that if there are multiple declarations for a function, they must all be grouped together.
      ]]></text>
      <code hooks="Haskell"><![CDATA[
@module Example @where

g (x) = f(x) + f(x);

f (0) = 0;
f (x) = f(x - 1) + 1;

-- This is a comment.
      ]]></code>
      <text><![CDATA[
Each declaration in a Haskell module falls into one of two categories: an expression-level declaration, or a type-level declaration. Any declaration that defines variables or functions is an expression-level declaration; any declaration that defines a type is a type-level declaration.
      ]]></text>
      <code hooks="Haskell"><![CDATA[
-- Expression-level declaration (defines a new function called "f").
f(x) = 2 * x                      

-- Type-level declaration (defines a new data type called "Tree".
@data Tree = Leaf | Node Tree Tree 
      ]]></code>
    </subsection>
    <subsection title="Common data structures (i.e., Haskell expressions)">
      <text><![CDATA[
The Haskell <a href="http://hackage.haskell.org/package/base">base</a> library (sometimes also called the "Prelude", and imported implicitly and automatically into every module) has a large number of standard and conventional data type and function declarations. These declarations provide native support for a variety of data structures and operations that we will use throughout this course: integers, strings, lists, and tuples, among others. In this subsection, we present how instances of these data structures are represented in Haskell, as well as the most common operations and functions that can be applied to these data structure instances.
      ]]></text>
      <unorderedlist>
        <item>
          <text><![CDATA[The <b>Bool</b> data type supports two constructors: <code>True</code> and <code>False</code>.]]></text>
          <unorderedlist>
            <item><![CDATA[
              The usual logical operations are available using the operators <code>&&</code>, <code>||</code>, and <code>not</code>.
            ]]></item>
            <item><![CDATA[
              The built-in syntax <code>if ... then ... else ...</code> is also available (similar to Python's <code>... if ... else ...</code> and C/C++/Java's ternary operator <code> ... ? ... : ...</code>.
            ]]></item>
          </unorderedlist>
          <code hooks="Haskell"><![CDATA[
*> True
True
*> False
False
*> True || False && True && (not False)
True
*> @if True @then "Yes" @else "No"
"Yes"
          ]]></code>
        </item>
        <item>
          <text><![CDATA[<b>Integers</b> are written as in most other programming languages (i.e., as a sequence of digits). Haskell supports a bounded-size type <code>Int</code> and an unbounded-size type <code>Integer</code>.]]></text>
          <unorderedlist>
            <item><![CDATA[The usual arithmetic operations are available using the operators <code>+</code>, <code>*</code>, <code>-</code>, <code>/</code>, and <code>^</code>. The <code>Prelude</code> function <code>div</code> represents integer division. The <code>Prelude</code> functions <code>min</code> and <code>max</code> make it possible to compute the minimum and maximum of two integers, respectively, and the function <code>minimum</code> and <code>maximum</code> make it possible to compute the minimum and maximum of a list of integers. Negative integers are prefixed with the negation operator <code>-</code>.]]></item>
            <item><![CDATA[The usual relational operators <code>==</code>, <code>/=</code> (not equal), <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> are available.]]></item>
          </unorderedlist>
          <code hooks="Haskell"><![CDATA[
*> 123
123
*> 1 * (2 + 3) `div` 4 - 5
-4
*> 4 * 5 >= 19
True
*> max 10 20
20
*> minimum [1,2,3]
1
          ]]></code>
        </item>
        <item>
          <text><![CDATA[<b>Strings</b> are delimited by <code>"</code> characters (individual characters are always delimited using <code>'</code>). Strings can be treated as lists of characters.]]></text>
          <unorderedlist>
            <item><![CDATA[The empty string is denoted using <code>""</code>.]]></item>
            <item><![CDATA[Two strings can be concatenated using <code>++</code>.]]></item>
            <item><![CDATA[The <code>Prelude</code>function <code>length</code> returns the length of a string.]]></item>
          </unorderedlist>
          <code hooks="Haskell"><![CDATA[
*> "Example."        -- A string.
"Example."
*> length "ABCD"     -- String length.
4
*> "ABCD" ++ "EFG"   -- String concatenation.
"ABCDEFG"
          ]]></code>
        </item>
        <item>
          <text><![CDATA[<b>Lists</b> are ordered sequences of expressions. The entries of a list must all be of the same type. Lists are delimited using <code>[</code> and <code>]</code>, with the individual list entries separated by commas.]]></text>
          <unorderedlist>
            <item><![CDATA[The empty list is denoted using <code>[]</code>.]]></item>
            <item><![CDATA[Elements can be added to the front of a list using <code>:</code>.]]></item>
            <item><![CDATA[Two lists can be concatenated using <code>++</code>.]]></item>
            <item><![CDATA[The <code>Prelude</code> function <code>length</code> returns the length of a list.]]></item>
            <item><![CDATA[To check if a value is in a list, use the <code>Prelude</code> function <code>elem</code> (note that this relies on the <code>==</code> operation being defined on the type of the elements in the list).]]></item>
          </unorderedlist>
          <code hooks="Haskell"><![CDATA[
*> [1,2,3]            -- A list.
[1,2,3]
*> 1 : [2,3]          -- Adding an element to the front.
[1,2,3]
*> [1,2,3] ++ [4,5]   -- Concatenating lists.
[1,2,3,4,5]
*> length [1,2,3,4]   -- List length.
4
*> 1 `elem` [1, 2]    -- List containment check.
True
          ]]></code>
        </item>
        <item>
          <text><![CDATA[<b>Tuples</b> are ordered, and can contain expressions of different types. They are delimited by parentheses <code>(</code> and <code>)</code>, with entries separated by commas.]]></text>
          <unorderedlist>
            <item><![CDATA[The empty tuple is denoted using <code>()</code>.]]></item>
            <item><![CDATA[There are no tuples containing a single element; <code>(e)</code> is equivalent to <code>e</code> for any Haskell expression <code>e</code>.]]></item>
          </unorderedlist>
          <code hooks="Haskell"><![CDATA[
*> (1,2,3)  -- A tuple.
(1,2,3)
          ]]></code>
        </item>
      </unorderedlist>
    </subsection>
  </appendix>
</sheaf>
